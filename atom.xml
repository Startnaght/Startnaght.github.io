<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小狐仙</title>
  <icon>https://www.gravatar.com/avatar/f134cc5c44704ea724b8cc60781a4b82</icon>
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-06-24T15:50:35.436Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小狐仙</name>
    <email>507566350@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java-枚举类和注解</title>
    <link href="http://yoursite.com/2022/06/24/java-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/06/24/java-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-06-24T10:48:52.000Z</published>
    <updated>2022-06-24T15:50:35.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>1、jdk5.0新增的功能<br>2、Annotation 其实就是代码里面的特殊标记，这些标记可以在编译，类加载，运行时被加载，并在程序员不改变原逻辑的情况下，在源文件中嵌入一些补充信息。<br>3、在javaSe中，注解的使用目的比较简单，列如标记过时的功能，忽略警告等，在javaEE中注解占据更重要的的角色，列如来配置应用程序的人任何切面，替代SE遗留的大量xml配置和繁重代码。</p><h3 id="内置的基本注解"><a href="#内置的基本注解" class="headerlink" title="内置的基本注解"></a>内置的基本注解</h3><blockquote><p>jdk内置的三个基本注解<br>@Override:限定重写父类方法，该注解只能用于方法<br>@Deprecated:用于表示所修饰的元素(类方法等)已过时，通常是因为所修饰的结构危险<br>@SuppressWarnings:抑制编译器警告</p></blockquote><h3 id="自定义注解注解"><a href="#自定义注解注解" class="headerlink" title="自定义注解注解"></a><font color="red">自定义注解<sup><a href="#fn_注解" id="reffn_注解">注解</a></sup></font></h3><blockquote><p>①注解声明为:@interface,参照@SuppressWarnings定义<br>Annotation的成员变量在Annotation的定义中为无参方法的形式来声明其值定义了该成员的名字和类型,配置类型为八种基本数据类型(一般情况下只有一个成员变量参数名使用value(),默认值设置则用<font color="red">default&lt;/font &gt;来)<br>②内部定义成员,通常使用value来表示<br>③可以指定成员的默认值,使用defalu来定义<br>④如果自定义注解没有成员,则是一个<font color="blue">标识</font>作用</p></blockquote><font color="red">如果注解有成员,在使用注解时需要传入值</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个注解,传入一个字符串给这个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="title">defalut</span><span class="params">(<span class="string">&quot;words&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个注解</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;hellos&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人走路!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元Annotation用于修饰其他Annotation的定义(元数据<sup><a href="#fn_元数据" id="reffn_元数据">元数据</a></sup>)<br>jdk5.0提供了4个标准的meta-Annotation的类型分别是</p><blockquote><p><font color="red">@Retention</font>:只能用于修饰一个Annotation定义,用于指定该Annotation的生命周期,@Retention包含一个<font color="red">RetentionPolicy</font>类型的成员变量,使用时必须为其指定该value成员变量指定的值</p><blockquote><p><font color="red">RetentionPolicy.SOURCE:</font>在源文件中有效(即源文件保留),编译器直接丢弃这种策略的注释<br>   <font color="red">RetentionPolicy.CLASS:</font>在class文件中有效(即class保留),当运行java程序时,JVM不会保留注解,这是默认值<br>   <font color="red">RetentionPolicy.RUNTIME:</font>在运行时有效(即运行时保留),当运行java程序时,JVM会保留注解,程序可以通过反射获得该注解<br>   <img src="img/RetentionPolicy流程.png"><br>   <img src="img/RetentionPolicy中的枚举类.png">  </p></blockquote><p><font color="red">@Target</font>:用来修饰Annotation定义,用于指定被修饰的Annotation能用于修饰哪些程序元素,@Target也包含一个名为value的成员变量</p><blockquote><p>详细如下↓</p></blockquote></blockquote><div class="table-container"><table><thead><tr><th>取值(ElementType)</th><th></th><th>取值(ElementType)</th><th></th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于描述构造器</td><td>PACKAGE</td><td>用于描述包</td></tr><tr><td>FIELD</td><td>用于描述域</td><td>PARAMETER</td><td>用于描述参数</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于描述局部变量</td><td>TRPE</td><td>用于描述类,接口(包含注解类型)或enum声明</td></tr><tr><td>METHOD</td><td>用于描述方法</td><td></td></tr></tbody></table></div><p><img src="img/Target枚举类.png"></p><blockquote><p><font color="red">@Documented</font>:表示所修饰的Annotation类会被Javadoc提取为文档</p><p><font color="red">@Inherited</font>:被它修饰的Annotation会具有<font color="red">继承性</font>,如果某类被注解了Inherited及其子类会自动继承父类级别的注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Text</span></span><br><span class="line"><span class="comment">//通过反射获取注解信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">textGetAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz Student.class;</span><br><span class="line">    Annotation[] annotation clazz.getAnnotation();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;annotation.length;i++&gt;)&#123;</span><br><span class="line">        System.out.println(annotation[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote id="fn_注解"><sup>注解</sup>. 自定义注解必须配上注解信息处理流程才有意义(反射实现)<a href="#reffn_注解" title="Jump back to footnote [注解] in the text."> &#8617;</a></blockquote><blockquote id="fn_元数据"><sup>元数据</sup>. 在数据库中对于现有数据的修饰<a href="#reffn_元数据" title="Jump back to footnote [元数据] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h2&gt;&lt;p&gt;1、jdk5.0新增的功能&lt;br&gt;2、Annotation 其实就是代码里面的特殊标记，这些标记可以在编译，类加载，运行时被加载，并在程序员</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习计划</title>
    <link href="http://yoursite.com/2022/06/24/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
    <id>http://yoursite.com/2022/06/24/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</id>
    <published>2022-06-24T02:19:01.000Z</published>
    <updated>2022-06-24T02:26:27.264Z</updated>
    
    <content type="html"><![CDATA[<p>Java 学习路线一条龙版 by 鱼皮。</p><p>原创不易，请勿抄袭，违者必究！</p><p>大家好，我是鱼皮。现在网上的编程资料实在太多了，而且人人肯定都说自己的最好，那就导致大家又不知道怎么选了。大部分的博主推荐资源，也就是把播放量高的视频说一遍，水一期视频，没有一条很清晰的学习路线。</p><p>所以今天我的这个 Java 学习路线就做做减法，给大家来个一条龙服务，Java 要学的知识点、对应的最佳学习资源和预计要花费的时间，都安排的明明白白的，不用选了，有计划了，也别再迷茫和纠结了，就无脑跟着学就行了。</p><p>大纲<br>实在太长了，没办法全部展开，只能放个大纲了。。。</p><p>图片<br>鱼皮 - Java 学习路线 一条龙版本<br>路线特点<br>最新，完整一条龙，从入门到入土（⭐ 表示推荐学习）</p><p>给出目标、学习建议、关键知识点、最优资源以及各类资源推荐（视频、书籍、文档、项目、工具等）</p><p>鱼皮自己是 Java 开发者，融入个人经历 + 思考，让路线有灵魂</p><p>划分阶段、更有计划，且在最后给出持续学习的方向、探索 Java 程序员发展的无限可能</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先呢，我们要了解 Java 的应用场景和就业方向，看看和自己的学习目的是否一致，目前，Java 的岗位需求多，是后台开发的主流编程语言，功能强大，还是很值得学习的。</p><p>那大家可以看我的视频了解：<a href="https://www.bilibili.com/video/BV1y3411r7pX/">https://www.bilibili.com/video/BV1y3411r7pX/</a></p><h2 id="阶段-1：Java-入门"><a href="#阶段-1：Java-入门" class="headerlink" title="阶段 1：Java 入门"></a>阶段 1：Java 入门</h2><p>目标<br>培养兴趣、快速上手</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>准备好一款在线、随时随地写代码的工具，不用在本地去安装和配置，是初学者的好帮手</p><p>推荐网站 - 菜鸟工具：<a href="https://c.runoob.com/compile/10">https://c.runoob.com/compile/10</a><br>准备一款记笔记的软件，学编程的过程中老师的思路、自己遇到的问题、解决问题的方法、心得感悟、遇到的好资料，都要记下来哦，好记性不如烂笔头，可以帮助你事半功倍。</p><p>推荐软件 Typora：<a href="https://www.typora.io/">https://www.typora.io/</a><br>推荐使用 Markdown 语法编写，鱼皮教程：<a href="https://www.bilibili.com/video/BV1no4y1k7YT/">https://www.bilibili.com/video/BV1no4y1k7YT/</a><br>想学好编程，别背代码，要多写，把这句话刻到脑子里。</p><p>选视频和找资料的小技巧：多看评论区、多看隔壁评论区，不要看过期的视频。</p><h2 id="Java-编程基础（45-天）"><a href="#Java-编程基础（45-天）" class="headerlink" title="Java 编程基础（45 天）"></a>Java 编程基础（45 天）</h2><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>Java 特点（看不懂没事，别背！）</p><p>环境搭建</p><h4 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h4><p>数据类型<br>流程控制<br>数组</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>方法<br>重载<br>封装<br>继承<br>多态<br>抽象类</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>枚举</p><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><p>String<br>日期时间</p><h4 id="集合类"><a href="#集合类" class="headerlink" title="　集合类"></a>　集合类</h4><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h4 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h4><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><h3 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h3><p>一定要持续学习，不能断！</p><p>跟着书上的例子敲代码后，自主编写代码，并完成课后练习。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>视频</p><blockquote><p>⭐ 韩顺平 - 零基础 30 天学会 Java：<a href="https://www.bilibili.com/video/BV1fh411y7R8（900">https://www.bilibili.com/video/BV1fh411y7R8（900</a> 多集，顺序安排很合理，每个知识真正的打碎了，通俗、有示例、有实战、有思想）<br>文档<br>⭐ 菜鸟教程：<a href="https://www.runoob.com/java/java-tutorial.html（可以在线练习）">https://www.runoob.com/java/java-tutorial.html（可以在线练习）</a><br>廖雪峰 Java 教程：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744">https://www.liaoxuefeng.com/wiki/1252599548343744</a><br>书籍<br>《Head First Java》<br>在线游戏<br>Codegym：<a href="https://codegym.cc/zh（玩玩前几关培养兴趣不错，但后面收费了）">https://codegym.cc/zh（玩玩前几关培养兴趣不错，但后面收费了）</a></p></blockquote><h3 id="Java-8（3-天）"><a href="#Java-8（3-天）" class="headerlink" title="Java 8（3 天）"></a>Java 8（3 天）</h3><p>知识<br>Stream API<br>Lambda 表达式<br>新日期时间 API<br>接口默认方法</p><h3 id="资源-1"><a href="#资源-1" class="headerlink" title="资源"></a>资源</h3><blockquote><p>视频<br>⭐ 宋红康 - 全网最全Java零基础入门教程：<a href="https://www.bilibili.com/video/BV1Kb411W75N（只看">https://www.bilibili.com/video/BV1Kb411W75N（只看</a> Java 8 部分即可）<br>文&gt;档<br>⭐ 菜鸟教程：<a href="https://www.runoob.com/java/java8-new-features.html">https://www.runoob.com/java/java8-new-features.html</a><br>书籍<br>《Java 8 实战》<br>工具<br>⭐ 在线编写运行  Java 8：<a href="https://www.tutorialspoint.com/compile_java8_online.php">https://www.tutorialspoint.com/compile_java8_online.php</a><br>项目<br>Java 8 小代码片段：<a href="https://github.com/biezhi/30-seconds-of-java8">https://github.com/biezhi/30-seconds-of-java8</a><br>尾声</p></blockquote><h2 id="阶段-2：巩固基础"><a href="#阶段-2：巩固基础" class="headerlink" title="阶段 2：巩固基础"></a>阶段 2：巩固基础</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>想学好编程，计算机基础知识要学好。</p><p>比如算法，是程序员的灵魂。学好算法有助于我们理解程序、开拓思路，因此也是很多公司面试时考察的关键，在找工作前，还是要刷个上百道算法题目的。</p><p>我们这个阶段的目标是：熟练使用 Java 语言来编写程序，巩固 Java 的基础。</p><p>那直接用 Java 来写算法题目，一举两得，岂不美哉？</p><h3 id="Java-基础（30-天）"><a href="#Java-基础（30-天）" class="headerlink" title="Java 基础（30 天）"></a>Java 基础（30 天）</h3><p>学习建议<br>建议大家去阅读 《Java 核心技术卷 1》，这本书堪称经典，是帮助你复习巩固  Java 的不二之选，其中图形界面章节可以选择不看。</p><p>之后可以刷牛客的 Java 练习题，检验自己的水平，我当时刷了两遍。</p><p>资源</p><p>书籍</p><blockquote><p>⭐《Java 核心技术卷 1》<br>练习<br>⭐ 牛客题库：<a href="https://www.nowcoder.com/intelligentTest">https://www.nowcoder.com/intelligentTest</a></p></blockquote><h3 id="数据结构与算法-45"><a href="#数据结构与算法-45" class="headerlink" title="数据结构与算法(45)"></a>数据结构与算法(45)</h3><h4 id="知识-1"><a href="#知识-1" class="headerlink" title="知识"></a>知识</h4><p>时间 / 空间复杂度分析</p><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><blockquote><p>数组<br>字符串<br>队列<br>栈<br>链表<br>集合<br>哈希表<br>二叉树</p></blockquote><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><blockquote><p>排序<br>双指针<br>查找<br>分治<br>动态规划<br>递归<br>回溯<br>贪心<br>位运算<br>DFS<br>BFS<br>图</p></blockquote><h4 id="学习建议-1"><a href="#学习建议-1" class="headerlink" title="学习建议"></a>学习建议</h4><p>学算法一定要多思考、多练习！！！</p><p>在复习 Java、巩固基础的过程中，每天可以坚持用 Java 做 2 - 3 道算法题目。</p><p>不用担心看不懂，直接进入 LeetCode 学习板块 LeetBook，提供了免费的教程，文字、图解、动画讲算法、在线练习应有尽有，从 0 开始，跟着学习基础知识、跟着教程刷一些同类题目，培养算法思路。</p><p>之后再由简单到复杂、由通过率高到低，自主刷题，多看题解，举一反三。</p><p>有条件的朋友也可以试着参与竞赛，没什么门槛，可以帮助你集中精神，而且周赛的题目还是挺友好的~</p><p>资源</p><h4 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h4><blockquote><p>⭐ 刷了 1000 多道算法题，一点心得：<a href="https://t.1yb.co/oT9q（鱼皮原创）">https://t.1yb.co/oT9q（鱼皮原创）</a></p></blockquote><h4 id="在线教程"><a href="#在线教程" class="headerlink" title="在线教程"></a>在线教程</h4><blockquote><p>⭐ LeetCode LeetBook：<a href="https://leetcode-cn.com/leetbook/">https://leetcode-cn.com/leetbook/</a></p></blockquote><h4 id="在线刷题"><a href="#在线刷题" class="headerlink" title="在线刷题"></a>在线刷题</h4><blockquote><p>⭐ LeetCode：<a href="https://leetcode-cn.com/">https://leetcode-cn.com/</a></p></blockquote><h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><blockquote><p>⭐《小灰的漫画算法》<br>⭐《剑指 Offer》<br>《程序员代码面试指南》<br>图解算法数据结构：<a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/">https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/</a><br>LeetCode 101（C++）：<a href="https://github.com/changgyhub/leetcode_101">https://github.com/changgyhub/leetcode_101</a><br>LeetCode 题解（C++）：<a href="https://github.com/soulmachine/leetcode">https://github.com/soulmachine/leetcode</a><br>LeetCode Cookbook（Go 语言）：<a href="https://github.com/halfrost/LeetCode-Go">https://github.com/halfrost/LeetCode-Go</a><br>视频<br>尚硅谷 Java 数据结构与算法：<a href="https://www.bilibili.com/video/BV1E4411H73v（难度比面试的要求大一些，适合希望更全面学习的朋友）">https://www.bilibili.com/video/BV1E4411H73v（难度比面试的要求大一些，适合希望更全面学习的朋友）</a><br>Leetcode 真题解析：<a href="https://www.bilibili.com/video/BV1a54y1b74k">https://www.bilibili.com/video/BV1a54y1b74k</a><br>工具<br>VisuAlgo 数据结构和算法动态可视化：<a href="https://visualgo.net/zh">https://visualgo.net/zh</a><br>数据结构可视化：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a><br>网站<br>五分钟学算法：<a href="https://www.cxyxiaowu.com/">https://www.cxyxiaowu.com/</a></p></blockquote><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><h4 id="知识-2"><a href="#知识-2" class="headerlink" title="　知识"></a>　知识</h4><h5 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h5><blockquote><p>HTTP / HTTPS 协议<br>网络模型<br>UDP / TCP 协议<br>网络安全<br>域名解析<br>操作系统<br>进程、线程<br>进程 / 线程间通讯方式<br>进程调度算法<br>进程 / 线程状态<br>死锁<br>内存管理</p></blockquote><h4 id="学习建议-2"><a href="#学习建议-2" class="headerlink" title="学习建议"></a>学习建议</h4><p>在巩固基础期间，我建议大家多去了解计算机基础知识，比如操作系统、计算机网络。</p><p>但这一块知识说实话挺枯燥的，对吧，你说说我现在项目都不会做，你又让我看这些理论，是不是想让我头秃。</p><p>我的建议是，可以先看有趣的课外书，比如《图解 HTTP》等等，对基础知识先有个大致的印象，等后面有时间了再系统学习。</p><p>比如还在校园就跟着学校的进度学习就成，自学的话可以看下 《计算机网络微课堂》、 《清华操作系统原理》视频，有实力的小伙伴，能看懂大黑书就更好了。</p><h4 id="资源-2"><a href="#资源-2" class="headerlink" title="资源"></a>资源</h4><p>视频</p><blockquote><p>《计算机网络微课堂》：<a href="https://www.bilibili.com/video/BV1c4411d7jb">https://www.bilibili.com/video/BV1c4411d7jb</a><br>《清华操作系统原理》：<a href="https://www.bilibili.com/video/BV1uW411f72n">https://www.bilibili.com/video/BV1uW411f72n</a><br>书籍<br>⭐《图解 HTTP》<br>《网络是怎样连接的》<br>⭐《图解 TCP / IP》<br>《编码》<br>《30天自制操作系统》<br>《计算机网络-自顶向下方法》（难度较大，不推荐新手看）<br>《现代操作系统》（难度较大，不推荐新手看）<br>《深入理解计算机系统》（难度较大，不推荐新手看）</p></blockquote><p>尾声</p><blockquote><p>巩固基础要花至少 1 个月的时间，当你读完《Java 核心技术卷1》并且不用查询文档也能熟练地用 Java 做题时，就可以接着往下了。</p></blockquote><h2 id="阶段-3：Java-企业开发基础"><a href="#阶段-3：Java-企业开发基础" class="headerlink" title="阶段 3：Java 企业开发基础"></a>阶段 3：Java 企业开发基础</h2><p>目标<br>面向薪资编程，学习实际工作要用的技术，并能 独立 做出一个具有完整功能的 Java Web 项目。</p><h3 id="MySQL-数据库（7-天）"><a href="#MySQL-数据库（7-天）" class="headerlink" title="MySQL 数据库（7 天）"></a>MySQL 数据库（7 天）</h3><p>企业中大部分业务数据都是用关系型数据库存储的，因此数据库是后台开发同学的必备技能，其中 MySQL 数据库是目前的主流，也是面试时的重点。</p><h4 id="知识-3"><a href="#知识-3" class="headerlink" title="知识"></a>知识</h4><p>基本概念</p><blockquote><p>MySQL 搭建<br>SQL 语句编写<br>约束<br>索引<br>事务<br>设计数据库表<br>性能优化</p></blockquote><h4 id="学习建议-3"><a href="#学习建议-3" class="headerlink" title="学习建议"></a>学习建议</h4><p>其中，SQL 语句编写 和 设计数据库表 这两个能力一定要有！</p><p>比如让你做一个学生管理系统，你要能想到需要哪些表，比如学生表、班级表；每个表需要哪些字段、字段类型。</p><p>这就要求大家多写 SQL、多根据实际的业务场景去练习设计能力。</p><h4 id="资源-3"><a href="#资源-3" class="headerlink" title="资源"></a>资源</h4><p>视频</p><blockquote><p>⭐ 老杜 - mysql入门基础 + 数据库实战：<a href="https://www.bilibili.com/video/BV1Vy4y1z7EX（较新、内容相对精炼，有习题）">https://www.bilibili.com/video/BV1Vy4y1z7EX（较新、内容相对精炼，有习题）</a><br>尚硅谷 - MySQL基础教程：<a href="https://www.bilibili.com/video/BV1xW411u7ax（小姐姐讲课，但感觉音质一般）">https://www.bilibili.com/video/BV1xW411u7ax（小姐姐讲课，但感觉音质一般）</a><br>在线练习<br>⭐ SQL 自学网：<a href="http://xuesql.cn/">http://xuesql.cn/</a><br>⭐ SQL 在线运行：<a href="https://www.bejson.com/runcode/sql/">https://www.bejson.com/runcode/sql/</a><br>文档<br>SQL - 菜鸟教程：<a href="https://www.runoob.com/sql/sql-tutorial.html">https://www.runoob.com/sql/sql-tutorial.html</a><br>MySQL - 菜鸟教程：<a href="https://www.runoob.com/mysql/mysql-tutorial.html">https://www.runoob.com/mysql/mysql-tutorial.html</a></p></blockquote><h3 id="开发框架（60-天）"><a href="#开发框架（60-天）" class="headerlink" title="开发框架（60 天）"></a>开发框架（60 天）</h3><p>Java 之所以能成为主流的企业开发语言，很大一部分原因是它完善的框架生态，用好框架，不仅能够大大提升开发效率，还能提高项目的稳定性、减少维护成本。</p><p>开发框架是后台开发工作中不可或缺的，也是面试考察的重点，一定要好好学！</p><p>不知道 Java 能做什么的朋友们，学完开发框架，就会有答案啦。</p><p>下面给大家推荐的都是企业中应用最多的主流开发框架，知识点比较零碎，就放在一起讲了。</p><h4 id="知识-4"><a href="#知识-4" class="headerlink" title="知识"></a>知识</h4><p>Java Web<br>描述：Java 网页应用开发基础</p><p>前端基础</p><blockquote><p>XML<br>JSON<br>Servlet<br>Filter<br>Listener<br>JSP<br>JSTL<br>Cookie<br>Session</p></blockquote><p>Spring 5</p><blockquote><p>描述：Java 轻量级应用框架<br>IOC<br>AOP<br>事务</p></blockquote><h5 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h5><blockquote><p>描述：Java 轻量级 web 开发框架<br>什么是 MVC？<br>请求与响应<br>Restful API<br>拦截器<br>配置<br>执行过程</p></blockquote><h5 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h5><blockquote><p>描述：数据访问框架，操作数据库进行增删改查等操作<br>增删改查<br>全局配置<br>动态 SQL<br>缓存<br>和其他框架的整合<br>逆向工程</p></blockquote><h5 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis Plus"></a>MyBatis Plus</h5><blockquote><p>描述：Mybatis 的增强工具，能够简化开发、提高效率<br>引入<br>通用 CRUD<br>条件构造器<br>代码生成器<br>插件扩展<br>自定义全局操作</p></blockquote><h5 id="SpringBoot-2"><a href="#SpringBoot-2" class="headerlink" title="SpringBoot 2"></a>SpringBoot 2</h5><blockquote><p>描述：简化 Spring 应用的初始搭建以及开发过程，提高效率<br>常用注解<br>资源整合<br>高级特性<br>本地热部署</p></blockquote><h5 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h5><blockquote><p>描述：Spring 的安全管理框架<br>用户认证<br>权限管理<br>Maven / Gradle<br>描述：项目管理工具<br>构建<br>依赖管理<br>插件<br>配置<br>子父工程</p></blockquote><p>学习建议<br>由于技术较多，且框架之间存在一定的联系，因此建议大家看同一系列的视频教程（尚硅谷、狂神说等等都可以），以保证学习内容的连续以及体验上的一致。</p><p>学这些技术的时候，千万不能懒 ！一定要多记笔记，并且跟着老师写代码。原理部分不要太过纠结，先以能跟着敲出代码、写出可运行的项目为主，有些东西做出来也能帮助你更好地理解理论。</p><p>学习顺序挺重要的，建议按我推荐的顺序学，不要一上手就学 SpringBoot。只有先学习下自己整合框架的方法，才能帮你理解 SpringBoot 解决的问题，感受到它的方便和高效。</p><p>Maven / Gradle 当工具用就好，面试基本不问，跟着框架教程去用就行了，先不用花太多时间去深入学。</p><h4 id="资源-4"><a href="#资源-4" class="headerlink" title="资源"></a>资源</h4><p>视频（按顺序看）</p><blockquote><p>⭐ 尚硅谷最新版 JavaWeb 全套教程：<a href="https://www.bilibili.com/video/BV1Y7411K7zz（前端部分最好也看下）">https://www.bilibili.com/video/BV1Y7411K7zz（前端部分最好也看下）</a><br>⭐ 尚硅谷 - Spring 5 框架最新版教程（idea版）：<a href="https://www.bilibili.com/video/BV1Vf4y127N5">https://www.bilibili.com/video/BV1Vf4y127N5</a><br>⭐ 尚硅谷 - SpringMVC 2021 最新教程：<a href="https://www.bilibili.com/video/BV1Ry4y1574R">https://www.bilibili.com/video/BV1Ry4y1574R</a><br>⭐ 尚硅谷 - MyBatis 实战教程全套完整版：<a href="https://www.bilibili.com/video/BV1mW411M737">https://www.bilibili.com/video/BV1mW411M737</a><br>⭐ 尚硅谷 - MyBatisPlus 教程：<a href="https://www.bilibili.com/video/BV1Ds411E76Y">https://www.bilibili.com/video/BV1Ds411E76Y</a><br>Maven 零基础入门教程：<a href="https://www.bilibili.com/video/BV1TW411g7hP（搞不懂">https://www.bilibili.com/video/BV1TW411g7hP（搞不懂</a> Maven 可以看看）<br>⭐ 雷丰阳 2021 版 SpringBoot2 零基础入门：<a href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a><br>尚硅谷 - SpringSecurity 框架教程：<a href="https://www.bilibili.com/video/BV15a411A7kP">https://www.bilibili.com/video/BV15a411A7kP</a></p></blockquote><h3 id="开发规范（3-天）"><a href="#开发规范（3-天）" class="headerlink" title="开发规范（3 天）"></a>开发规范（3 天）</h3><p>开发不规范，同事两行泪。</p><p>开发规范是团队开发中必须遵守的，有利于提高项目的开发效率、降低维护成本。</p><p>知识<br>代码规范<br>代码风格<br>命名<br>其他规则<br>提交规范<br>学习建议<br>简单过一遍大厂团队的规范手册就好了，以后做项目的时候能想起来的话就去使用，或者从书中、网上查规范，再去遵守。</p><p>项目做得多了，自然会养成好的习惯，不用刻意去记（毕竟每个团队规范也不完全相同，背了也没用）。</p><p>资源<br>书籍</p><p>⭐ 阿里巴巴 Java 开发手册：<a href="https://developer.aliyun.com/graph/java（搜索《Java开发手册》）">https://developer.aliyun.com/graph/java（搜索《Java开发手册》）</a><br>视频</p><p>华山版《Java开发手册》独家讲解：<a href="https://developer.aliyun.com/live/1201">https://developer.aliyun.com/live/1201</a><br>文档</p><p>Google Java Style Guide：<a href="https://google.github.io/styleguide/javaguide.html（谷歌">https://google.github.io/styleguide/javaguide.html（谷歌</a> Java 代码规范）</p><h3 id="Git（3-天）"><a href="#Git（3-天）" class="headerlink" title="Git（3 天）"></a>Git（3 天）</h3><p>此前大家可能听说过 GitHub，一流的代码开源托管平台。</p><p>Git 和它可不一样，是一个版本控制工具，可以更好地管理和共享项目代码，比如把自己的代码传到 GitHub 上、或者从远程下载。</p><p>无论自己做项目、还是团队开发，Git 都是现在不可或缺的神器。</p><p>知识<br>工作区<br>分支<br>代码提交、推送、拉取、回退、重置<br>分支操作<br>代码合并、解决冲突<br>标签<br>cherry-pick<br>学习建议<br>每个命令跟着敲一遍，有个大致的印象，会用即可，用的多了自然熟悉了。</p><p>资源<br>视频</p><p>⭐【尚硅谷】5h打通Git全套教程丨2021最新IDEA版 <a href="https://www.bilibili.com/video/BV1vy4y1s7k6">https://www.bilibili.com/video/BV1vy4y1s7k6</a><br>书籍</p><p>猴子都能懂的 Git 入门 <a href="https://backlog.com/git-tutorial/cn/">https://backlog.com/git-tutorial/cn/</a><br>⭐ GitHub 漫游指南 <a href="https://github.phodal.com/">https://github.phodal.com/</a><br>文档</p><p>GitHub 官方文档：<a href="https://docs.github.com/cn">https://docs.github.com/cn</a><br>游戏</p><p>Learning Git Branching：<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p><h3 id="Linux（10-天）"><a href="#Linux（10-天）" class="headerlink" title="Linux（10 天）"></a>Linux（10 天）</h3><p>企业中的很多前后台项目都是部署在 Linux 服务器上的，因此很有必要熟悉 Linux 的操作和脚本的编写。</p><p>后面学微服务、学架构都是在多台服务器操作，如果你不熟悉 Linux，会有点吃力。</p><p>知识<br>Linux 系统安装<br>环境变量<br>文件管理<br>用户管理<br>内存管理<br>磁盘管理<br>进程管理<br>网络管理<br>软件包管理<br>服务管理<br>日志管理<br>Linux 内核<br>常用命令<br>常用环境搭建<br>Shell 脚本编程<br>VIM 的使用<br>学习建议<br>多动手实践，建议自己购买一台云服务器，并且在本地搭建 Linux 虚拟机环境。</p><p>一定要自己从 0 开始手敲命令安装软件、部署服务，熟悉整个项目的上线流程。</p><p>每个命令至少要跟着敲一遍，了解它们的作用，并通过自然地练习，熟悉常用的 Linux 命令。</p><p>记不住没关系，用文档查就行了。</p><p>先会用，再理解。</p><p>资源<br>视频</p><p>⭐ 2021 韩顺平 一周学会Linux <a href="https://www.bilibili.com/video/BV1Sv411r7vd（基于">https://www.bilibili.com/video/BV1Sv411r7vd（基于</a> CentOS 7.6 版本较新）<br>书籍</p><p>《鸟哥的 Linux 私房菜 —— 基础篇》<a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php（经典）">http://cn.linux.vbird.org/linux_basic/linux_basic.php（经典）</a><br>文档</p><p>Linux 工具快速教程：<a href="https://linuxtools-rst.readthedocs.io（基础、工具进阶、工具参考）">https://linuxtools-rst.readthedocs.io（基础、工具进阶、工具参考）</a><br>实战</p><p>⭐ 蓝桥云课 Linux 基础入门：<a href="https://www.lanqiao.cn/courses/1">https://www.lanqiao.cn/courses/1</a><br>腾讯云动手实验室：<a href="https://cloud.tencent.com/developer/labs">https://cloud.tencent.com/developer/labs</a><br>阿里云体验实验室：<a href="https://developer.aliyun.com/adc/labs/">https://developer.aliyun.com/adc/labs/</a><br>阿里云知行实验室：<a href="https://start.aliyun.com/">https://start.aliyun.com/</a><br>华为云沙箱实验室：<a href="https://lab.huaweicloud.com/">https://lab.huaweicloud.com/</a><br>社区</p><p>Linux 中国：<a href="https://linux.cn/">https://linux.cn/</a><br>工具</p><p>⭐ Linux 命令搜索：<a href="https://wangchujiang.com/linux-command">https://wangchujiang.com/linux-command</a><br>Linux 命令大全手册：<a href="https://www.linuxcool.com/">https://www.linuxcool.com/</a><br>Linux 命令示例：<a href="http://linux-commands-examples.com/">http://linux-commands-examples.com/</a><br>宝塔 Linux 面板：<a href="https://www.bt.cn/">https://www.bt.cn/</a></p><h3 id="前端基础（14-天）"><a href="#前端基础（14-天）" class="headerlink" title="前端基础（14 天）"></a>前端基础（14 天）</h3><p>虽然 Java 程序员面试时基本不会出现前端相关问题，但是在企业中，往往需要前后端程序员配合完成工作。会一些前端，不仅可以提高你们的协作效率，还能提高自己对整个项目的了解和掌控力，甚至能独立开发出一个完整项目！这点也是能给面试加分的。</p><p>知识<br>HTML<br>CSS<br>JavaScript<br>Ajax<br>Vue<br>学习建议<br>不需要学习太多的前端技术，熟悉下基础的前端三件套，了解前端是如何向后端发送请求来做数据交互的一般就够了。有时间的话可以学下 Vue ，是比较容易上手的主流前端开发框架，Vue + SpringBoot 还是很香的。</p><p>资源<br>参见鱼皮原创的前端学习路线：<a href="https://mp.weixin.qq.com/s/HbzLEt6NOP9Is9F3GOnbUQ">https://mp.weixin.qq.com/s/HbzLEt6NOP9Is9F3GOnbUQ</a></p><h2 id="阶段-4：Java-企业开发进阶"><a href="#阶段-4：Java-企业开发进阶" class="headerlink" title="阶段 4：Java 企业开发进阶"></a>阶段 4：Java 企业开发进阶</h2><p>目标<br>学习更多企业级开发技术和编程思想，能够结合多种技术，独立开发出架构合理的完整系统，解决实际问题 。</p><p>要了解为什么需要这个技术？什么时候用哪些技术？</p><h3 id="设计模式（21-天）"><a href="#设计模式（21-天）" class="headerlink" title="设计模式（21 天）"></a>设计模式（21 天）</h3><p>设计模式是软件开发中解决一类问题的通用方法。</p><p>使用设计模式能让你写出更优雅、可维护的代码，也正因如此，很多框架源码都用到了设计模式，你不学很难看懂。</p><p>知识<br>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程</p><p>单例模式<br>工厂方法模式<br>抽象工厂<br>建造者模式<br>原型模式<br>结构型模式：把类或对象结合在一起形成一个更大的结构</p><p>适配器模式<br>组合模式<br>装饰器模式<br>代理模式<br>享元模式<br>外观模式<br>桥接模式<br>行为型模式：类和对象如何交互，及划分责任和算法</p><p>迭代器模式<br>模板方法模式<br>策略模式<br>命令模式<br>状态模式<br>责任链模式<br>备忘录模式<br>观察者模式<br>访问者模式<br>中介者模式<br>解释器模式<br>学习建议<br>先理解概念，了解每个设计模式的特点和应用场景，再多加练习，运用到实际项目。</p><p>资源<br>书籍</p><p>⭐《图解设计模式》（强烈推荐这本书，正是用 Java 语言实现，图多、有示例代码、有习题和答案，很不错）</p><p>《Head First 设计模式》</p><p>《大话设计模式》</p><p>《设计模式：可复用面向对象软件的基础》（大黑书，有能力的话也可以去读）</p><p>视频</p><p>尚硅谷图解 Java 设计模式：<a href="https://www.bilibili.com/video/BV1G4411c7N4">https://www.bilibili.com/video/BV1G4411c7N4</a><br>文档</p><p>菜鸟教程：<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a><br>图说设计模式：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/">https://design-patterns.readthedocs.io/zh_CN/latest/</a></p><h3 id="中间件（14-天）"><a href="#中间件（14-天）" class="headerlink" title="中间件（14 天）"></a>中间件（14 天）</h3><p>除了框架外，企业项目开发也会用到大量独立的中间件，以解决某些实际问题，比如提高项目的性能、提高项目的稳定性和可靠性等。</p><p>下面分享几个最常用的主流中间件。</p><p>知识<br>Redis 缓存<br>数据类型</p><p>常用操作</p><p>Java 操作 Redis</p><p>主从模型搭建</p><p>哨兵集群搭建</p><p>日志持久化</p><p>应用场景</p><p>RabbitMQ 消息队列<br>消息队列的作用</p><p>生产消费模型</p><p>交换机模型</p><p>死信队列</p><p>延迟队列</p><p>消息持久化</p><p>Java 操作</p><p>集群搭建</p><p>Nginx 网关<br>Nginx 作用</p><p>正向代理</p><p>反向代理（负载均衡）</p><p>常用命令</p><p>配置</p><p>动静分离（网站部署）</p><p>集群搭建</p><p>学习建议<br>学会如何使用中间件并不难，先能够独立使用，了解他们的应用场景；再用 Java 来操作中间件，和项目相结合。</p><p>跟着视频教程实操一遍即可，可以等到面试前再去深入了解原理和高级特性。</p><p>资源<br>视频</p><p>⭐ 尚硅谷 - 2021 最新 Redis 6 入门到精通教程：<a href="https://www.bilibili.com/video/BV1Rv41177Af（基于">https://www.bilibili.com/video/BV1Rv41177Af（基于</a> Redis 6 的，推荐）<br>⭐ 尚硅谷 - 2021 最新 RabbitMQ 教程：<a href="https://www.bilibili.com/video/BV1cb4y1o7zz（很新很全面）">https://www.bilibili.com/video/BV1cb4y1o7zz（很新很全面）</a><br>⭐ 尚硅谷 - Nginx 教程由浅入深：<a href="https://www.bilibili.com/video/BV1zJ411w7SV（讲的比较全面）">https://www.bilibili.com/video/BV1zJ411w7SV（讲的比较全面）</a><br>⭐ Nginx 鱼皮 - 手把手带你从0搭建个人网站：<a href="https://www.bilibili.com/video/BV1rU4y1J785/">https://www.bilibili.com/video/BV1rU4y1J785/</a> （简单演示 Nginx 部署网站）<br>文档</p><p>Redis 命令参考：<a href="http://redisdoc.com/">http://redisdoc.com/</a><br>Redis 面试题整理：<a href="https://github.com/lokles/Web-Development-Interview-With-Java/blob/main/Redis%E9%97%AE%E9%A2%98.md">https://github.com/lokles/Web-Development-Interview-With-Java/blob/main/Redis%E9%97%AE%E9%A2%98.md</a><br>RabbitMQ 中文文档：<a href="http://rabbitmq.mr-ping.com/">http://rabbitmq.mr-ping.com/</a><br>Nginx 中文文档：<a href="https://www.nginx.cn/doc/index.html">https://www.nginx.cn/doc/index.html</a><br>书籍</p><p>《Redis 实战》（经典）<br>《RabbitMQ 实战：高效部署分布式消息队列》（经典）<br>工具</p><p>⭐ Redis 在线练习：<a href="https://try.redis.io/（强烈推荐）">https://try.redis.io/（强烈推荐）</a><br>⭐ RabbitMQ 在线模拟器：<a href="http://tryrabbitmq.com/">http://tryrabbitmq.com/</a><br>Nginx 配置在线生成：<a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN">https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN</a><br>相关技术</p><p>缓存：Memcached、Ehcache<br>队列：Kafka、ActiveMQ、TubeMQ、RocketMQ<br>网关：HAProxy</p><h3 id="Netty-网络编程（14-天）"><a href="#Netty-网络编程（14-天）" class="headerlink" title="Netty 网络编程（14 天）"></a>Netty 网络编程（14 天）</h3><p>开源的 Java 网络编程框架，用于开发高性能（事件驱动、异步非阻塞）、高可靠的网络服务器和客户端程序。</p><p>很多网络框架和服务器程序都用到了 Netty 作为底层，学好 Netty 不仅可以让我们自己实现高性能服务器，也能更好地理解其他的框架应用、阅读源码。</p><p>知识<br>IO 模型（BIO / NIO）<br>Channel<br>Buffer<br>Seletor<br>Netty 模型<br>WebSocket 编程（动手做个聊天室）<br>学习建议<br>不同于之前学的 SSM 框架，Netty 还是需要一定学习成本的，一方面是国内资源太缺乏，另一方面很多重要的概念（比如 NIO）还是要多动手写代码调试才能理解。</p><p>还是建议先从视频入门，并且不建议在 Netty 上花太多时间，面试的时候一般也就考察一些 Netty 思想。</p><p>资源<br>视频</p><p>⭐ 尚硅谷Netty教程：<a href="https://www.bilibili.com/video/BV1DJ411m7NR">https://www.bilibili.com/video/BV1DJ411m7NR</a></p><p>Netty 技术演讲（中文字幕版）：<a href="https://www.youtube.com/watch?v=I8yy2Cy7dDI">https://www.youtube.com/watch?v=I8yy2Cy7dDI</a></p><p>文档</p><p>Netty 4 用户指南：<a href="https://www.w3cschool.cn/netty_4_user_guide/">https://www.w3cschool.cn/netty_4_user_guide/</a><br>书籍</p><p>《Netty 实战》<br>相关技术</p><p>Vertx：<a href="http://vertxchina.github.io/vertx-translation-chinese/（比">http://vertxchina.github.io/vertx-translation-chinese/（比</a> Netty 简单多了，实在看不懂 Netty 也可以学习下这个）</p><h3 id="微服务（60-天）"><a href="#微服务（60-天）" class="headerlink" title="微服务（60 天）"></a>微服务（60 天）</h3><p>随着互联网的发展，项目越来越复杂，单机且庞大的巨石项目已无法满足开发、运维、并发、可靠性等需求。</p><p>因此，后台架构不断演进，可以将庞大的项目拆分成一个个职责明确、功能独立的细小模块，模块可以部署在多台服务器上，相互配合协作，提供完整的系统能力。</p><p>换言之，想做大型项目，这块儿一定要好好学！</p><p>知识<br>Dubbo<br>架构演进<br>RPC<br>Zookeeper<br>服务提供者<br>服务消费者<br>项目搭建<br>微服务<br>微服务概念<br>Spring Cloud 框架<br>子父工程<br>服务注册与发现<br>注册中心 Eureka、Zookeeper、Consul<br>Ribbon 负载均衡<br>Feign 服务调用<br>Hystrix 服务限流、降级、熔断<br>Resilience4j 服务容错<br>Gateway（Zuul）微服务网关<br>Config 分布式配置中心<br>分布式服务总线<br>分布式链路追踪<br>Spring Cloud Alibaba<br>Nacos 注册、配置中心<br>OpenFeign 服务调用<br>Sentinel 流控<br>Seata 分布式事务<br>接口管理<br>Swagger 接口文档<br>Postman 接口测试<br>学习建议<br>时间不急的话，建议先从 Dubbo 学起，对分布式、RPC、微服务有些基本的了解，再去食用 Spring Cloud 全家桶会更香。</p><p>这部分内容的学习，原理 + 实践都很重要，也不要被各种高大上的词汇唬住了，都是上层（应用层）的东西，基本没有什么算法，跟着视频教程学，其实还是很好理解的。</p><p>分布式相关知识非常多，但这里不用刻意去背，先通过视频教程实战使用一些微服务框架，也能对其中的概念有基本的了解。</p><p>资源<br>视频</p><p>⭐ 尚硅谷 Dubbo 教程：<a href="https://www.bilibili.com/video/BV1ns411c7jV">https://www.bilibili.com/video/BV1ns411c7jV</a></p><p>⭐ 尚硅谷 SpringCloud（H版&amp;alibaba）框架开发教程（微服务分布式架构）：<a href="https://www.bilibili.com/video/BV18E411x7eT（把国外的">https://www.bilibili.com/video/BV18E411x7eT（把国外的</a> Spring Cloud 和国内的 Spring Cloud Alibaba 结合在一起对比着去讲，主流技术栈、知识点都讲到了，真心不错！）</p><p>文档</p><p>Apache Dubbo 官方文档：<a href="https://dubbo.apache.org/zh/">https://dubbo.apache.org/zh/</a><br>Spring Cloud Alibaba 官方文档：<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a><br>⭐ Swagger 教学文档：<a href="https://doc.xiaominfo.com/（跟着快速开始直接用就好了）">https://doc.xiaominfo.com/（跟着快速开始直接用就好了）</a></p><h3 id="容器（7-天）"><a href="#容器（7-天）" class="headerlink" title="容器（7 天）"></a>容器（7 天）</h3><p>将应用和环境进行封装，相互隔离、独立部署、便于移植，提高安全性、提高开发和维护效率。</p><p>便于实现微服务、持续集成和交付。</p><p>知识<br>Docker<br>容器概念<br>镜像<br>部署服务<br>Dockerfile<br>K8S（Kubernetes）<br>架构<br>部署应用<br>暴露服务<br>动态扩缩容<br>学习建议<br>会用 Docker / K8S 部署项目和服务就行，企业一般都有现成的平台直接用，面试考察不多，不用花太多时间。</p><p>资源<br>视频</p><p>⭐【狂神说】Docker 最新超详细版教程通俗易懂：<a href="https://www.bilibili.com/video/BV1og4y1q7M4">https://www.bilibili.com/video/BV1og4y1q7M4</a><br>K8S 视频教程：<a href="https://www.bilibili.com/video/BV1K5411N7j8">https://www.bilibili.com/video/BV1K5411N7j8</a><br>书籍</p><p>《深入浅出 Docker》：<a href="https://www.zhihu.com/pub/reader/119632192">https://www.zhihu.com/pub/reader/119632192</a><br>文档</p><p>Docker — 从入门到实践：<a href="https://vuepress.mirror.docker-practice.com/">https://vuepress.mirror.docker-practice.com/</a><br>菜鸟教程 Docker：<a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a><br>国外 Docker 官方文档：<a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a><br>网站</p><p>Docker 中文社区：<a href="https://www.docker.org.cn/（强烈推荐，有很多">https://www.docker.org.cn/（强烈推荐，有很多</a> Docker 技术文章和学习笔记）<br>Docker Blog：<a href="https://www.docker.com/blog/（国外">https://www.docker.com/blog/（国外</a> Docker 技术博客）<br>镜像源</p><p>Docker Hub：<a href="https://hub.docker.com">https://hub.docker.com</a><br>腾讯软件源：<a href="http://mirrors.tencent.com/#/index">http://mirrors.tencent.com/#/index</a><br>阿里云 Docker 仓库：<a href="https://cr.console.aliyun.com/">https://cr.console.aliyun.com/</a></p><h3 id="CI-CD（3-天）"><a href="#CI-CD（3-天）" class="headerlink" title="CI / CD（3 天）"></a>CI / CD（3 天）</h3><p>持续集成 / 持续交付，贯穿整个研发到项目上线的过程，提高效率。</p><p>大公司一般都有自己的 CI / CD 平台。</p><p>知识<br>什么是 CI / CD</p><p>CI / CD 有什么好处</p><p>使用任一 CI / CD 平台</p><p>学习建议<br>了解它是什么，并且实战使用任一 CI / CD 平台，感受它和传统开发运维到底有什么不同，就足够了。其实很简单，不要花太多时间。</p><p>真正要自己去搭建的时候，跟着官方文档来就行。</p><p>资源<br>视频</p><p>⭐【狂神说】CI/CD到底是什么？十分钟理解企业级DevOps：<a href="https://www.bilibili.com/video/BV1zf4y127vu（讲的非常棒！带你快速理解">https://www.bilibili.com/video/BV1zf4y127vu（讲的非常棒！带你快速理解</a> CI / CD 的作用和部分原理）</p><p>尚硅谷 - Jenkins 持续集成工具教程：<a href="https://www.bilibili.com/video/BV1GW411w7pn（实在要用到">https://www.bilibili.com/video/BV1GW411w7pn（实在要用到</a> Jenkins 再去学）</p><p>文档</p><p>Jenkins 官方文档：<a href="https://www.jenkins.io/zh/">https://www.jenkins.io/zh/</a> （有很多案例，要用的时候查一下就行了）<br>实战平台</p><p>⭐ 微信云托管：<a href="https://cloud.weixin.qq.com/cloudrun（直播演示过，鱼皮后面会给大家出视频教程）">https://cloud.weixin.qq.com/cloudrun（直播演示过，鱼皮后面会给大家出视频教程）</a></p><p>前端托管 Webify：<a href="https://cloud.tencent.com/product/webify（鱼皮给大家出过视频教程的">https://cloud.tencent.com/product/webify（鱼皮给大家出过视频教程的</a> <a href="https://www.bilibili.com/video/BV11V411p7vf/）">https://www.bilibili.com/video/BV11V411p7vf/）</a></p><h2 id="阶段-5：项目实战"><a href="#阶段-5：项目实战" class="headerlink" title="阶段 5：项目实战"></a>阶段 5：项目实战</h2><p>目标<br>综合所学技术从 0 到 1 开发和上线一个全面、有特色的、可以写进简历的个人项目。</p><p>学习建议<br>其实在之前的框架学习视频中应该就做过几个项目了，但相对不够完整和体系化。</p><p>有想法的同学可以做任何自己想做的项目，推荐参加一些作品类竞赛，练手、拿奖、收获项目经历一举三得。</p><p>暂时没想法的朋友，建议先跟着专门带做项目的视频教程做 1 - 2 套 Java 完整项目，一定要从 0 到 1 自己手写！</p><p>有能力的朋友也可以试着用 GitHub 上的源码来学习啦~</p><p>做一个完整的项目的确很不容易，建议大家根据自己的 时间、兴趣 选择 较新的、有配套源码的 教程，保持耐心。</p><p>如何选择编程学习资源，可以看下我的原创文章：<a href="https://mp.weixin.qq.com/s/mlMql9RJCd7THt6rpGb8UA">https://mp.weixin.qq.com/s/mlMql9RJCd7THt6rpGb8UA</a></p><p>下面推荐一些优质的、较新的项目实战视频教程 + 50 套项目源码。</p><p>视频教程<br>尚硅谷 - 谷粒学院 - 微服务 + 全栈 - 在线教育实战项目：<a href="https://www.bilibili.com/video/BV1dQ4y1A75e（全栈项目，前后端讲得都很全面）">https://www.bilibili.com/video/BV1dQ4y1A75e（全栈项目，前后端讲得都很全面）</a></p><p>尚硅谷 - 尚筹网 - Java项目实战开发教程 - SSM 框架 + 微服务架构：<a href="https://www.bilibili.com/video/BV1bE411T7oZ（500">https://www.bilibili.com/video/BV1bE411T7oZ（500</a> 多集，包含完整的用户权限管理，功能丰富、讲得很细致全面）</p><p>黑马 - 24 小时搞定 Java 毕设电商项目：<a href="https://www.bilibili.com/video/BV13f4y1r7fS">https://www.bilibili.com/video/BV13f4y1r7fS</a></p><p>黑马程序员 Java 项目《传智健康》，超完整的企业级医疗行业项目：<a href="https://www.bilibili.com/video/BV1Bo4y117zV">https://www.bilibili.com/video/BV1Bo4y117zV</a></p><p>黑马程序员 Java 项目《万信金融》企业级开发实战，互联网金融行业解决方案：<a href="https://www.bilibili.com/video/BV1Ub4y1f7rk">https://www.bilibili.com/video/BV1Ub4y1f7rk</a></p><p>黑马程序员 Java 项目 SaaS 移动办公完整版《iHRM 人力资源管理系统》，跨行业 SaaS 办公整合性解决方案：<a href="https://www.bilibili.com/video/BV18A411L7UX">https://www.bilibili.com/video/BV18A411L7UX</a></p><p>黑马程序员 Java 大型分布式微服务闪聚支付项目，Java 移动支付全生态系统：<a href="https://www.bilibili.com/video/BV17v411V79c">https://www.bilibili.com/video/BV17v411V79c</a></p><p>黑马程序员 Java 项目《好客租房》：<a href="https://www.bilibili.com/video/BV1sZ4y1F7PD">https://www.bilibili.com/video/BV1sZ4y1F7PD</a></p><p>项目源码（50 套）<br>电商秒杀<br>天猫整站 J2EE：<a href="https://how2j.cn/module/115.htm">https://how2j.cn/module/115.htm</a></p><p>天猫整站 SSM：<a href="https://how2j.cn/module/134.html">https://how2j.cn/module/134.html</a></p><p>天猫整站 Springboot：<a href="https://how2j.cn/module/156.html">https://how2j.cn/module/156.html</a></p><p>mall-learning：<a href="https://github.com/macrozheng/mall-learningmall（学习教程，架构、业务、技术要点全方位解析）">https://github.com/macrozheng/mall-learningmall（学习教程，架构、业务、技术要点全方位解析）</a></p><p>SpringBoot 电商商城系统 Mall4j：<a href="https://github.com/gz-yami/mall4j">https://github.com/gz-yami/mall4j</a></p><p>SpringBoot 完整电商系统 Mall：<a href="https://github.com/macrozheng/mall（包括前台商城系统及后台管理系统，基于">https://github.com/macrozheng/mall（包括前台商城系统及后台管理系统，基于</a> SpringBoot+MyBatis 实现）</p><p>newbee-mall：<a href="https://github.com/newbee-ltd/newbee-mall">https://github.com/newbee-ltd/newbee-mall</a> （一套电商系统，包括 newbee-mall 商城系统及 newbee-mall-admin 商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发）</p><p>paascloud-master：<a href="https://github.com/paascloud/paascloud-master（基于">https://github.com/paascloud/paascloud-master（基于</a> spring cloud + vue + oAuth2.0，前后端分离商城系统）</p><p>mall-swarm：<a href="https://github.com/macrozheng/mall-swarm（一套微服务商城系统，采用了">https://github.com/macrozheng/mall-swarm（一套微服务商城系统，采用了</a> Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台方便快速搭建系统）</p><p>onemall：<a href="https://github.com/YunaiV/onemall（mall">https://github.com/YunaiV/onemall（mall</a> 商城，基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba）</p><p>litemall：<a href="https://github.com/linlinjava/litemall（又一个小商城，litemall">https://github.com/linlinjava/litemall（又一个小商城，litemall</a> = Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端）</p><p>xmall：<a href="https://github.com/Exrick/xmall">https://github.com/Exrick/xmall</a> （基于SOA架构的分布式电商购物商城 前后端分离 前台商城:Vue全家桶 后台管理系统）</p><p>miaosha：<a href="https://github.com/qiurunze123/miaosha">https://github.com/qiurunze123/miaosha</a> （秒杀系统设计与实现）</p><p>SecKill：<a href="https://github.com/hfbin/Seckill（基于">https://github.com/hfbin/Seckill（基于</a> SpringBoot+Mybatis+Redis+RabbitMQ 秒杀系统）</p><p>博客论坛<br>Mblog：开源 Java 博客系统</p><p>halo：一个优秀的开源博客发布应用</p><p>forum-java：一款用 Java（spring boot） 实现的现代化社区（论坛/问答/BBS/社交网络/博客）系统平台</p><p>vhr：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。</p><p>favorites-web:云收藏 Spring Boot 2.X 开源项目。云收藏是一个使用 Spring Boot 构建的开源网站，可以让用户在线随时随地收藏的一个网站，在网站上分类整理收藏的网站或者文章。</p><p>community：码问，开源论坛、问答系统，现有功能提问、回复、通知、最新、最热、消除零回复功能。技术栈 Spring、Spring Boot、MyBatis、MySQL/H2、Bootstrap</p><p>NiterForum：尼特社区-NiterForum-一个论坛/社区程序。后端Springboot/MyBatis/Maven/MySQL，前端Thymeleaf/Layui。可供初学者，学习、交流使用。</p><p>VBlog：V部落，Vue+SpringBoot实现的多用户博客管理平台!</p><p>NiceFish：SpringBoot/SpringCloud 前后端分离项目</p><p>My-Blog：My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验。</p><p>My-Blog-layui：layui 版本的 My-Blog : A simple &amp; beautiful blogging system implemented with spring-boot &amp; layui &amp; thymeleaf &amp; mybatis My Blog 是由  SpringBoot + Layui + Mybatis + Thymeleaf 等技术实现的 Java  博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验</p><p>symphony：Java 实现的现代化社区</p><p>管理系统<br>Spring-Cloud-Admin：Cloud-Admin 是国内首个基于 Spring Cloud 微服务化开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关 API 管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。核心技术采用 Spring Boot2 以及 Spring Cloud Gateway 相关核心组件，前端采用 vue-element-admin 组件。</p><p>bootshiro：基于 springboot+shiro+jwt 的资源无状态认证权限管理系统后端</p><p>悟空CRM：基于jfinal+vue+ElementUI的前后端分离CRM系统</p><p>EL-ADMIN：基于 SpringBoot 的后台管理系统</p><p>pig：基于 Spring Boot 2.2、 Spring Cloud Hoxton &amp; Alibaba、 OAuth2 的 RBAC 权限管理系统。</p><p>FEBS-Shiro：Spring Boot 2.1.3，Shiro1.4.0 &amp; Layui 2.5.4 权限管理系统。</p><p>Spring Boot-Shiro-Vue：基于Spring Boot-Shiro-Vue 的权限管理</p><p>studentmanager：基于springboot+mybatis学生管理系统</p><p>jshERP：华夏ERP基于SpringBoot框架和SaaS模式，立志为中小企业提供开源好用的ERP软件，目前专注进销存+财务功能。主要模块有零售管理、采购管理、销售管理、仓库管理、财务管理、报表查询、系统管理等。支持预付款、收入支出、仓库调拨、组装拆卸、订单等特色功能。拥有库存状况、出入库统计等报表。同时对角色和权限进行了细致全面控制，精确到每个按钮和菜单。</p><p>HotelSystem：酒店管理系统 Java,tomcat,mysql,servlet,jsp实现，没有使用任何框架</p><h4 id="开发平台"><a href="#开发平台" class="headerlink" title="开发平台"></a>开发平台</h4><p>open-capacity-platform：微服务能力开发平台<br>jeecg-boot：JeecgBoot是一款基于BPM的低代码平台！前后端分离架构 SpringBoot 2.x，SpringCloud，Ant  Design&amp;Vue，Mybatis-plus，Shiro，JWT，支持微服务。强大的代码生成器让前后端代码一键生成，实现低代码开发！<br>其他<br>学之思在线考试系统：一款 java + vue 的前后端分离的考试系统</p><p>PassJava-Platform：一款面试刷题的 Spring Cloud 开源系统</p><p>kkFileView：使用spring boot打造文件文档在线预览项目</p><p>dynamic-datasource：一个基于springboot的快速集成多数据源的启动器</p><p>moti-cloud：莫提网盘，基于 SpringBoot+MyBatis+ThymeLeaf+BootStrap，适合初学者</p><p>threadandjuc：three-high-import 高可用\高可靠\高性能，三高多线程导入系统（该项目意义为理论贯通)</p><p>proxyee-down：http下载工具，基于http代理，支持多连接分块下载</p><p>hosp_order：医院预约挂号系统，基于 SSM 框架</p><p>趋势投资 SpringCloud</p><p>DiyTomcat</p><h2 id="阶段-6：Java-高级"><a href="#阶段-6：Java-高级" class="headerlink" title="阶段 6：Java 高级"></a>阶段 6：Java 高级</h2><p>目标<br>不满足于能做，而是通过更 深入 和 广泛 的学习，实现高质量的代码和更优秀的架构，培养解决问题的能力。</p><h3 id="并发编程（21-天）"><a href="#并发编程（21-天）" class="headerlink" title="并发编程（21 天）"></a>并发编程（21 天）</h3><p>对 Java 后端开发程序员来说，懂得如何利用有限的系统资源来提高系统的性能是很重要的，也是大厂面试考察的重点，因此并发编程（尤其是 Java 并发包的使用）这块的知识很重要。</p><p>把它放到高级，是因为在学并发编程前，需要有一定的编程经验、了解一定的操作系统知识。</p><p>知识<br>线程和进程<br>线程状态<br>并行和并发<br>同步和异步<br>Synchronized<br>Volatile 关键字<br>Lock 锁<br>死锁<br>可重入锁<br>线程安全<br>线程池<br>JUC 的使用<br>AQS<br>Fork Join<br>CAS<br>学习建议<br>并发编程入门不难，依然是 先学会使用 基础的 Java 并发包， 再通过大量地实践和测试，了解一些原理，才能真正掌握何时使用、如何更合理地使用并发编程。</p><p>资源<br>视频</p><p>⭐【尚硅谷】大厂必备技术之JUC并发编程2021最新版：<a href="https://www.bilibili.com/video/BV1Kw411Z7dF（特点是短、精、新）">https://www.bilibili.com/video/BV1Kw411Z7dF（特点是短、精、新）</a><br>黑马程序员全面深入学习Java并发编程：<a href="https://www.bilibili.com/video/BV16J411h7Rd（讲的很细、全面深入）">https://www.bilibili.com/video/BV16J411h7Rd（讲的很细、全面深入）</a><br>书籍</p><p>⭐《Java并发编程实战》（国外的经典）<br>⭐《Java 并发编程艺术》（国人写的，理论思想内容较多，有时间建议反复看）<br>项目</p><p>⭐ Java 并发知识点总结：<a href="https://github.com/CL0610/Java-concurrency">https://github.com/CL0610/Java-concurrency</a></p><h3 id="JVM（30-天）"><a href="#JVM（30-天）" class="headerlink" title="JVM（30 天）"></a>JVM（30 天）</h3><p>想要深入理解 Java，探秘 Java 跨平台的奥秘，一定要了解 Java 底层的虚拟机技术。</p><p>了解虚拟机、掌握虚拟机性能调优方法，有助于你写出更高性能、资源占用更小的优质程序。</p><p>在学习 JVM 的过程中，也能学到很多精妙的设计，开拓思路。</p><p>知识<br>JVM 内存结构<br>JVM 生命周期<br>主流虚拟机<br>Java 代码执行流程<br>类加载<br>类加载器<br>类加载过程<br>双亲委派机制<br>垃圾回收<br>垃圾回收器<br>垃圾回收策略<br>垃圾回收算法<br>StopTheWorld<br>字节码<br>内存分配和回收<br>JVM 性能调优<br>性能分析方法<br>常用工具<br>参数设置<br>学习建议<br>JVM 的知识略显枯燥，建议先看视频，有实操的地方一定要实操！自己多去分析。</p><p>第一遍不理解没有关系，可以再看书来巩固，想要真正学好，《深入理解 Java 虚拟机（第三版）》一定要读。</p><p>如果只是为了通过面试可以直接看更精简的视频，比如狂神的。</p><p>资源<br>视频</p><p>⭐ 尚硅谷宋红康 - JVM 全套教程详解：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ（讲得相当全面！附有实操）">https://www.bilibili.com/video/BV1PJ411n7xZ（讲得相当全面！附有实操）</a></p><p>【狂神说Java】JVM快速入门篇：<a href="https://www.bilibili.com/video/BV1iJ411d7jS（讲得有点浅，但都是面试重点，时间紧的小伙伴可以直接看这个）">https://www.bilibili.com/video/BV1iJ411d7jS（讲得有点浅，但都是面试重点，时间紧的小伙伴可以直接看这个）</a></p><p>书籍</p><p>⭐《深入理解 Java 虚拟机（第三版）》（有理论有实践，内容丰富，不可多得的 JVM 学习神书，就是有点废头发）<br>项目</p><p>⭐ Java 虚拟机底层原理知识总结：<a href="https://github.com/doocs/jvm">https://github.com/doocs/jvm</a><br>实战</p><p>阿里云 JVM 实战：<a href="https://developer.aliyun.com/graph/java/point/64">https://developer.aliyun.com/graph/java/point/64</a><br>架构设计<br>分布式<br>分布式理论</p><p>CAP<br>BASE<br>分布式缓存</p><p>Redis<br>Memcached<br>Etcd<br>一致性算法</p><p>Raft<br>一致性哈希<br>分布式事务</p><p>分布式 id 生成</p><p>分布式服务调用</p><p>分布式存储</p><p>分布式数据库</p><p>分布式文件系统</p><p>分布式协调</p><p>Zookeeper<br>分布式监控</p><p>Prometheus<br>分布式消息队列</p><p>RabbitMQ<br>Kafka<br>Apache Pulsar<br>分布式日志收集</p><p>Elastic Stack<br>Loki<br>分布式搜索引擎</p><p>Elasticsearch<br>分布式链路追踪</p><p>Apache SkyWalking<br>分布式配置中心</p><p>Apollo<br>Nacos<br>高可用<br>主从<br>异地多活<br>容灾备份<br>高并发<br>数据库</p><p>分库分表<br>读写分离<br>缓存</p><p>缓存雪崩<br>缓存击穿<br>缓存穿透<br>负载均衡</p><p>负载均衡算法<br>软硬件负载均衡（2、3、4、7 层）<br>其他<br>监控告警</p><p>领域驱动设计</p><p>应用安全</p><p>线上故障分析</p><p>服务网格</p><p>Serverless</p><p>云原生</p><p>学习建议<br>多看文章多思考</p><h2 id="阶段-7：Java-求职"><a href="#阶段-7：Java-求职" class="headerlink" title="阶段 7：Java 求职"></a>阶段 7：Java 求职</h2><p>目标<br>找到好工作</p><p>建议<br>尽早做规划，可以通过大厂招聘官网的岗位描述来了解岗位的要求</p><p>雕琢一份优秀的简历，推荐阅读：<a href="https://mp.weixin.qq.com/s/wfabzdpOPdq89faFFpZ4NA">https://mp.weixin.qq.com/s/wfabzdpOPdq89faFFpZ4NA</a></p><p>多读面经，坚持刷算法</p><p>多参与面试，持续复盘总结</p><p>资源<br>岗位要求<br>阿里 Java 开发：<a href="https://campus.alibaba.com/position.htm?refno=12699">https://campus.alibaba.com/position.htm?refno=12699</a></p><p>腾讯后台开发：<a href="https://join.qq.com/post_detail.html?pid=1&amp;id=101&amp;tid=2">https://join.qq.com/post_detail.html?pid=1&amp;id=101&amp;tid=2</a></p><p>腾讯全栈开发：<a href="https://join.qq.com/post_detail.html?pid=1&amp;id=137&amp;tid=2">https://join.qq.com/post_detail.html?pid=1&amp;id=137&amp;tid=2</a></p><p>腾讯运营开发：<a href="https://join.qq.com/post_detail.html?pid=1&amp;id=105&amp;tid=2">https://join.qq.com/post_detail.html?pid=1&amp;id=105&amp;tid=2</a></p><p>美团后端开发：<a href="https://campus.meituan.com/jobs?jobFamily=1&amp;jobId=4005&amp;jobType=1&amp;pageNo=2">https://campus.meituan.com/jobs?jobFamily=1&amp;jobId=4005&amp;jobType=1&amp;pageNo=2</a></p><p>华为软件开发：<a href="https://career.huawei.com/reccampportal/portal5/campus-recruitment-detail.html?jobId=176044">https://career.huawei.com/reccampportal/portal5/campus-recruitment-detail.html?jobId=176044</a></p><p>鱼皮经历<br>从 0 开始的编程学习进大厂经历</p><p>⭐ 我学计算机的四年，共勉：<a href="https://mp.weixin.qq.com/s/Nc7Ee2UyrPg6hGseQUCzeg">https://mp.weixin.qq.com/s/Nc7Ee2UyrPg6hGseQUCzeg</a><br>实习经历</p><p>⭐ 我的第一份实习：<a href="https://mp.weixin.qq.com/s/SwGiRzyTkCOOCUXfXPR1Pw">https://mp.weixin.qq.com/s/SwGiRzyTkCOOCUXfXPR1Pw</a></p><p>⭐ 我的第二份实习，字节跳动：<a href="https://mp.weixin.qq.com/s/3q-YIfuZBjPjSnamNwOraw">https://mp.weixin.qq.com/s/3q-YIfuZBjPjSnamNwOraw</a></p><p>知识总结<br>⭐ 牛客 Java 面试宝典：<a href="https://www.nowcoder.com/tutorial/94">https://www.nowcoder.com/tutorial/94</a></p><p>⭐ JavaGuide：<a href="https://snailclimb.gitee.io/javaguide/#/">https://snailclimb.gitee.io/javaguide/#/</a></p><p>⭐ CS-Notes：<a href="http://www.cyc2018.xyz/">http://www.cyc2018.xyz/</a></p><p>阿里 Java 技术图谱：<a href="https://developer.aliyun.com/graph/java">https://developer.aliyun.com/graph/java</a></p><p>面经<br>⭐ 2021 最新 Java 笔试、面试题合集：<a href="https://pan.baidu.com/s/1DE4HAu-DS80n7VOaGpU_KQ（密码：lkw1）">https://pan.baidu.com/s/1DE4HAu-DS80n7VOaGpU_KQ（密码：lkw1）</a></p><p>⭐ 牛客面经：<a href="https://www.nowcoder.com/discuss/experience?tagId=639">https://www.nowcoder.com/discuss/experience?tagId=639</a></p><p>视频<br>⭐ 尚硅谷 2021 逆袭版 Java 面试题第三季：<a href="https://www.bilibili.com/video/BV1Hy4y1B78T">https://www.bilibili.com/video/BV1Hy4y1B78T</a></p><p>⭐ 阿里大佬透彻讲解 Java 面试 500 道必考题：<a href="https://www.bilibili.com/video/BV1yU4y1J7Bb">https://www.bilibili.com/video/BV1yU4y1J7Bb</a></p><h2 id="阶段-8：持续学习"><a href="#阶段-8：持续学习" class="headerlink" title="阶段 8：持续学习"></a>阶段 8：持续学习</h2><p>目标<br>持续追求技术的深度和广度，培养自己的 核心竞争力 和 不可替代性 ，学无止境！</p><p>学习建议<br>自主学习，自主搜索教程，多看书，多阅读技术博客，多实践。</p><p>学习方向<br>框架源码<br>Spring<br>SpringBoot<br>SpringMVC<br>MyBatis<br>Netty<br>Dubbo<br>SpringCloud<br>计算机原理<br>《算法导论》：<a href="https://www.bilibili.com/video/av48922404">https://www.bilibili.com/video/av48922404</a></p><p>《现代操作系统》：<a href="https://www.bilibili.com/video/av9555596">https://www.bilibili.com/video/av9555596</a></p><p>《深入理解计算机系统》：<a href="https://www.bilibili.com/video/av31289365">https://www.bilibili.com/video/av31289365</a></p><p>《编译原理》：<a href="https://www.bilibili.com/video/av17649289">https://www.bilibili.com/video/av17649289</a></p><p>《计算机网络：自顶向下方法》：<a href="https://www.bilibili.com/video/av41404195">https://www.bilibili.com/video/av41404195</a></p><p>《计算机程序的构造和解释》：<a href="https://www.bilibili.com/video/av8515129">https://www.bilibili.com/video/av8515129</a></p><p>《数据库系统概念》：<a href="https://www.bilibili.com/video/av52007695">https://www.bilibili.com/video/av52007695</a></p><p>数据库 / 中间件 / 分布式<br>数据库<br>MySQL<br>PostgreSQL<br>缓存<br>Redis<br>队列<br>Apache Kafka<br>Apache Pulsar<br>搜索引擎<br>Elastic Stack<br>容器<br>Docker<br>K8S<br>解决方案<br>广告<br>电商<br>搜索<br>游戏<br>即时通讯<br>社交<br>CMS<br>ERP<br>OA<br>架构<br>亿级流量架构<br>秒杀系统<br>架构选型能力<br>大数据<br>5V 特点<br>Hadoop<br>HDFS<br>MapReduce<br>Spark<br>Flink<br>Storm<br>Hive<br>HBase<br>Druid<br>Kylin<br>Pig<br>Mahout<br>前沿技术<br>云原生：<a href="https://www.jianshu.com/p/a37baa7c3eff">https://www.jianshu.com/p/a37baa7c3eff</a></p><p>Quasar Framework：<a href="http://www.quasarchs.com/">http://www.quasarchs.com/</a></p><p>自学 Java 专题资源<br>GitHub Java 专区：<a href="https://github.com/topics/java">https://github.com/topics/java</a></p><p>GitHub Java 合集：<a href="https://github.com/akullpp/awesome-java">https://github.com/akullpp/awesome-java</a></p><p>StackOverflow：<a href="https://stackoverflow.com/questions/tagged/java（解决问题必备）">https://stackoverflow.com/questions/tagged/java（解决问题必备）</a></p><p>掘金 Java 专区：<a href="https://juejin.cn/tag/Java">https://juejin.cn/tag/Java</a></p><p>美团技术团队：<a href="https://tech.meituan.com/">https://tech.meituan.com/</a></p><p>阿里技术团队：<a href="https://102.alibaba.com/tech/list/">https://102.alibaba.com/tech/list/</a></p><p>有赞技术团队：<a href="https://tech.youzan.com/tag/back-end/">https://tech.youzan.com/tag/back-end/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 学习路线一条龙版 by 鱼皮。&lt;/p&gt;
&lt;p&gt;原创不易，请勿抄袭，违者必究！&lt;/p&gt;
&lt;p&gt;大家好，我是鱼皮。现在网上的编程资料实在太多了，而且人人肯定都说自己的最好，那就导致大家又不知道怎么选了。大部分的博主推荐资源，也就是把播放量高的视频说一遍，水一期视频，没</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学下</title>
    <link href="http://yoursite.com/2022/05/22/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8B/"/>
    <id>http://yoursite.com/2022/05/22/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8B/</id>
    <published>2022-05-22T11:58:36.000Z</published>
    <updated>2022-06-24T02:45:51.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="经典加密"><a href="#经典加密" class="headerlink" title="经典加密"></a>经典加密</h2><p>在数字计算机没有发明之前，加密都是对字符进行加密，一般采用的方法是字母替换，我把它称为 经典加密 。</p><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>简单的字母替换规则可以通过对字母表进行循环移位而来，最早记载的凯撒（Caesar）密码就是采用这种方式。凯撒密码是传说中的凯撒大帝发明，加密时将明文中的每个字母都按照其在字母表中的顺序向后移动固定数目生成密文。例如，当偏移量是右移3(+3)的时候形成下面的字母替换表：</p><blockquote><p>+——+—————————————+<br>|明文|ABCDEFGHIJKLMNOPQRSTUVWXYZ|<br>+——+—————————————+<br>|密文|DEFGHIJKLMNOPQRSTUVWXYZABC|<br>+——+—————————————+</p></blockquote><p>对应我们的明文 <font color="red">GAME404</font> 就变成了密文 <font color="red"> JDPH404 </font>。解密时候再把密文在字母表中左移3(-3)得到明文 GAME404。这种情况下凯撒密码的秘钥就是单个数字3。</p><p>凯撒密码现在看来是比较小儿科，但是在2000多年前，是了不起的发明，为凯撒部队的保密工作做了贡献。即使是到现在，军事上的信息保密需求，任然是密码学前进的最大动力。</p><blockquote><p>这里数字忽略加密，采用原文传输</p></blockquote><h2 id="ROT13加密"><a href="#ROT13加密" class="headerlink" title="ROT13加密"></a>ROT13加密</h2><p>rot13（rotate by 13 places）也是一种简易的替换式密码，是凯撒密码的变种。rot13将明文偏移13位形成密文，因为英文总共26位，所以密文再偏移13位后会循环回到原文，非常巧妙的设计，加密和解密使用同一个方法。这是公式:  <font color="red">rot13(rot13(xxx))=xxx</font>。在python3中默认带rot_13的算法实现, 下面是用例:</p><blockquote><p>➜  ~ echo “game404” | python -m encodings.rot_13<br>tnzr404<br>➜  ~ echo “tnzr404” | python -m encodings.rot_13<br>game404</p></blockquote><h2 id="随机单表替换"><a href="#随机单表替换" class="headerlink" title="随机单表替换"></a>随机单表替换</h2><p>采用位移形成的字母替换，有明显的规律。加密中最要的一点是 随机 ，所以可以使用随机的方式形成字母替换表:</p><blockquote><p>+——+—————————————+<br>|明文|ABCDEFGHIJKLMNOPQRSTUVWXYZ|<br>+——+—————————————+<br>|密文|ZEBRASCDFGHIJKLMNOPQTUVWXY|<br>+——+—————————————+</p></blockquote><p>这样加密和解密都必须持有  <font color="red">ZEBRASCDFGHIJKLMNOPQTUVWXY</font> 这个完整的密码本，长度为26位，而不是3或者13这样的单位秘钥。<br>随机单表替换，初看无法得到具体信息。但是一些密码破译专家，也是数学家就可以看到一些统计规律。比如明文 hello game 加密后的密文  <font color="red">daiil czja</font>。因为在英语中字母e是频率最高的字符，根据前面的密文表现，可以初步推断 e-&gt;a。如果我们再掌握更多的密文，分析其中的统计规律，使用类似求解数独的方式，破译密码。</p><h2 id="维吉尼亚多表替换密码"><a href="#维吉尼亚多表替换密码" class="headerlink" title="维吉尼亚多表替换密码"></a>维吉尼亚多表替换密码</h2><p>单表替换容易透露统计规律，自然的改进思路就是使用多表替换，每个字母采用不同的替换规则，让规律不好捉摸。比如下面的维吉尼亚多表:<br><img src="img/维吉尼亚多表替换.png"></p><blockquote><p>此密码曾被误以为由布莱斯•德•维吉尼亚所创，所以才叫作维吉尼亚密码，实际上最著名的一种为吉奥万•巴蒂斯塔•贝拉索于1585年推出。它于1863年之前一直未被破解。法国人称它作“不能破译的密码”。<br>维吉尼亚密码中,表格的第一行只需直接填上26个字母,然后以下每一行的字母都是向左偏移一格，形成对称结构。这叫作表格横移,数学上每一列同余26。<br>这种密码需要使用一个关键字来作为密钥，关键字按字循环使用。</p></blockquote><p>假设关键字是CAT,明文的第一个字由C加密,第二个字由A加密,第三个则由T加密,然后再回到C加密,一直重复。加密按照上边的密码表,例如明文BALL用CAT作关键字时会得到密文DAEN,同一个字母L会加密成2个不同字母EN。现实中,维吉尼亚密码的关键字非常长，破解难度提高了很多。<br>维吉尼亚密码的密码本是规则的，所以破解的关键在于找到关键字。具体破解办法还是要从统计规律入手，进行暴力破解。<br>恩尼格玛密码机<br>人为制作的密码本是规则且有限，所以聪明的人想出了制作密码机器。恩尼格玛密码机(德語：Enigma)是第二次世界大战时的纳粹德国使用的密码机。关于恩尼格玛密码机和图灵的故事非常精彩和传奇，也有很多文章介绍。这里我只是简单介绍一小小部分。恩尼格玛密码机大概长这样:</p><p>看起来和一个机械打字机类似，顶部的转子用来旋转设置秘钥，转子内部自动生成不同的密码表，底部的键盘用来键入明文，每个明文经过机器转换加密后输出到中间的灯泡，记录下灯泡的位置就得到密文。解密的时候设置好相同的转子位置，然后输入密文，就得到了明文。<br>因为恩尼格玛密码机加密非常复杂，不犯错的情况下人肉难以快速破解。所以后来大神图灵登场，设计了“炸弹机”，用机器来破解机器，从此开启了计算机的新时代。<br>数字加密<br>在数字世界里，字符不再是不可分割。经典场景中字符A是原子的，没法拆分成左半个A和右半个A。数字世界0和1才是原子的，字符可以分解成不同的0和1组合，比如:</p><blockquote><blockquote><blockquote><p>a = “a”<br>print(a, ord(a), bin(ord(a)))<br>a 97 0b1100001</p></blockquote></blockquote></blockquote><p>字符a的ASCII码是97，对应的二进制是8位001100001。这样我们就可以把a打散成两部分，比如左边6位0011000，右边2位01，再和别的字符重新排列。<br>base64<br>所谓Base64，就是说选出64个字符——小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）——作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。这种加密方式因为密码本公开，所以一般只是称为base64 编码，而不叫做base64 加密。<br>阮一峰老师的Base64笔记介绍的非常好，大家可以通过尾部的参考链接去查看。我偷懒简单整理一下。先是base64的码表:<br>码值    字符    码值    字符    码值    字符    码值    字符<br>0    A    16    Q    32    g    48    w<br>1    B    17    R    33    h    49    x<br>2    C    18    S    34    i    50    y<br>3    D    19    T    35    j    51    z<br>4    E    20    U    36    k    52    0<br>5    F    21    V    37    l    53    1<br>6    G    22    W    38    m    54    2<br>7    H    23    X    39    n    55    3<br>8    I    24    Y    40    o    56    4<br>9    J    25    Z    41    p    57    5<br>10    K    26    a    42    q    58    6<br>11    L    27    b    43    r    59    7<br>12    M    28    c    44    s    60    8<br>13    N    29    d    45    t    61    9<br>14    O    30    e    46    u    62    +<br>15    P    31    f    47    v    63    /</p><p>然后部分ASCII码表:<br>二进制    十进制    十六进制    图形<br>…<br>0100 1101    77    4D    M<br>…<br>0110 0001    97    61    a<br>…<br>0110 1110    110    6E    n</p><p>那么base64的编码过程如下:</p><p>AESDESAES 代表高级加密标准Advanced Encryption StandardDES代表数据加密标准Data Encryption Standard创作日期为1999年。创作日期为1976年。面向字节。面向位。密钥长度可以是 128 位、192 位和 256 位。DES 中的密钥长度为 56 位。轮数取决于密钥长度：10（128 位）、12（192 位）或 14（256 位）DES涉及16轮相同操作该结构基于置换-置换(substitution-permutation)网络。该结构基于Feistel网络。AES 的设计原理是开放的。DES 的设计原理是封闭的。对此的选择过程是秘密的，但接受了公开的公众评论。选择过程是秘密的。AES 比 DES 密码更安全，是事实上的世界标准。DES 很容易被破解，因为它有已知的漏洞。3DES（三重 DES）是 DES 的一种变体，它比通常的 DES 更安全。AES 中的轮次是：字节替换、移位行、混合列和密钥加法DES 中的轮是：扩展、使用轮密钥的 XOR 操作、替换和置换AES 可以加密 128 位的明文。DES 可以加密 64 位的明文。AES 密码是从旁通道方密码派生的。DES密码源自路西法密码。AES 由 Vincent Rijmen 和 Joan Daemen 设计。DES 由 IBM 设计。没有已知的针对 AES 的密码分析攻击，但可能会针对 AES 实施进行侧信道攻击。Biclique 攻击比蛮力攻击具有更好的复杂性，但仍然无效。针对 DES 的已知攻击包括暴力破解、线性密码分析和差分密码分析。<br>DES的算法比较复杂，我简单总结一下大概步骤：</p><p>准备64位的明文和64位的密钥<br>秘钥经过16次调度，形成16个子秘钥<br>每个子秘钥，通过从秘钥64位摘取56位，分成左右各28位的L端和R端。然后L端和R端各自左移指定轮次的位数，然后拼接L端和R端。这个过程是字节的重组。最后对形成的秘钥在进行一次置换。得到48位的子秘钥。<br>重复上面的步骤3，直到得到16个48位子秘钥<br>明文的64位根据置换表进行一次置换，再拆分成L端和R端各32位<br>循环执行L，R = R，F(L，子秘钥)16次，就是把R端复制给L，然后把32位的L和48位的子秘钥使用f函数进行加密。<br>最后把L和R拼接后进行再进行一次置换得到密文</p><p>可以看到算法中关键点, F函数。 Feistel函数重点是把32位的一半明文和48位的子秘钥，混合得出一个32位的等长秘钥。这个过程依赖一个不透明的预制机制S盒，所以其实不收大家信任，怀疑算法留有后门。这个过程，我们可以把它想象成接水管游戏，不同的输入经过内部管道处理，输出特定的结果:</p><p>DES加密的思想，总结起来就是二进制位的重组和替换。DES和AES都是成熟的算法，一般情况下我们不需要实现它。出于安全性考虑，DES已经弃用，现在实际业务中一般直接利用AES的API即可。下面是完整的实现:<br>from base64 import b64encode, b64decode<br>from Crypto.Cipher import AES<br>from Crypto.Util.Padding import pad, unpad</p><p>def ase_cbc():<br>    data = b”secret”<br>    key = b”jSOlan6Co5Ac2HiT”<br>    cipher = AES.new(key, AES.MODE_CBC, iv=key[:AES.block_size])<br>    ct_bytes = cipher.encrypt(pad(data, AES.block_size))<br>    ciphertext = b64encode(ct_bytes).decode(‘utf-8’)<br>    print(ciphertext)<br>    ct = b64decode(b64encode(ct_bytes).decode())<br>    cipher = AES.new(key, AES.MODE_CBC, iv=key[:AES.block_size])<br>    dat = unpad(cipher.decrypt(ct), AES.block_size)<br>    print(dat)</p><p> svhpgz4vi1AgHDtdt8aaww==<br> b’secret’</p><p>明文是6个字节，秘钥是16个字节<br>创建一个ase的算法实现，这使用cbc模式<br>使用pad方法先对明文数据进行补齐<br>对明文进行加密得到密文，密文是二进制<br>因为二进制密文打印会乱码，所以将其使用base64编码转换成ascii字符<br>解密则是加密的逆过程</p><p>非对称加密算法<br>前一篇文章介绍过非对称加密的一些思路，和对称加密不同的是秘钥分成一个秘钥对：私钥+公钥。公钥用于加密，私钥永于解密。在介绍非对称加密的算法实现之前，我们先看看物理世界的非对称加密模拟，有助于我们理解非对称加密的基本逻辑。</p><p>上面是我简单画的一个非对称加密信箱，分成上下2个盒子，中间是联通的。上方盒子需要使用四角星的钥匙打开，下方盒子需要使用五角星的的钥匙打开。那么一个信息加密传输过程大概如下:</p><p>发送方甲用自己的锁把上方盒子用四角星锁锁住，然后把信箱传递给接收方乙。<br>接收方乙收到信箱后把下方盒子用五角星锁锁住，然后把信息回传给发送方甲。<br>甲用四角星钥匙打开上方盒子，塞入信件，然后把信箱和信件一起传递给乙。<br>乙用五角星钥匙打开下方盒子，取出信件。完成一次信息加密传输。</p><p>在这个信息传递过程中，甲乙的钥匙都分别自己保管，没有经过运输。甲用四角星钥匙加锁，乙用五角星钥匙解锁，而且信件都在信箱中。这样保证了信息传递是安全的。<br>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法，现在是非对称加密的标准。算法主要采用的是质数因式分解这样一个”盒子”比如下面一个等式:<br>n = 61×53 = 3233</p><p>61和53的乘积，大家口算或者笔算有可能可以计算出来，但是反过来求3233是那两个质数的乘积却非常难。在非对称加密情况下，我们选择一个随机数，比如17。使用(3233，17)这样的信息组成公钥，然后使用类似(3233,17<em>61/17</em>65)这样的信息组成私钥。公钥只是私钥的一部分信息，这样公钥加密的信息，逻辑上私钥肯定可以解密。而且通过公钥的3233，很难推断出私钥中的61*53。当然非对称加密的数学验证比这个举例要严谨和复杂的多，我这里只是尝试举例，帮助理解。<br>加密示例:<br>def rsa_enc():<br>    from Crypto.PublicKey import RSA<br>    from Crypto.Random import get_random_bytes<br>    from Crypto.Cipher import AES, PKCS1_OAEP</p><pre><code>data = &quot;I met aliens in UFO. Here is the map.&quot;.encode(&quot;utf-8&quot;)file_out = open(&quot;encrypted_data.bin&quot;, &quot;wb&quot;)recipient_key = RSA.import_key(open(&quot;public.pem&quot;).read())session_key = get_random_bytes(16)# Encrypt the session key with the public RSA keycipher_rsa = PKCS1_OAEP.new(recipient_key)enc_session_key = cipher_rsa.encrypt(session_key)# Encrypt the data with the AES session keycipher_aes = AES.new(session_key, AES.MODE_EAX)ciphertext, tag = cipher_aes.encrypt_and_digest(data)[file_out.write(x) for x in (enc_session_key, cipher_aes.nonce, tag, ciphertext)]file_out.close()</code></pre><p>秘钥可以使用代码生成，也可以使用OpenSSL工具生成，这里我使用上一篇文章中的秘钥<br>导入rsa公钥<br>随机一个AES秘钥，然后使用rsa公钥加密这个秘钥<br>使用AES加密信息<br>将AES秘钥密文，AES的随机数，iv和密文写入结果</p><p>解密示例:<br>from Crypto.PublicKey import RSA<br>from Crypto.Cipher import AES, PKCS1_OAEP</p><p>file_in = open(“encrypted_data.bin”, “rb”)</p><p>private_key = RSA.import_key(open(“private.pem”).read())</p><p>enc_session_key, nonce, tag, ciphertext = \<br>   [ file_in.read(x) for x in (private_key.size_in_bytes(), 16, 16, -1) ]</p><p> Decrypt the session key with the private RSA key<br>cipher_rsa = PKCS1_OAEP.new(private_key)<br>session_key = cipher_rsa.decrypt(enc_session_key)</p><p> Decrypt the data with the AES session key<br>cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)<br>data = cipher_aes.decrypt_and_verify(ciphertext, tag)<br>print(data.decode(“utf-8”))</p><p>导入rsa私钥<br>读取结果，并按位从中解析出aes私钥密文，随机数，iv和剩下的密文信息<br>使用rsa私钥从aes秘钥的密文中解析出aes密钥明文<br>使用aes秘钥解密密文信息</p><p>这一对过程的重点是，rsa仅仅加密aes的私钥，私钥的密文进行传输 。encrypted_data.bin是二进制的，直接使用文本方式查看会是乱码，我们可以转换为base64方式查看:<br>✗ base64 encrypted_data.bin<br>w+ii4VVphO1ulHjrUy4fcc7CuLxaxJTQuzTtgIqvoot3ivBcRWwxV/1rNqIA2fsddYq8AIRo7jV9xoxbUK9ll8LQdM5S0N9eBakM6wzEwnN9PFrJEKN7VdmTqxnzC7go5tS2qNR173xcJKTX3UXKBTLbKXkafj9k2Bk9g93hRh19Uka/S5AqD43dFjIyI2ogxZNkN0v5E6uAyINlhGO8jCHAN0yhu4S5zz0ph7mFAVfXQkNDuotcdmsRfPpEi641BI/fEGE=</p><p>散列算法<br>散列函数（Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表，用来表示信息完整性。<br>散列函数数学逻辑并不难，首先需要一个奇函数，保证每一个输入可以得到一个唯一的输出:</p><p>然后我们再从输出结果中进行信息摘取部分，这样来保证摘要比原文要短，因为摘要比原文长，那就没有价值。我们可以自己随便设想一个哈希算法:</p><p>函数取值 y=2f(x)+3<br>将结果转换为二进制后循环左移3位<br>将二进制结果拆分成左右两段并还原成2个十进制数<br>使用2个十进制数相乘<br>结果再转换为二进制数据，取其前8位转换成16进制得到哈希值</p><p>根据抽屉原理，9个苹果放到8个箱子，一定有一个箱子会有2个苹果。信息摘要算法一定会有冲突，只是好的算法信息冲突的概率会非常非常低。我们上面的设想的哈希算法，仅仅8位，冲突的概率非常高。好的散列函数在输入域中很少出现散列冲突，知名的算法有MD5和SHA。<br>MD5信息摘要演算法5（MD5 Message-Digest Algorithm 5）是散列算法的一种，可以产生出一個128位（16个字节(BYTES)）的散列值（hash value），一般表示为32位十六进制数字。<br>SHA安全散列算法（Secure Hash Algorithm ）也是一个系列的散列算法。最早SHA-1，正式发布的第一代算法可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。<br>这两种算法都被我国的 王小云 教授破解了，所以这2种算法都被认为安全性不足，不再建议使用，目前较多使用sha256算法。sha256是sha-2算法的变种，输出是256位(32字节)的摘要值，同属sha-2的还有SHA-224，SHA-512等。2015年还推出了sha算法的第3个版本，即sha3。<br>下面是md5和sha256的示例:<br>def hash_sample():<br>    import hashlib<br>    plaintext = “game404”<br>    result = hashlib.md5(plaintext.encode())<br>    md5 = result.hexdigest()<br>    print(md5, len(md5))<br>    result = hashlib.sha256(plaintext.encode())<br>    s256 = result.hexdigest()<br>    print(s256, len(s256))</p><h1 id="e935208860777d1584d3586a9e93e160-32"><a href="#e935208860777d1584d3586a9e93e160-32" class="headerlink" title="e935208860777d1584d3586a9e93e160 32"></a>e935208860777d1584d3586a9e93e160 32</h1><h1 id="c56afda14db3e8b61eb83f17540401ec983e91e92375826d2842e29c8a4db437-64"><a href="#c56afda14db3e8b61eb83f17540401ec983e91e92375826d2842e29c8a4db437-64" class="headerlink" title="c56afda14db3e8b61eb83f17540401ec983e91e92375826d2842e29c8a4db437 64"></a>c56afda14db3e8b61eb83f17540401ec983e91e92375826d2842e29c8a4db437 64</h1><p>license实现<br>了解完所有算法的模型后，license的实现就非常简单了。我们先设置license信息:<br>{<br>    “name”:”game404”，<br>    “expiryDate”: 20220220<br>}</p><p>然后我们将其dump成字符后使用ras签名, 完整代码如下:<br>def rsa_sign():<br>    from Crypto.PublicKey import RSA<br>    from Crypto.Cipher import AES<br>    from Crypto.Signature import PKCS1_v1_5<br>    from Crypto.Hash import SHA256<br>    import json</p><pre><code>license_object = &#123;    &quot;name&quot;: &quot;game404&quot;,    &quot;expiryDate&quot;: 20220220&#125;plaintext = json.dumps(license_object)file_out = open(&quot;encrypted_license.bin&quot;, &quot;wb&quot;)private_key = RSA.import_key(open(&quot;private.pem&quot;).read())# rsa签名cipher_rsa = PKCS1_v1_5.new(private_key)digest = SHA256.new()digest.update(plaintext.encode(&quot;utf-8&quot;))signature = cipher_rsa.sign(digest)# aes加密session_key = get_random_bytes(16)cipher_aes = AES.new(session_key, AES.MODE_EAX)ciphertext, tag = cipher_aes.encrypt_and_digest(plaintext.encode(&quot;utf-8&quot;))# 写licensefile_out.write(b&quot;&quot;.join([session_key, cipher_aes.nonce, tag, signature, ciphertext]))file_out.close()</code></pre><p>证书我们可以base64后发送出去:<br>F4IBtZOODAE5XSdluFynrk8e01gSKwVftivMg+eucfD7j5nCdMZhIcjGyLjQ5miV4Y6mAOooajNypWVL+GTVleXoLUQzqf0hLG02ytuIZ3QlCbGXVn3sofePq+IhwDBH5x2CECwHofzuNH0LbQLlW7LbwXxOl8xvGOw1gCvUgGo8Uuqli0cgrijqKO+n72Rb4Is0KW8EMjvPvaaLodbEhUc2iCLDiDDLXpBvcWsMZeW+AVgfpr6jKR9ICyELg4XQ2s84gs3d+EcFjaFjAzwygBuLYdqa40pR4G/e</p><p>本地验证证书:<br>def rsa_verify():<br>    from Crypto.PublicKey import RSA<br>    from Crypto.Cipher import AES<br>    from Crypto.Signature import PKCS1_v1_5<br>    from Crypto.Hash import SHA256</p><pre><code>file_in = open(&quot;encrypted_license.bin&quot;, &quot;rb&quot;)public_key = RSA.import_key(open(&quot;public.pem&quot;).read())# 读取licensesession_key, nonce, tag, signature, ciphertext = [file_in.read(x) for x in (16, 16, 16, 128, -1)]# aes解密cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)data = cipher_aes.decrypt_and_verify(ciphertext, tag)print(data.decode(&quot;utf-8&quot;))cipher_rsa = PKCS1_v1_5.new(public_key)digest = SHA256.new()digest.update(data)try:    # 验证签名    cipher_rsa.verify(digest, signature)except ValueError:    pass</code></pre><p>证书实际上不需要保密，只需要验证来源的合法性和完整性。所以我们可以看到aes的秘钥是写入到证书文件中的，合法性和完整性使用rsa算法和sha256算法结合来保证。<br>小结<br>本文我们一起回顾了经典加密和数字加密的演化过程，学习了使用 随机 ，变换 和 重组 等方式构建加密算法。重点了解了aes对称加密算法，rsa非对称加密算法以及sha256摘要算法，并利用它实现了一个商业license的制作。<br>数字加密的尽头，可能是量子计算。首先是量子通讯的不可观测性让量子加密具有巨大优势，如果通讯被偷听会导致量子叠加的坍缩，这样还可以主动识别是否被偷听。这个主动防窃听就非常厉害了，是上面的经典计算机的加密算法都无法实现的。其次量子计算机，在并行计算上也有巨大优势，经典计算机无法快速破解的算法，对量子计算机可能秒破。保密和破解这一矛和盾，又将迎来新的一轮变更。<br>最后，最重要的是我国在量子领域处于第一梯队，起步不晚，发展迅速。从md5的破解，再到量子通讯/计算，中国科学家逐渐登场，以后一定会看到更多 中国名字 和 中国标准 。<br>参考链接</p><p>DES算法原理及实现 www.ruanx.net/des/<br>什么是DES加密 www.cxyxiaowu.com/1478.html<br>费斯妥密码 zh.wikipedia.org/wiki/%E8%B4…<br>Feistel Cipher kysonlok.gitbook.io/blog/crypto…<br>Difference between AES and DES ciphers www.geeksforgeeks.org/difference-…<br>维吉尼亚多表替换加密术 sca.gov.cn/sca/zxfw/20…<br>zh.wikipedia.org/wiki/%E6%81…<br>Base64笔记 www.ruanyifeng.com/blog/2008/0…<br>XOR 加密简介 www.ruanyifeng.com/blog/2017/0…<br>pycryptodome.readthedocs.io/en/latest/s…</p><p>作者：游戏不存在<br>链接：<a href="https://juejin.cn/post/7066794630422986788">https://juejin.cn/post/7066794630422986788</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;经典加密&quot;&gt;&lt;a href=&quot;#经典加密&quot; class=&quot;headerlink&quot; title=&quot;经典加密&quot;&gt;&lt;/a&gt;经典加密&lt;/h2&gt;&lt;p&gt;在数字计算机没有发明之前，加密都是对字符进行加密，一般采用的方法是字母替换，我把它称为 经典加密 。&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>密码学</title>
    <link href="http://yoursite.com/2022/05/22/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    <id>http://yoursite.com/2022/05/22/%E5%AF%86%E7%A0%81%E5%AD%A6/</id>
    <published>2022-05-22T11:58:21.000Z</published>
    <updated>2022-05-22T12:20:29.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全防护"><a href="#安全防护" class="headerlink" title="安全防护"></a>安全防护</h2><p>密码学<sup><a href="#fn_密码学" id="reffn_密码学">密码学</a></sup>主要的解决的问题可以分为以下三点<br>    1、 防窃听，就是防止文件在传输过程中的被第三方读取。明信片在邮递过程中，信息可以被任何接触到的人看到，信息就泄露了。解决这个问题，最简单的办法，加一个密封的信封。这样信息在传递过程中就是安全的，其它人看不到。</p><pre><code>2、 防伪造是指防止信息的来源被第三方伪造。传统的信件防伪方法有印章，3、防篡改是指防止信息被第三方修改。传统的方法是使用蜡丸/火漆来包装信息，完整的蜡丸/火漆表示信息未被修改。网络中防窃听的方法是发送方把原文信息进行数字加密，传输密文，接收方只有使用秘钥才可以解开，保证信息的私密性。防伪造的方法是数字签名，发送方给信息附加一个数字签名，表明信息来源的真实性。防篡改的方式是数字摘要，对信息形成一个唯一的摘要，任何微小的原文修改都会导致数字摘要变化，从而保证信息的完整性。</code></pre><h2 id="加密和签名"><a href="#加密和签名" class="headerlink" title="加密和签名"></a>加密和签名</h2><p>加密和解密是一个对称操作，使用秘钥对原文进行加密得到密文，再使用同一秘钥对密文进行解密得到原文。</p><p>这种使用 唯一秘钥 的加密方式叫做 对称加密 。对称加密执行效率很高，但是在网络中如何安全的传输秘钥是个问题？秘钥无法安全传输，加密就达不到防护效果。<br>下面是使用openssl工具进行对称加密的演示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;123abc&quot; | openssl enc -e -aes-128-cbc -pass pass:game404 -base64 -md sha1</span><br><span class="line">U2FsdGVkX1+wwmevh948fa38juYRyBxYYcdL2rWBhMQ=</span><br><span class="line">...</span><br><span class="line"># echo &quot;U2FsdGVkX1+wwmevh948fa38juYRyBxYYcdL2rWBhMQ=&quot; | openssl enc -d -aes-128-cbc -pass pass:game404 -base64 -md sha1</span><br><span class="line">123abc</span><br></pre></td></tr></table></figure></p><p>非对称加密 可以解决秘钥传输的安全问题。在非对称加密中使用一对秘钥: 私钥+公钥。私钥发送方(通常是服务端)保存，公钥通过网络对外发布，可以有多个接收方（通常是客户端）。客户端使用公钥加密后的密文，只能够在服务端使用私钥进行解密，即使再使用公钥也无法完成密文解密。<br>当然也可以反过来，使用私钥“加密”信息，公钥“解密”信息。但是由于公钥有多个，任何持有公钥的客户端，都可以对信息进行解密，所以这种私钥“加密”的信息，起不到保密的作用。只可以用来验证信息来源的唯一性，这个过程通常叫做 签名 和 验签。<br>私钥和公钥还有一个主要特点：公钥是通过私钥生成的，通过公钥很难推断出私钥，这样由于私钥的唯一性，可以做到信息保密。<br>总结一下口诀: 公钥加密，私钥解密；私钥签名，公钥验签 。<br>同样使用openssl工具创建非对称加密的私钥:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl genrsa -out private.pem 1024</span></span><br><span class="line">Generating RSA private key, 1024 bit long modulus</span><br><span class="line">...............++++++</span><br><span class="line">.++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat private.pem</span></span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXAIBAAKBgQDj73NhxbtD0lNJtYA5bWrMRKYhN07r6BYOKqsFMm9N91ZtvW/R</span><br><span class="line">7w87XO6WSt5uqVzBgQAHshQZNh0PNeBp8DpwIQYArG9x/ZZhZnTIsD3wUpbMbp5E</span><br><span class="line">EF4IBgw1284IKtpvV8a7HJzNchl4//bFGkAU/flIP1Upl6ZkOMk6KP76wQIDAQAB</span><br><span class="line">AoGALAqdWbvyBhXCoBBg2TfKFfQBwZNFPZHXiR83ckafeQocehHLZF3zrH21X/bR</span><br><span class="line">acJxuLXrQpFnDsQE82ZumSmgsKJK27yKIrf4eM7IKB0n6vK8WK9V+3L2FFg+p19i</span><br><span class="line">v9sA/sXZuJ7tNmXcbk3Vsqgv0ZRcro1I5PKZJUKZU3yoakECQQD9prACGI6igdMQ</span><br><span class="line">2YhZvuZPZ1zQPjuCBG046+WKXKFUO/IrLJbvvmpz218wzKdL/24A/dZwZHs/KOOh</span><br><span class="line">FYf11DoJAkEA5gvM98VOA+dGmf/KGy5Fx3CgFW+lEojDaNAFo1ZJY1kr6FJIY9H3</span><br><span class="line">n1mxXbXNObvBKi5FMQVgvsiCCHotw0BI+QJBALCxbgh3vNydXT9umZoS7nK/yRrT</span><br><span class="line">TzbaCI/PXB4POt7nx2Gl9Rra5WMBnQTse1nofGO6b6fphyVPQYpT6lsn1KkCQGg7</span><br><span class="line">JI2G6kg+e/C+wtX560foMcBEq6hwKwnMZyGQsQPAnXJQBdikg+vBeemZu/jSpzzz</span><br><span class="line">ZgpGA4Wt16z7nsx+zhECQCnN3OhSpOlT9Pq8CVXDMVNilutSbnNuO996k89Jg/zR</span><br><span class="line">s1XIN4zfEDxWLJi9N/iZ0BK7JnwtKMZ3Z+9IStWGqkg=</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><br>根据私钥创建公钥:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl rsa -<span class="keyword">in</span> private.pem -pubout -out public.pem</span></span><br><span class="line">writing RSA key</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat public.pem</span></span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDj73NhxbtD0lNJtYA5bWrMRKYh</span><br><span class="line">N07r6BYOKqsFMm9N91ZtvW/R7w87XO6WSt5uqVzBgQAHshQZNh0PNeBp8DpwIQYA</span><br><span class="line">rG9x/ZZhZnTIsD3wUpbMbp5EEF4IBgw1284IKtpvV8a7HJzNchl4//bFGkAU/flI</span><br><span class="line">P1Upl6ZkOMk6KP76wQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><br>对信息进行加密的部分过程:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl rsautl -sign -<span class="keyword">in</span> license.md5 -out license -inkey private.pem</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> base64 license</span></span><br><span class="line">hkBRNnalRvi21K+dnOvAg8W3V/ntheouUhlJelwvzzW3CMZbKw08z4TQzV4Qkx0DU7YgiUOdCNvn</span><br><span class="line">KWRdxVnj4jatqLZeMJp9BOYI3SrdzsQETzXQOV/37L+s6nA4T+EM8YfsdgoEfyt5GYezBqQW3Iii</span><br><span class="line">fppNQ4e67qSTBqpfD88=</span><br></pre></td></tr></table></figure><br>在非对称加密过程中还存在2个问题:</p><blockquote><p>1、 私钥加密无法达到保密效果，服务端响应信息无法加密。<br>  2、要求明文信息必须小于秘钥长度。</p></blockquote><p>一种容易想到的方法是让每个客户端也生成一对私钥+公钥，这样服务端使用客户端的公钥加密响应信息。这种方法的副作用是服务端需要保存所有的客户端公钥，实现成本较高，一般非金融类业务不会这样处理。对于明文信息必须小于秘钥长度，可采用明文分段方式进行加密，这种方法的副作用是效率更低。</p><p>比较好的解决上述2个问题的方法是把对称加密和非对称加密结合起来。客户端随机生成一个对称秘钥，然后使用公钥加密秘钥，服务端收到密文信息后解密得到秘钥。服务端使用秘钥对响应信息进行对称加密，客户端使用秘钥解密信息。这样就解决了服务端响应信息的加密问题。以后客户端再发送请求信息，都可以使用这个秘钥进行对称加密，同时也解决非对称加密效率低和秘钥长度的问题。流程如下:</p><p>步骤客户端服务端1生成对称秘钥-2公钥加密对称秘钥-3-私钥解密获得对称秘钥4使用对称秘钥加密请求明文-5-使用对称秘钥解密请求密文6-使用对称秘钥加密响应明文7使用对称秘钥解密响应明文-</p><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>使用对称加密+非对称加密的结合，还有秘钥伪造的安全问题。假设客户端请求A网站服务，需要先获取A网站的公钥。如果在网络传输中B网站使用自己的公钥进行伪装替换，客户端错误的把B网站的公钥当做A网站的公钥。那么客户端发送给A网站的信息就可以被B网站窃取。</p><p>解决的办法就需要使用 证书。由一个专业的安全机构，给A网站颁发一个证书。证书实际上就是把A网站的公钥使用自己的私钥包装一下。同时这个机构还会和操作系统配合，提前在操作系统中预制自己的公钥。这样通讯中获取到A站点的证书后，使用操作系统提供的安全机构公钥解密得到A站点的公钥，从而解决公钥伪造问题。以上处理方式就是https协议的安全基础。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>摘要一个应用场景是公示信息的完整性。下载网站在提供软件下载的时候，一般还会提供一个数字摘要，用来防止流氓软件捆绑。比如下面pypy软件包的摘要信息:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pypy3.9-v3.7.8 sha256:</span><br><span class="line">---------------------</span><br><span class="line">89dd0399a89a04b58c22e9b773747258807996bd5071dbf996a85bf8af432393  pypy3.9-v7.3.8rc1-linux32.tar.bz2</span><br><span class="line">f3f90203afcf7ee359e8c8a871bfaa06d96f926781fd94fb81f471dcd32f7332  pypy3.9-v7.3.8rc1-linux64.tar.bz2</span><br><span class="line">9a5d7217d8173bbdf1c7351b34651fee0596b0bcfe6fe4becae150d4a5469487  pypy3.9-v7.3.8rc1-osx64.tar.bz2</span><br><span class="line">4651d804341046be824af0ca35b7ebbbb6d5cdcef0d4a373891398dba182d010  pypy3.9-v7.3.8rc1-src.tar.bz2</span><br><span class="line">c4db62a854c2cc994d46fac0105a8e3bd4273093b9844c1f7cb69118fae6df72  pypy3.9-v7.3.8rc1-src.zip</span><br><span class="line">ad214e4a44c893dc503e7e0b6f6bdfa7523db80b9d4890523f8ee96339d05fc9  pypy3.9-v7.3.8rc1-win64.zip</span><br></pre></td></tr></table></figure></p><p>通过特定的散列算法，对 pypy3.9-v7.3.8rc1-linux32.tar.bz2 计算得到值为 89dd0399a89a04b58c22e9b773747258807996bd5071dbf996a85bf8af432393 的摘要。下载完成后比较一下摘要就知道软件包的完整性。</p><p>下面是另外一个摘要算法md5的示例:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ echo &quot;123456789&quot; | md5sum</span><br><span class="line">b2cfa4183267af678ea06c7407d4d6d8  -</span><br><span class="line">➜  ~ echo &quot;123456789&quot; | md5sum</span><br><span class="line">b2cfa4183267af678ea06c7407d4d6d8  -</span><br><span class="line">➜  ~ echo &quot;1&quot; | md5sum</span><br><span class="line">b026324c6904b2a9cb4b88d6d61c81d1  -</span><br><span class="line">➜  ~ echo &quot;123456780&quot; | md5sum</span><br><span class="line">9af763c0ffc99c565a6a9460e1a2ca7e  -</span><br></pre></td></tr></table></figure></p><p>散列函数形成的摘要都具有下面几个特点:</p><p>1、单向 只能够从tar包得到一个摘要值，从摘要值是无法还原完整的tar包<br>2、结果确定 同一个算法对每个输入的计算结果是确定<br>3、结果定长 可以看到字符串”1”和”123456789”得到的结果长度都是一样的<br>4、结果分散无规律 可以看到字符串”123456780”和”123456789”，仅仅变动了1个字符，摘要却变化非常大<br>5、效率高 工程上摘要的计算非常快速</p><p>下面是摘要算法的一些应用场景。</p><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>因为摘要算法的确定性，所以可以用来进行去重。对于数据是否变更，仅仅需要比较信息的摘要指是否变动:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if data[&quot;targets_md5&quot;] != self.route_data.get(&quot;targets_md5&quot;, None):</span><br><span class="line">    do_update()</span><br><span class="line">else:</span><br><span class="line">    log.info(&quot;update_router_info targets not changed !&quot;)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><h2 id="密码保护"><a href="#密码保护" class="headerlink" title="密码保护"></a>密码保护</h2><p>系统存储用户密码时，并不记录密码本身，仅记录密码的散列值。这样只有用户自己知道密码的明文。校验密码时，只要输入的密码正确，得到的散列值一定是一样的，表示校验通过。即使系统的数据库不小心产生泄露问题，也不会导致用户的密码泄露。<br>很多用户习惯使用同一个密码访问所有网站，比如A网站和B网站使用同一个密码，假设网站都是明文存储用户名和密码。A网站是大站点，网络安全处理比较好。但是B网站是小站点，发送了数据库泄露。这样攻击者利用盗取数据中的用户名和密码，从而拿到用户在A网站的重要信息。<br>md5算中123456789的值固定是b2cfa4183267af678ea06c7407d4d6d8，所以即使使用散列存储，也可以反向推断值为b2cfa4183267af678ea06c7407d4d6d8的密码明文是123456789。这种攻击方法一般称为 彩虹表，就是利用一些常用密码的散列值进行推测密码明文。解决这个问题的方法是 加盐 。加盐是一个通俗说法，利用散列算法的分散特性，在明文中混入一个其它数据，这样得到密文就会产生大的变化。校验的时候只要保证使用相同的盐，就可以确定明文是正确。</p><blockquote><p>明文+盐值 —&gt; 密文</p></blockquote><h2 id="接口签名"><a href="#接口签名" class="headerlink" title="接口签名"></a>接口签名</h2><p>摘要算法还可以用来做服务之间接口的安全认证。比如某个接口的参数如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appid： wxd930ea5d5a258f4f</span><br><span class="line">mch_id： <span class="number">10000100</span></span><br><span class="line">device_info： <span class="number">1000</span></span><br><span class="line">body： test</span><br><span class="line">nonce_str： ibuaiVcKdpRxkhJA</span><br></pre></td></tr></table></figure><br>对接口的参数信息进行拼接，形成一个原始的字符串:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringA=<span class="string">&quot;appid=wxd930ea5d5a258f4f&amp;body=test&amp;device_info=1000&amp;mch_id=10000100&amp;nonce_str=ibuaiVcKdpRxkhJA&quot;</span>;</span><br></pre></td></tr></table></figure><br>结合参数信息和秘钥形成一个摘要签名:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MD5签名方式：</span><br><span class="line">stringSignTemp=stringA+<span class="string">&quot;&amp;key=192006250b4c09247ec02edce69f6a2d&quot;</span> <span class="comment">//注：key为商户平台设置的密钥key</span></span><br><span class="line">sign=MD5(stringSignTemp).toUpperCase()=<span class="string">&quot;9A0A8659F005D6984697E2CA0A9CF3B7&quot;</span> <span class="comment">//注：MD5签名方式</span></span><br></pre></td></tr></table></figure><br>因为秘钥进行双方服务器存放，不进过网络传输。所以每个请求可以通过验证签名确定来源和信息的完整性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们了解了密码学的一些应用场景和解决问题的目的。目的这个很重要，可以让我们知道 加密，签名，摘要 都在保护什么。加密是保护信息的私密性，签名是保护信息来源真实性，摘要是保护信息的完整性。进而可以根据自己的需求，灵活的应用，比如创建一个自己的授权证书license。<br>下一节我会介绍一些算法的具体实现，以及如何实现一个license。</p><blockquote id="fn_密码学"><sup>密码学</sup>. 转自 <a href="https://juejin.cn/post/7064372860990521357">游戏不存在</a><a href="#reffn_密码学" title="Jump back to footnote [密码学] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安全防护&quot;&gt;&lt;a href=&quot;#安全防护&quot; class=&quot;headerlink&quot; title=&quot;安全防护&quot;&gt;&lt;/a&gt;安全防护&lt;/h2&gt;&lt;p&gt;密码学&lt;sup&gt;&lt;a href=&quot;#fn_密码学&quot; id=&quot;reffn_密码学&quot;&gt;密码学&lt;/a&gt;&lt;/sup&gt;主要的解决的问题</summary>
      
    
    
    
    
    <category term="密码学" scheme="http://yoursite.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>居酒屋hex的优化之路o</title>
    <link href="http://yoursite.com/2022/05/22/%E5%B1%85%E9%85%92%E5%B1%8B%E7%9A%84hexo%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AFo/"/>
    <id>http://yoursite.com/2022/05/22/%E5%B1%85%E9%85%92%E5%B1%8B%E7%9A%84hexo%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AFo/</id>
    <published>2022-05-22T06:15:16.000Z</published>
    <updated>2022-05-22T06:16:42.102Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Java网络编程-email详解</title>
    <link href="http://yoursite.com/2022/05/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-email%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/05/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-email%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-05-22T05:56:14.000Z</published>
    <updated>2022-05-22T05:56:14.320Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Java垃圾回收-垃圾回收机制算法</title>
    <link href="http://yoursite.com/2022/05/22/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2022/05/22/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%AE%97%E6%B3%95/</id>
    <published>2022-05-22T05:54:35.000Z</published>
    <updated>2022-05-22T06:13:23.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote><p>定义：<font color="#ad6598">当一个对象没有引用指向它</font>，这个对象就成为无用的内存（垃圾），就必须进行回收，以便用于后续其它对象的内存分配垃圾回收是<sup><a href="#fn_delect" id="reffn_delect">delect</a></sup></p></blockquote><h3 id="垃圾回收的实现算法"><a href="#垃圾回收的实现算法" class="headerlink" title="垃圾回收的实现算法"></a>垃圾回收的实现算法</h3><blockquote><p>引用计算算法<sup><a href="#fn_引用计算" id="reffn_引用计算">引用计算</a></sup></p><pre><code>- 实现简单，判断效率也很高，在大部分情况下它都是一个不错的算法。但是java语言并没有选用引用计数算法来管理内存，其中最主要的原因&lt;font color=&quot;#ad6598&quot;&gt;它很难解决对象之间相互循环引用&lt;/font&gt;的问题</code></pre><p>可达性分析算法（根搜索算法）<sup><a href="#fn_可达性分析" id="reffn_可达性分析">可达性分析</a></sup></p><pre><code>- 在java语言中，可以作为GC Roots对象的包含如下几种-- 1. 虚拟机栈帧（栈帧中的本地变量表）中引用的对象-- 2. 方法区中的类静态属性引用的对象-- 3. 方法区中的常量引用对象-- 4. 本地方法栈中JNI的引用的对象- 对象引用-强引用[^强引用]-- 只要引用存在，垃圾回收器永远不会回收-- obj对象对后面new Object有一个强引用，只有当obj这个引用被释放之后，对象才会被释放[^释放]掉- 对象引用-软引用[^软引用]-- 非必要引用，内存溢出之前进行回收，可以通过代码实现-- 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引取值，无需从繁忙的真是来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正来源查询这些数据- 对象引用-弱引用[^弱引用]-- 在第二次垃圾回收的时候在进行回收-- 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收-虚引用（幽灵/幻影引用）[^幽灵引用]-- 在垃圾回收时回收，无法通过引用取到对象值-- 虚引用主要用于检测对象是否已经从内存中删除</code></pre></blockquote><h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><blockquote><p>分代垃圾回收的提出<br>    —在java代码中，java语言没有显式的提供分配内存和删除内存方法。一些开发人员将引用对象设置为null或者调用system.gc()<sup><a href="#fn_system" id="reffn_system">system</a></sup>来释放内存<br>    — 在java中，由于开发人员没有在代码 中显式删除内存，所有垃圾回收器会去发现不需要（垃圾）的对象，然后删除它们，释放内存<br>    — 分代垃圾回收器是基于以下两个假设而创建的。<br>    — 1. 绝大多数对象在短时间内变得不可达<br>    — 2. 只有少量年老对象引用年轻对象</p><pre><code>- &lt;font color=&quot;#ad6598&quot;&gt;年轻代和老年代&lt;/font&gt;-- 年轻代：新创建的对象都存放在这里。因为大多数对象很快变得不可达，所以大多数对象在年轻代中创建，然后消失。当对象从这块内存区域消失时，我们说&lt;font color=&quot;#1ba784&quot;&gt;发生一次“minor GC”[^minorGC]&lt;/font&gt;-- 老年代：没有变的不可达，存活下来的年轻代对象被复制到这里。区域一般大于年轻代，这就意味着它有更大的规模，GC发生的次数相较于年轻代要小得多，当年轻代对象从老年代消失时，我们说&lt;font color=&quot;#1ba784&quot;&gt;“major GC”(或者“Full GC”)发生[^majorGC]&lt;/font&gt;了</code></pre></blockquote><h4 id="怎么去组织年轻代和老年代呢？"><a href="#怎么去组织年轻代和老年代呢？" class="headerlink" title="怎么去组织年轻代和老年代呢？"></a>怎么去组织年轻代和老年代呢？</h4><h5 id="年轻代组成部分"><a href="#年轻代组成部分" class="headerlink" title="年轻代组成部分"></a><font color="red">年轻代组成部分</font></h5><p>一、年轻代总共有3块空间，1块为Eden<sup><a href="#fn_Eden" id="reffn_Eden">Eden</a></sup>区,2块为Survivor<sup><a href="#fn_Survivor" id="reffn_Survivor">Survivor</a></sup>区.各个空间的执行顺序如下<br>Ⅰ、 绝大多数新创建的对象分配在Eden<br>Ⅱ、 在Eden区发生一次GC，存活的对象移到其中一个Survivor区<br>Ⅲ、 一旦一个Survivor区已满，存活的对象移动到你另外一个Survivor区，然后之前那个空间已满Survivior将置为空，没有任何数据<br>Ⅳ、经过重复多次这样的步骤后依旧存活的对象将被转移到老年区</p><h3 id="垃圾回收经典性算法"><a href="#垃圾回收经典性算法" class="headerlink" title="垃圾回收经典性算法"></a>垃圾回收经典性算法</h3><h4 id="Mark-Sweep（标记清除）算法"><a href="#Mark-Sweep（标记清除）算法" class="headerlink" title="Mark-Sweep（标记清除）算法"></a>Mark-Sweep（标记清除）算法</h4><p><img src="/img/Mark-Sweep.png"></img></p><ol><li><p>这是最基础的垃圾回收算法，之所以说它是最基础<font color="red">它最容易实现</font>，思想也是最简单的，标记清除算法分为两个阶段：标记阶段和清楚阶段。标记阶段的任务是标记出所需要被回收的对象，清除阶段就是回收被标记的对象所占用的的空间</p></li><li><p>从图中可以很容易的看出标记-清楚算法的实现起来比较容易，但是有一个比较严重的问题就是<font color="red">容易产生内存碎片</font>，碎片太多可能导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发一次新的垃圾回收动作。</p></li></ol><h4 id="Copying-复制-算法"><a href="#Copying-复制-算法" class="headerlink" title="Copying(复制)算法"></a>Copying(复制)算法</h4><p><img src="/img/Copying.png"></img></p><ol><li><p>为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来，它可以将可用内存按容量划分大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。</p></li><li><p>这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</p></li><li><p>很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。</p></li></ol><h4 id="Mark-Compact-标记-整理-算法"><a href="#Mark-Compact-标记-整理-算法" class="headerlink" title="Mark-Compact(标记-整理)算法"></a>Mark-Compact(标记-整理)算法</h4><p><img src="/img/Mark-Compact.png"></p><ol><li>为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它并不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</li></ol><h4 id="Generational-Collection-分代收集-算法"><a href="#Generational-Collection-分代收集-算法" class="headerlink" title="Generational Collection(分代收集)算法"></a>Generational Collection(分代收集)算法</h4><ol><li><p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。他的核心思想是根据<font color="red">对象存活的生命周期将内存划分为若干个不同的区域</font>一般情况将堆区划分为老年代（Tenured Generation）和新生代（Young Generation）,老年代的特点是<font color="red">每次垃圾收集时只有少量的对象需要被回收</font> ，而新生代的特点是&lt;font color=red”&gt;每次垃圾回收都有大量对象需要被回收&lt;/font&gt;，那么就可以给根据不同代的特点采取更适合的算法</p></li><li><p>目前大部分垃圾收集器对于新生代都采用Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说<font color="red">需要复制的操作次数较少</font>，但是实际上并不是按照1：1的比例来划分新生代的空间的，一般来说将新生代划分为一块较的Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清除原Eden和Survivor空间</p></li><li><p>由于老年代的特点是每次回收都只回收少量对象，一般使用Mark-Compact算法</p></li></ol><p>注意，在堆区之外还有一个代就是<font color="red">永久代(Permanent Generation)</font>，它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量<sup><a href="#fn_废弃常量" id="reffn_废弃常量">废弃常量</a></sup>和无用的类<sup><a href="#fn_无用的类" id="reffn_无用的类">无用的类</a></sup>。</p><blockquote id="fn_方法区"><sup>方法区</sup>. java虚拟机当中的内存的某一个区域<a href="#reffn_方法区" title="Jump back to footnote [方法区] in the text."> &#8617;</a></blockquote><blockquote id="fn_ConstantValue"><sup>ConstantValue</sup>. 是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性,在实际情况下只有同时又static和final才会具有ConstantValue这个属性, [<a href="https://blog.csdn.net/honjane/article/details/51835636">参考blog—&gt;楼阁猫</a>]<a href="#reffn_ConstantValue" title="Jump back to footnote [ConstantValue] in the text."> &#8617;</a></blockquote><blockquote id="fn_例如"><sup>例如</sup>. 例如—-&gt; public static final int value = 122;<a href="#reffn_例如" title="Jump back to footnote [例如] in the text."> &#8617;</a></blockquote><blockquote id="fn_应用类"><sup>应用类</sup>. ClassA[] arr =new ClassA()<a href="#reffn_应用类" title="Jump back to footnote [应用类] in the text."> &#8617;</a></blockquote><blockquote id="fn_delect"><sup>delect</sup>. 优先级为：系统级线程<a href="#reffn_delect" title="Jump back to footnote [delect] in the text."> &#8617;</a></blockquote><blockquote id="fn_引用计算"><sup>引用计算</sup>. 它实际上是通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数加一，如果删除对该对象的引用，那么它的引用计数就减一，当该对象的引用计数为0时，那么该对象就会被回收。[<a href="https://www.jianshu.com/p/1d5fa7f6035c">参考blog —&gt;可文分身</a>]<a href="#reffn_引用计算" title="Jump back to footnote [引用计算] in the text."> &#8617;</a></blockquote><blockquote id="fn_可达性分析"><sup>可达性分析</sup>. null_暂时没写<a href="#reffn_可达性分析" title="Jump back to footnote [可达性分析] in the text."> &#8617;</a></blockquote><blockquote id="fn_强引用"><sup>强引用</sup>. Object obj =new Object()<a href="#reffn_强引用" title="Jump back to footnote [强引用] in the text."> &#8617;</a></blockquote><blockquote id="fn_释放"><sup>释放</sup>. 把这个对象设置为null<a href="#reffn_释放" title="Jump back to footnote [释放] in the text."> &#8617;</a></blockquote><blockquote id="fn_软引用"><sup>软引用</sup>. Object obj =new Object() —&gt; SoftReference<object> sf = new SoftReference<object>(obj) —&gt; obj=aaull  —&gt; sf.get()<a href="#reffn_软引用" title="Jump back to footnote [软引用] in the text."> &#8617;</a></blockquote><blockquote id="fn_弱引用"><sup>弱引用</sup>. Object obj = new Object() —&gt; WeakReference<Object> wf = new WeakRerence<Object>(obj) —&gt; obj = null —&gt; wf.get() //有时候返回null —&gt; wf.isEnQueued()<a href="#reffn_弱引用" title="Jump back to footnote [弱引用] in the text."> &#8617;</a></blockquote><blockquote id="fn_幽灵引用"><sup>幽灵引用</sup>. 主要是这一句有所改动 —&gt; PhantomReference<object> pf = new PhantomReference<object>(obj) —&gt; pf.get()  //永远返回 null<a href="#reffn_幽灵引用" title="Jump back to footnote [幽灵引用] in the text."> &#8617;</a></blockquote><p><sup><a href="#fn_无用的类" id="reffn_无用的类">无用的类</a></sup>:1、该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。2、加载该类的 ClassLoader 已经被回收。 3、该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;垃圾回收&quot;&gt;&lt;a href=&quot;#垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收&quot;&gt;&lt;/a&gt;垃圾回收&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;定义：&lt;font color=&quot;#ad6598&quot;&gt;当一个对象没有引用指向它&lt;/font&gt;，这个对象</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java虚拟机-生命周期</title>
    <link href="http://yoursite.com/2022/05/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2022/05/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-05-22T05:54:06.000Z</published>
    <updated>2022-05-22T06:12:29.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h1><p> java虚拟机是一个想象的中的机器，在实际的计算机上通过软件模拟实现，java虚拟机有自己想象的一切</p><h2 id="为什么使用java虚拟机"><a href="#为什么使用java虚拟机" class="headerlink" title="为什么使用java虚拟机"></a>为什么使用java虚拟机</h2><p> 实现java的跨平台特性<br> 把目标代码编译成字节码</p><h3 id="java-虚拟机的生命周期"><a href="#java-虚拟机的生命周期" class="headerlink" title="java 虚拟机的生命周期"></a>java 虚拟机的生命周期</h3><ol><li>一个运行中的java机有一个清晰的任务：执行java程序。程序开始执行时他才运行，程序结束它将一起停止，每个java程序会单独运行一个Java 虚拟机<br>通过命令行启动Java虚拟机: java xxx(类名)<br>java虚拟机总是开始于一个main方法，这个方法必须公有public，返回void,直接接收一个字符串数组，在程序执行时，必须给java虚拟机指明这个包含main方法的类名<br>如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br></pre></td></tr></table></figure><blockquote><ol><li>main方法是程序的起点，它被执行的线程初始化为程序的初始线程。程序中其它线程都有它他来启动，java的线程分为两种:守护线程（daemon）和普通线程（non-daemon）.守护线程是java虚拟机自己使用的线程，比如负责垃圾收集的线程，也可以把自己的程序设置为守护线程。包含main方法的初始线程不是守护线程</li><li>只要java虚拟机中还有普通线程在执行，java虚拟机就不会停止运行，如果有足够的权限，就可以调用exit方法终止程序</li></ol></blockquote><h3 id="java虚拟机的体系结构"><a href="#java虚拟机的体系结构" class="headerlink" title="java虚拟机的体系结构"></a>java虚拟机的体系结构</h3><blockquote><ol><li>在java虚拟机中规范中定义了一系列的子系统、内存区域、数据类型和使用指南。这些组件构成了了java虚拟机的内部结构，他们不仅仅为java虚拟机的实现提供了清晰的内部结构，更加严格规范了java虚拟实现的外部行为</li><li>每一个java虚拟机都有一个类加载器子系统（class loader subsystem），负责加载程序中的类型（类class和接口interface），并赋予唯一的名字。每一个java虚拟机都有一个执行引擎（execution engine）负责执行被加载类中包含的指令。</li></ol></blockquote><h3 id="java虚拟机中使用的数据类型"><a href="#java虚拟机中使用的数据类型" class="headerlink" title="java虚拟机中使用的数据类型"></a>java虚拟机中使用的数据类型</h3><blockquote><ol><li>所有java虚拟机中使用的数据都有明确的数据类型，数据类型和操作都在java虚拟机规定中严格定义。java中的数据类型分为：<font color=#7E7129>原始数据类型（primitive types）</font>和：<font color=#7E7129>引用数据类型(reference type)</font></li><li>在java虚拟机还存在一个java语言中不能使用的的原始数据类型——<font color="red">返回值类型（return）</font>。这种类型被用来实现java程序中的“finally lasses”</li><li>引用类型可能被创建为：类类型（class type） ,接口类型（interface type）,数组类型（array type)。他们都引用被动态创建对象。当引用类型引用null时，说明没有引用任何对象。</li></ol></blockquote><h2 id="虚拟机类加载机制概念"><a href="#虚拟机类加载机制概念" class="headerlink" title="虚拟机类加载机制概念"></a>虚拟机类加载机制概念</h2><h3 id="问题-字节码文件如何被加载到虚拟机的？"><a href="#问题-字节码文件如何被加载到虚拟机的？" class="headerlink" title="问题 字节码文件如何被加载到虚拟机的？"></a>问题 字节码文件如何被加载到虚拟机的？</h3><blockquote><p>虚拟机把描述类的数据从class文件加载到内存中，并对数据进行校验、转换解析和初始化，并最终形成可以被虚拟机直接是使用的java类型<br>java语言里，类的加载和连接过程是在程序运行过程中完成的  —-&gt;保证流畅性和完成性</p></blockquote><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><blockquote><ol><li>加载 loading<ul><li>通过一个类的全限名来获取此类的二进制字节码</li><li>将这个字节码所代表的静态存储结构转化为<sup><a href="#fn_方法区" id="reffn_方法区">方法区</a></sup>的运行时数据结构</li></ul></li><li>验证 verification<ul><li>虚拟机规范：验证输入的字节流<font color="red">是否符合class文件的存储格式</font>，否则抛出一个<font color="red">java.lang.VerifyError</font>异常</li><li>文件格式的验证：<font color="red">验证字节流是否符合class文件格式的规范</font>，并且能被当前版本的虚拟机处理。经过这个阶段的验证，字节流进入内存的方法区中进行存储。</li><li>元数据验证：对<font color="red">类的元数据信息进行语义验证</font>，保证不存在不符合java语言规范的元数据信息。</li><li>字节码验证：进行<font color="red">数据流和控制流分析，对类的方法体进行校验分析</font>，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li><li>符号引用验证:发生在虚拟机<font color="red">将符号引用转化为直接引用的时候（解析阶段）</font>，对常量池中的各种符号引用的信息进行匹配性的校验。</li></ul></li><li>准备 preparation<ul><li>准备阶段是正式为 类变量 分配内存并设置 类变量 初始值（各数值类型的零值）的阶段，这些内存将在方法区中进行分配，但是如果类字段的字段属性表中存在ConstantValue属性，那再准备阶段变量值就会初始化为ConstantValue<sup><a href="#fn_ConstantValue" id="reffn_ConstantValue">ConstantValue</a></sup>属性指定的值<sup><a href="#fn_例如" id="reffn_例如">例如</a></sup></li></ul></li><li>解析 resolution<ul><li>解析阶段是在虚拟机将常量池内的符号引用替换为直接引用的过程</li><li>符号引用：符号引用以一组符号来描述所引用的目，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标<font color="red">并不一定已经加载到内存中</font></li><li>直接引用:直接引用可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。如果有了直接引用，那<font color="red">引用的目标必定已经在内存中存在</font></li></ul></li><li>初始化 initialization<ul><li><clinit>()方法：由编译器自动收集类中所有变量的赋值动作和静态语句块中语句合并产生，收集的顺序是由语句在源文件中出现的顺序决定的。</li><li>该方法与实例构造器不同<init>()不同，不需要显示的调用父类构造器。</li><li><clinit>()方法对于类或接口来不是必须的。</li><li>执行接口的<clinit>()不需要先执行父接口的<clinit>()方法</li><li>虚拟机会保证一个类的<clintt>()方法在<font color="red">多线程环境中被正确的加载和同步</font></li></ul></li><li>使用 using<br> -<font color="#ad6598">类的主要引用：</font><br> —遇到NEW、GETSTATIC、PUTSTATIC、INVOKEESTATIC这四条字节码指令时（使用new实例化对象的时候、读取或设置一个类的静态字段、调用一个类的静态方法）<br> — 使用java.long.reflet包的方法对类进行反射调用的时候<br> — 当初始化一个类的时候，如果发现其父类没有进行初始化，则需要先触发其父类的初始化<br> — 当虚拟机启动时，虚拟机会初始化主类（包含main方法的那个类）<br> -<font color="#ad6598">类的被动引用：</font><br> — 通过子类引用父类的静态字段，不会导致子类初始化（对于静态字段，只有直接定义这个字段的类才会被初始化）<br> — 通过数组来定义类应用类<sup><a href="#fn_应用类" id="reffn_应用类">应用类</a></sup>:触发了一个名为LClassA的类的初始化，它是一个由虚拟机自动生成的、直接继承于Object的类，创建动作由字节码指令newarray触发<br> — 常量会在编译阶段存入调用类的常量池</li></ol></blockquote><p>卸载 unloading</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java虚拟机&quot;&gt;&lt;a href=&quot;#java虚拟机&quot; class=&quot;headerlink&quot; title=&quot;java虚拟机&quot;&gt;&lt;/a&gt;java虚拟机&lt;/h1&gt;&lt;p&gt; java虚拟机是一个想象的中的机器，在实际的计算机上通过软件模拟实现，java虚拟机有自己想象的一</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java网络编程-socket</title>
    <link href="http://yoursite.com/2022/05/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/"/>
    <id>http://yoursite.com/2022/05/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/</id>
    <published>2022-05-22T05:53:29.000Z</published>
    <updated>2022-05-22T06:12:04.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URl对象"><a href="#URl对象" class="headerlink" title="URl对象"></a>URl对象</h2><p> ipv4地址（32位，4字节）<br> ipv6地址（128位，16字节）<br> 主机名<br> 端口号 80，21，23，25-1024为保留端口<br> 服务类型 server</p><p>URL类（Uniform Resource Locator） 一致资源定位器的简称，它表示Internet上某一资源的地址<br> URL的组成 Protocol:resourceNam 协议名指的是获取资源所使用的传输协议，如http\ftp\file\等<br>  例如：public URL(String protocol,String host,String file)<br>TCP（Transport Control Protoco!）<br> 面向连接提供可靠的流式数据传输协议<br> URL、URLConnection、Socket、ServerSolet等都可以进行协议网络通信<br>  网络上的两个程序通过双向连接</p><p> Socket（）<br> Socket（InetAddress address,int port）远程目标地址 ，端口号<br> Socket（String host,int prot） 连接主机名，端口号<br> Socket（InetAddress host,int port,InetAddress localAddr,int localPort）<br> Socket(String host,int port,InetAddress localAddr,int localPort）</p><p>思考：<br> java中socket如何实现多客户机制的实现<br> 数据报是如何通信的<br> 广播是如何实现的？<br> 如何实现一个带界面的简单聊天程序？</p><p>TC有建立时间<br>UDP传输有大小限制：64kb内<br>TCP的应用：Telnet,Ftp<br>UDP的应用：ping<br>数据报的方法-&gt;&gt;<br> DatagramSocket()<br> DatagramSocket(int prot)<br> DatagramPacket(byte ibuf[],int ilength) / 接受<br> DatagramPacket(byte ibuf[],int ilength，InetAddress iaddr ,int iport) / 发送</p><p>收<br>DatagramPacket packet = new DatagramPacket(buf,260);<br>socket.receice(packet)</p><p>发<br>DatagramPacket packet = new Datapramcket(buf,buf.length,address,port);<br>socket.send(packet)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;URl对象&quot;&gt;&lt;a href=&quot;#URl对象&quot; class=&quot;headerlink&quot; title=&quot;URl对象&quot;&gt;&lt;/a&gt;URl对象&lt;/h2&gt;&lt;p&gt; ipv4地址（32位，4字节）&lt;br&gt; ipv6地址（128位，16字节）&lt;br&gt; 主机名&lt;br&gt; 端口号 80，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java线程-面试题合集</title>
    <link href="http://yoursite.com/2022/05/22/Java%E7%BA%BF%E7%A8%8B-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2022/05/22/Java%E7%BA%BF%E7%A8%8B-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</id>
    <published>2022-05-22T05:52:42.000Z</published>
    <updated>2022-05-22T05:52:42.942Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Java-线程</title>
    <link href="http://yoursite.com/2022/05/22/Java-%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2022/05/22/Java-%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-05-22T05:52:10.000Z</published>
    <updated>2022-05-22T06:10:48.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java-线程"><a href="#java-线程" class="headerlink" title="java 线程"></a>java 线程</h2><p>现成的实现和继承两者方式<br>第一种方式 继承thread类 启动线程则是start方法<br>例子<br>测试类 —&gt;&gt;<br> publi class FactorialThreadTester{<br> public static void main (String[] args)<br> {<br>  System.out.println(“main thread starts”);<br>  FactorialThread thread=new FactorialThrea(10);<br>              thread().start() //自动进入rua()方法<br>              System.out.println(“main thread ends”);</p><p> }<br> }</p><p>主代码类 —&gt;&gt;<br>public class FactorialThread extends Thread{<br>    private int num;<br>    public FactorialThread(int num){<br>        this.num=num;<br>    }</p><pre><code>/** * If this thread was constructed using a separate * &lt;code&gt;Runnable&lt;/code&gt; run object, then that * &lt;code&gt;Runnable&lt;/code&gt; object&#39;s &lt;code&gt;run&lt;/code&gt; method is called; * otherwise, this method does nothing and returns. * &lt;p&gt; * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method. * */@Overridepublic void run() &#123;</code></pre><p>//        实现阶乘计算<br>        int i=num;<br>        int result=1;<br>        System.out.println (“new thread started”);<br>        while(i&gt;0){<br>            result=result*i;<br>            i=i-1;<br>        }<br>        System.out.println (“Thread factorial of\t”+num+”\tis\t”+result);<br>        System.out.println (“new thread ends”);<br>    }<br>}</p><p>Thread详解<br>常用api接口<br> public Thread() 构造方法<br> public Thread(Runnable target) 构造新的线程对象<br> public Thread(String name) 构造一个新的线程对象，并同时指定线程名<br> public static Thread currentThread() 返回当前正在运行的线程对象<br> public static void yield() 使当前线程对象暂停，运行别的线程开始<br> public static void sleep(long millis)  使当前线程暂停运行指定毫秒数，但此线程并不会失去已经获得的锁<br> public void start() 启动线程 同时运行两个线程（当前线程以及run()）但是并不是执行线程执行线程去决定于线程调度器<br> public void run() thread的子类应该重写此方法，内容为需要执行的任务代码<br> public void stop() 停止线程运行，释放该线程占用的对象锁<br> public vodi interrupt() 中断此线程<br> public final void jojn() 如果此前启动了线程a，调用jojn方法将等待线程a死亡才能继续执行当前线程<br> public final void jojn(long millis) 如果此前启动了线程a，调用jojn方法将等待指定毫秒数或线程a死亡才能继续执行当前线程<br> public final setPriority(int newPriority) 设置线程优先级<br> public final void set Daemon(Boolean on) 设置是否为后台进程，如果当前运行线程均为后台线程则jvm停止运行。这个方法必须在start（）方法前使用<br> public final void checkAccess() 判断当前线程是否有权力修改调<br>用此方法的线程<br> public void setName(String name) 更改本线程的名称指定参数<br> public final boolean isAlive() 测试线程是否处于活动状态下，如果线程被启动并且没有死亡则返回true</p><p>使用Runnable创建线程</p><p>测试  —&gt;&gt;<br>public class FactorialThreadTester {<br>    public static void main(String[] args) {<br>        System.out.println (“main thread starts”);<br>        FactorialThread thread = new FactorialThread (10);  //实现了Runnable的类<br>        new Thread (thread).start (); //运行FactorialThread的run<br>        String name = new Thread (thread).getName ();<br>        System.out.println (name);<br>        System.out.println (“new thread started,main thread ends”);</p><pre><code>&#125;</code></pre><p>}</p><p>主代码类  —&gt;&gt;<br>public class FactorialThread  implements Runnable{<br>    private int num;</p><pre><code>public FactorialThread(int num) &#123;    this.num = num;&#125;/** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object&#39;s * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see Thread#run() */@Overridepublic void run() &#123;    int i = num;    int result =1;    while(i&gt;0)&#123;        result=result*i;        i=i-1;    &#125;    System.out.println (&quot;The factorial of \t&quot;+num+&quot;\tis\t&quot;+result);    System.out.println (&quot;new thread ends&quot;);&#125;</code></pre><p>}</p><p> 两种线程构造方式的比较<br>使用runnable接口<br> 可以将cpu,代码和数据分离开，形成清晰的数据模型，还可以从其它类继承<br>直接继承thread类<br> 编写简单，直接继承，重写run方法，不能再从其他类继承</p><p>线程数据共享<br> 同一实现Runnable接口对象作为参数创建多个线程<br> 多个线程共享同一对象中的相同数据<br>例子 —&gt;&gt;<br>thread1going to sleep for344<br>thread2going to sleep for344<br>thread3going to sleep for344<br>  备注：应为是runnable实现的线程主体，所以这三个线程就共享了这个对象的私有成员sleepTime，所以都会休眠344毫秒</p><p>一、线程的锁机制<br> 生产者/消费者问题—-&gt;锁机制中经典问题<br>  存票线程结束了，而售票线程经过休眠1秒过后又被线程控制器唤醒，而这时由于存票线程已经结束了就不存在将t.available设置为true就会导致这个线程进入无解循环<br>二、线程的优先级<br>三、多线程的同步控制</p><p> 有时候线程之间彼此不独立，需要”同步”<br>  线程之间的”互斥” （同时运行几个线程需要共享数据 ，共享数据时在某一时刻只允许一个线程访问该共享数据，因此有些方法或程序段在同一时刻只能被一个线程执行，称为监视区）<br>  线程之间的“协作”（多个线程可以在有条件地同时操作共享数据。执行监视区代码的线程在条件满足地情况下可以允许其他线程进入监视区）<br>          线程同步关键字 —&gt;&gt; synchronized 实现互斥<br>  用于指定需要同步地代码段或者方法，也就是监视区<br>  可实现与一个锁的交互。例如<br>   synchronized(对象){代码段}<br>  synchronized：首先判断对象锁是否存在，如果存在则先获取锁，然后就可以执行紧随其后的代码段；如果对象锁不在（已被其他线程拿走），就进入的等待阶段，直至获取锁<br>  synchronized：限定代码执行完成，就会释放所获得锁<br> 注：线程休眠不会释放锁 线程可以获得多个锁 线程损害并发性 说明获取那个对象的锁</p><p>线程的等待 —&gt;&gt;wait<br> 为了更加有效协同不同线程的工作，需要在线程间建立沟通渠道，通过线程间的“对话“，来解同步问题<br> wait来源于-&gt;(java.lang.Ogject) 该线程执行暂停进入等待池，并释放以获得的锁，等待其他线程唤醒</p><p>后台线程<br> 也叫守护线程，通常是为了辅助其它线程而运行的线程<br> 它不妨碍程序终止<br> 一个进程只要还有一个前台线程在运行，这个进程就不会结束；如果一个进程中的所有前台线程都已经结束，那么无论是否还有未结束的后台线程，这个进程都会结束<br> “垃圾回收”便是一个后台线程<br> 如果对某个线程对象在启动（调用start方法）之前调用了setDaemon(true),这个线程自然就成为后台线程</p><p>线程的生命周期<br> 线程从产生到消亡的过程<br> 一个线程在任何时刻都处于不同的状态<br>  诞生状态（刚被创建）-&gt;救赎状态（star已经被执行）-&gt;运行状态-&gt;阻塞状态-&gt;休眠状态-&gt;死亡状态<br> 死锁状态： 线程在运行过程中，其中某一个步骤往往需要满足一些条件才能继续进行下去，如果这个条件不满足，线程将在这个步骤阻塞</p><p>线程的调度<br> 在单cpu的系统中，多个线程需要共享cpu，在任何时间点上实际上只能有一个线程在执行<br> 控制多个线程在统一cpu上以某种规则顺序运行称为线程调度<br> java虚拟机支持一种非常简单，确定的调度算法，叫做固定优先级算法，这个算法基于线程的优先级对其进行调度</p><p>那什么是优先级呢？<br> 每个线程都有一个优先级，其范围都在1和10之间。默认情况下，每个线程的优先级都设置为5（即创建未作任何更改的情况下都为这个）<br> 在线程a运行过程中创建的新的线程对象b，初始状态具有和线程a相同的优先级<br> 如果a是后台线程，则b亦是后台线程<br> 可在线程创建之后的任何时候，通过setPriority(int priority)方法改变其原来的优先级</p><p>固定优先级算法 —&gt;&gt; 基于线程优先级的线程调度<br> 具有较高优先级的线程比优先级较低的线程优先执行<br> 对具有相同优先级的线程，java的处理时随机的<br> 底层操作系统支持的优先级可能会少于10个，这样会造成一些混乱，因此，只能将优先级作为一种很粗略的工具使用，最后控制可以通过yield()来完成<br>  yield() —&gt;&gt; 可以将本线程线程让出cpu资源，让给同等级优先级线程执行，如果同等级优先级只有它一个依旧是它本身执行</p><p>结论：</p><p>线程安全与线程兼容与对立<br> 线程安全的定义<br>  线程安全：当多个线程访问同一对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 —-From Brian Goetz《Java Concurrency ln Practice》<br> Java线程安全<br>  不可变、绝对线程安全、相对线程安全、线程兼容和对立<br>不可变  final修饰过的、string、枚举类型、Number的子类、Biginteger,BigDecimal(数值类型的高精度实现)<br>绝对线程安全：满足Brian Goetz在《Java Concurrency ln Practice》中定义的线程为绝对线程安全、java API中标注自己是线程安全的类绝大部分不是绝对线程安全的<br>相对线程安全：通常意义上的线程安全，需要保证这个对象单独操作是线程安全的，调用的时候不需要做额外的保证措施，但是对于一些特定顺序的连续调用，就需要在调用时使用同步手段保证调用的正确性<br>线程兼容：对象本身不是线程安全的，但是可以通过在调用端正常地使用同步手段来保证线程对象在并发环境下可以安全使用<br>线程对立：无论 调用端是否采用了同步措施，都无法在多线程环境中并发使用代码</p><p>线程是安全实现： 互斥同步、非阻塞同步、无同步方案</p><p>同步地实现方式：<br>临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphone）<br> synchronized关键字：经过编译后，会在同步块前后形成monitorenter和monitorexit两个字节码<br>  —synchronized 同步块对自己是可以重入的，不会将自己锁死<br>  —同步块在已进入的线程执行完之前，会阻塞后面其他线程进入<br>重入锁ReentrantLock (java.util.concurrent)<br>相比采用synchronized ，重入锁可实现，等待可中断，公平锁、锁可以绑定多个线程<br>synchronized 表现为原生语法层面上的互斥锁，而ReentrantLock 表现为api层面的互斥锁</p><p>非阻塞同步实现方案：<br> 阻塞同步:互斥同步存在的问题是进行线程阻塞和唤醒所带来的性能问题，这种同步被称为阻塞同步（Blocking Synchronization）这是一种悲观并发策略<br> 非阻塞同步：不同于悲观并发策略，而是使用基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程征用共享数据，则操作成功，否则就是发生冲突，采取不断重试直到成功为止的策略，这种策略不需要把线程挂起，称为非阻塞同步<br>使用硬件处理器指令进行不断重测策略（jdk1.5）<br> 测试并设置（Test-and-Set）、获取并增加(Fetch-and-Increment)、交换(Swap)、比较并交换（Compare-and-Swap，简称CAS）、加载链接，条件存储（Load-Linked,Store-conditional,简称LL,SC<br> 例如：java实现类AtomicInteger,AtomicDouble等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;java-线程&quot;&gt;&lt;a href=&quot;#java-线程&quot; class=&quot;headerlink&quot; title=&quot;java 线程&quot;&gt;&lt;/a&gt;java 线程&lt;/h2&gt;&lt;p&gt;现成的实现和继承两者方式&lt;br&gt;第一种方式 继承thread类 启动线程则是start方法&lt;br&gt;例</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Meven使用管理本地依赖</title>
    <link href="http://yoursite.com/2022/05/22/Meven%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96/"/>
    <id>http://yoursite.com/2022/05/22/Meven%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96/</id>
    <published>2022-05-22T05:51:08.000Z</published>
    <updated>2022-05-22T06:14:23.796Z</updated>
    
    <content type="html"><![CDATA[<p>mvn install:install-file -Dfile=jar包的位置 -DgroupId=一般是公司名倒序 -DartifactId=唯一型ID -Dversion=版本号 -Dpackaging=jar</p><p>例如：添加fastdfs的jar包<br>1，在jar包所在文件夹，点击鼠标右键-在此处打开命令窗口<br>2，输入命令<br>mvn install:install-file -Dfile=fastdfs_client_v1.20.jar -DgroupId=com.hueason -DartifactId=fastdfs_client -Dversion=1.20 -Dpackaging=jar<br>3，回车，看到install success<br>然后就可以在项目pom文件中引入<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hueason<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs_client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>1、添加本地jar包到maven中   —&gt; commons-dbutils<br>mvn install:install-file -Dfile=commons-dbutils-1.7.jar -DgroupId=site.xinchen -DartifactId=commons-dbutils -Dversion=1.7 -Dpackaging=jar</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;mvn install:install-file -Dfile=jar包的位置 -DgroupId=一般是公司名倒序 -DartifactId=唯一型ID -Dversion=版本号 -Dpackaging=jar&lt;/p&gt;
&lt;p&gt;例如：添加fastdfs的jar包&lt;br&gt;1</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分布式框架-kafka</title>
    <link href="http://yoursite.com/2022/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6-kafka/"/>
    <id>http://yoursite.com/2022/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6-kafka/</id>
    <published>2022-05-22T05:49:50.000Z</published>
    <updated>2022-05-22T06:09:19.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kafka知识总结"><a href="#Kafka知识总结" class="headerlink" title="Kafka知识总结"></a><strong>Kafka知识总结</strong></h1><h2 id="一、讲讲acks参数对消息持久化的影响"><a href="#一、讲讲acks参数对消息持久化的影响" class="headerlink" title="一、讲讲acks参数对消息持久化的影响"></a><strong>一、讲讲acks参数对消息持久化的影响</strong></h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h3><ol><li>写在前面</li><li>如何保证宕机时数据不丢失？</li><li>多副本之间数据如何同步？</li><li>ISR到底指的是什么东西？</li><li>acks参数的含义？</li><li>最后的思考</li></ol><h3 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1.写在前面"></a><strong>1.写在前面</strong></h3><p>面试大厂时，一旦简历上写了Kafka，几乎必然会被问到一个问题：说说acks参数对消息持久化的影响？</p><p>这个acks参数在kafka的使用中，是非常核心以及关键的一个参数，决定了很多东西。</p><p>所以无论是为了面试还是实际项目使用，大家都值得看一下这篇文章对Kafka的acks参数的分析，以及背后的原理。</p><h3 id="2-如何保证宕机的时候数据不丢失？（或者kafka如何保证高可用、或者Kafka如何保证高可用）"><a href="#2-如何保证宕机的时候数据不丢失？（或者kafka如何保证高可用、或者Kafka如何保证高可用）" class="headerlink" title="2.如何保证宕机的时候数据不丢失？（或者kafka如何保证高可用、或者Kafka如何保证高可用）"></a><strong>2.如何保证宕机的时候数据不丢失？（或者kafka如何保证高可用、或者Kafka如何保证高可用）</strong></h3><ul><li><p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p></li><li><p>而且Kafka还提供replica<strong>副本机制</strong>，每个partition的数据都会同步到其他机器上，形成自己的多个replica副本。所有replica会选举出来一个leader出来，那么<strong>生产和消费都跟这个leader打交道</strong>，然后其他replica就是follower。写的时候，leader会负责把数据同步到所有follower上去，读的时候就直接读leader上的数据即可。</p></li></ul><p>如果某个broker宕机了，那个broker上的partition在其他机器上都有副本。如果这个宕机的broker上面有某个partition的leader，那么从follower中重新选举一个新的leader出来，然后继续读写新的leader即可，这就是所谓的高可用。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/1.jpg" alt=""></p><h3 id="3-多副本之间数据如何保证同步"><a href="#3-多副本之间数据如何保证同步" class="headerlink" title="3.多副本之间数据如何保证同步"></a>3.<strong>多副本之间数据如何保证同步</strong></h3><p>其实任何一个Partition，只有Leader是对外提供读写服务的，也就是说，如果有一个客户端往一个Partition写入数据，此时一般就是写入这个Partition的Leader副本。</p><p>然后Leader副本接收到数据之后，Follower副本会不停的给他发送请求尝试去拉取最新的数据，拉取到自己本地后，写入磁盘中。如下图所示：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/2.jpg" alt=""></p><h3 id="4-ISR到底指的是什么东西？"><a href="#4-ISR到底指的是什么东西？" class="headerlink" title="4.ISR到底指的是什么东西？"></a><strong>4.ISR到底指的是什么东西？</strong></h3><p>ISR全称是“In-Sync Replicas”，也就是<strong>保持同步的副本</strong>，他的含义就是，跟Leader始终保持同步的Follower有哪些。</p><p>大家可以想一下 ，如果说某个Follower所在的Broker因为JVM FullGC之类的问题，导致自己卡顿了，无法及时从Leader拉取同步数据，那么是不是会导致Follower的数据比Leader要落后很多？</p><p>所以这个时候，就意味着Follower已经跟Leader不再处于同步的关系了。但是只要Follower一直及时从Leader同步数据，就可以保证他们是处于同步的关系的。</p><p>所以每个Partition都有一个ISR，这个ISR里一定会有Leader自己，因为Leader肯定数据是最新的，然后就是那些跟Leader保持同步的Follower，也会在ISR里。</p><h3 id="5-acks参数的含义"><a href="#5-acks参数的含义" class="headerlink" title="5.acks参数的含义"></a><strong>5.acks参数的含义</strong></h3><p>首先这个acks参数，是在KafkaProducer，也就是生产者客户端里设置的</p><p>也就是说，你往kafka写数据的时候，就可以来设置这个acks参数。然后这个参数实际上有三种常见的值可以设置，分别是：<strong>0、1 和 all</strong>。</p><p><strong>第一种选择是把acks参数设置为0</strong>，意思就是我的KafkaProducer在客户端，只要把消息发送出去，不管那条数据有没有在哪怕Partition Leader上落到磁盘，我就不管他了，直接就认为这个消息发送成功了。</p><p>如果你采用这种设置的话，那么你必须注意的一点是，可能你发送出去的消息还在半路。结果呢，Partition Leader所在Broker就直接挂了，然后结果你的客户端还认为消息发送成功了，此时就会<strong>导致这条消息就丢失了</strong>。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/3.jpg" alt=""></p><p><strong>第二种选择是设置 acks = 1</strong>，意思就是说只要Partition Leader接收到消息而且写入本地磁盘了，就认为成功了，不管他其他的Follower有没有同步过去这条消息了。</p><p>这种设置其实是<strong>kafka默认的设置</strong></p><p>也就是说，默认情况下，你要是不管acks这个参数，只要Partition Leader写成功就算成功。</p><p>但是这里有一个问题，万一Partition Leader刚刚接收到消息，Follower还没来得及同步过去，结果Leader所在的broker宕机了，此时也会导致这条消息丢失，因为人家客户端已经认为发送成功了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/4.jpg" alt=""></p><p><strong>最后一种情况，就是设置acks=all</strong>，这个意思就是说，<strong>Partition Leader接收到消息之后，还必须要求ISR列表里跟Leader保持同步的那些Follower都要把消息同步过去</strong>，才能认为这条消息是写入成功了。</p><p>如果说Partition Leader刚接收到了消息，但是结果Follower没有收到消息，此时Leader宕机了，那么客户端会感知到这个消息没发送成功，他会重试再次发送消息过去。</p><p>此时可能Partition 2的Follower变成Leader了，此时ISR列表里只有最新的这个Follower转变成的Leader了，那么只要这个新的Leader接收消息就算成功了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/5.jpg" alt=""></p><h3 id="6-最后的思考"><a href="#6-最后的思考" class="headerlink" title="6.最后的思考"></a><strong>6.最后的思考</strong></h3><p>acks=all 就可以代表数据一定不会丢失了吗？</p><p>当然不是，如果你的Partition只有一个副本，也就是一个Leader，任何Follower都没有，你认为acks=all有用吗？</p><p>当然没用了，因为ISR里就一个Leader，他接收完消息后宕机，也会导致数据丢失。</p><p>所以说，<strong>这个acks=all，必须跟ISR列表里至少有2个以上的副本配合使用</strong>，起码是有一个Leader和一个Follower才可以。</p><p>这样才能保证说写一条数据过去，一定是2个以上的副本都收到了才算是成功，此时任何一个副本宕机，不会导致数据丢失。</p><p><strong>参考</strong>：<a href="https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A">https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A</a></p><h2 id="二、Kafka参数调优实战"><a href="#二、Kafka参数调优实战" class="headerlink" title="二、Kafka参数调优实战"></a>二、Kafka参数调优实战</h2><h3 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h3><ol><li>背景引入：很多同学看不懂的Kafka参数</li><li>一段Kafka生产端的示例代码</li><li>内存缓冲的大小</li><li>多少数据打包为一个Batch合适？</li><li>要是一个Batch迟迟无法凑满怎么办？</li><li>最大请求大小</li><li>重试机制</li><li>持久化机制</li></ol><h4 id="1、背景引入：很多同学看不懂的kafka参数"><a href="#1、背景引入：很多同学看不懂的kafka参数" class="headerlink" title="1、背景引入：很多同学看不懂的kafka参数"></a>1、背景引入：很多同学看不懂的kafka参数</h4><p>在使用Kafka的客户端编写代码与服务器交互的时候，是需要对客户端设置很多的参数的。</p><h4 id="2、一段Kafka生产端的示例代码"><a href="#2、一段Kafka生产端的示例代码" class="headerlink" title="2、一段Kafka生产端的示例代码"></a>2、一段Kafka生产端的示例代码</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> props = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>); </span><br><span class="line">props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">67108864</span>); </span><br><span class="line">props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">131072</span>); </span><br><span class="line">props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">100</span>); </span><br><span class="line">props.put(<span class="string">&quot;max.request.size&quot;</span>, <span class="number">10485760</span>); </span><br><span class="line">props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>); </span><br><span class="line">props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">10</span>); </span><br><span class="line">props.put(<span class="string">&quot;retry.backoff.ms&quot;</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">KafkaProducer</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; producer = <span class="keyword">new</span> <span class="type">KafkaProducer</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;(props);</span><br></pre></td></tr></table></figure><h4 id="3、内存缓冲的大小"><a href="#3、内存缓冲的大小" class="headerlink" title="3、内存缓冲的大小"></a>3、内存缓冲的大小</h4><p>首先看看“<strong>buffer.memory</strong>”这个参数是什么意思？</p><p>Kafka的客户端发送数据到服务器，一般都是要经过<strong>缓冲</strong>的，也就是说，<strong>通过KafkaProducer发送出去的消息都是先进入到客户端本地的内存缓冲里，然后把很多消息收集成一个一个的Batch，再发送到Broker上去的</strong>。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/6.jpg" alt=""></p><p>所以这个“<strong>buffer.memory”的本质就是用来约束KafkaProducer能够使用的内存缓冲的大小的，他的默认值是32MB</strong>。</p><p>你可以先想一下，如果这个内存缓冲设置的过小的话，可能会导致一个什么问题？</p><p>首先要明确一点，那就是在内存缓冲里大量的消息会缓冲在里面，形成一个一个的Batch，每个Batch里包含多条消息。</p><p>然后KafkaProducer有一个Sender线程会把多个Batch打包成一个Request发送到Kafka服务器上去。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/7.jpg" alt=""></p><p>那么如果要是<strong>内存设置的太小</strong>，可能<strong>导致一个问题</strong>：消息快速的写入内存缓冲里面，但是Sender线程来不及把Request发送到Kafka服务器。</p><p>这样是不是会造成内存缓冲很快就被写满？一旦被写满，就会阻塞用户线程，不让继续往Kafka写消息了。</p><p>所以对于“buffer.memory”这个参数应该结合自己的实际情况来进行压测，你需要测算一下在生产环境，你的用户线程会以每秒多少消息的频率来写入内存缓冲。</p><p>比如说每秒300条消息，那么你就需要压测一下，假设内存缓冲就32MB，每秒写300条消息到内存缓冲，是否会经常把内存缓冲写满？经过这样的压测，你可以调试出来一个合理的内存大小。</p><h4 id="4、多少数据打包为一个Batch合适？"><a href="#4、多少数据打包为一个Batch合适？" class="headerlink" title="4、多少数据打包为一个Batch合适？"></a>4、多少数据打包为一个Batch合适？</h4><p>接着你需要思考第二个问题，就是你的“<strong>batch.size</strong>”应该如何设置？<strong>这决定了你的每个Batch要存放多少数据就可以发送出去了</strong>。</p><p>比如说你要是给一个Batch设置成是16KB的大小，那么里面凑够16KB的数据就可以发送了。</p><p>这个<strong>参数的默认值是16KB</strong>，一般可以尝试把这个参数调节大一些，然后利用自己的生产环境发消息的负载来测试一下。</p><p>比如说发送消息的频率就是每秒300条，那么如果比如“batch.size”调节到了32KB，或者64KB，是否可以提升发送消息的整体吞吐量。</p><p>因为理论上来说，提升batch的大小，可以允许更多的数据缓冲在里面，那么一次Request发送出去的数据量就更多了，这样吞吐量可能会有所提升。</p><p>但是<strong>不能无限的大</strong>，过于大了之后，要是数据老是缓冲在Batch里迟迟不发送出去，那么岂不是你发送消息的延迟就会很高，<strong>导致高延迟问题</strong>。</p><p>比如说，一条消息进入了Batch，但是要等待5秒钟Batch才凑满了64KB，才能发送出去。那这条消息的延迟就是5秒钟。</p><p>所以需要在这里按照生产环境的发消息的速率，调节不同的Batch大小自己测试一下最终出去的吞吐量以及消息的 延迟，设置一个最合理的参数。</p><h4 id="5、要是一个Batch迟迟无法凑满怎么办？"><a href="#5、要是一个Batch迟迟无法凑满怎么办？" class="headerlink" title="5、要是一个Batch迟迟无法凑满怎么办？"></a>5、要是一个Batch迟迟无法凑满怎么办？</h4><p>要是一个Batch迟迟无法凑满，此时就需要引入另外一个参数了，“<strong>linger.ms</strong>”</p><p><strong>含义是一个Batch被创建之后，最多过多久，不管这个Batch有没有写满，都必须发送出去了</strong>。</p><p>给大家举个例子，比如说batch.size是16kb，但是现在某个低峰时间段，发送消息很慢。</p><p>这就导致可能Batch被创建之后，陆陆续续有消息进来，但是迟迟无法凑够16KB，难道此时就一直等着吗？</p><p>当然不是，假设你现在设置“linger.ms”是50ms，那么只要这个Batch从创建开始到现在已经过了50ms了，哪怕他还没满16KB，也要发送他出去了。</p><p>所以“linger.ms”决定了你的消息一旦写入一个Batch，最多等待这么多时间，他一定会跟着Batch一起发送出去。</p><p>避免一个Batch迟迟凑不满，导致消息一直积压在内存里发送不出去的情况。<strong>这是一个很关键的参数。</strong></p><p>这个参数一般要非常慎重的来设置，要配合batch.size一起来设置。</p><p>举个例子，首先假设你的Batch是32KB，那么你得估算一下，正常情况下，一般多久会凑够一个Batch，比如正常来说可能20ms就会凑够一个Batch。</p><p>那么你的linger.ms就可以设置为25ms，也就是说，正常来说，大部分的Batch在20ms内都会凑满，但是你的linger.ms可以保证，哪怕遇到低峰时期，20ms凑不满一个Batch，还是会在25ms之后强制Batch发送出去。</p><p>如果要是你把linger.ms设置的太小了，比如说默认就是0ms，或者你设置个5ms，那可能导致你的Batch虽然设置了32KB，但是经常是还没凑够32KB的数据，5ms之后就直接强制Batch发送出去，这样也不太好其实，会导致你的Batch形同虚设，一直凑不满数据。</p><h4 id="6、最大请求大小"><a href="#6、最大请求大小" class="headerlink" title="6、最大请求大小"></a>6、最大请求大小</h4><p><strong>“max.request.size”这个参数决定了每次发送给Kafka服务器请求的最大大小</strong>，同时也会限制你一条消息的最大大小也不能超过这个参数设置的值，这个其实可以根据你自己的消息的大小来灵活的调整。</p><p>给大家举个例子，你们公司发送的消息都是那种大的报文消息，每条消息都是很多的数据，一条消息可能都要20KB。</p><p>此时你的batch.size是不是就需要调节大一些？比如设置个512KB？然后你的buffer.memory是不是要给的大一些？比如设置个128MB？</p><p>只有这样，才能让你在大消息的场景下，还能使用Batch打包多条消息的机制。但是此时“max.request.size”是不是也得同步增加？</p><p>因为可能你的一个请求是很大的，默认他是1MB，你是不是可以适当调大一些，比如调节到5MB？</p><h4 id="7、重试机制"><a href="#7、重试机制" class="headerlink" title="7、重试机制"></a>7、重试机制</h4><p><strong>“retries”和“retries.backoff.ms”决定了重试机制，也就是如果一个请求失败了可以重试几次，每次重试的间隔是多少毫秒</strong>。</p><p>这个大家适当设置几次重试的机会，给一定的重试间隔即可，比如给100ms的重试间隔。</p><h4 id="8、持久化机制"><a href="#8、持久化机制" class="headerlink" title="8、持久化机制"></a>8、持久化机制</h4><p>“acks”参数决定了发送出去的消息要采用什么样的持久化策略，这个涉及到了很多其他的概念，大家可以参考之前专门为“acks”写过的一篇文章。</p><p><strong>参考</strong>：<a href="https://mp.weixin.qq.com/s/YLrGg-jx5ddmHECmdccppw"></a></p><h2 id="三、消息中间件消费到的消息处理失败怎么办？"><a href="#三、消息中间件消费到的消息处理失败怎么办？" class="headerlink" title="三、消息中间件消费到的消息处理失败怎么办？"></a>三、消息中间件消费到的消息处理失败怎么办？</h2><p>消息中间件最核心的作用是：解耦、异步、削峰。</p><p>假如有如下的系统：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/8.jpg" alt=""></p><p>生产中存在这种情况：如果独立仓库系统或者第三方物流系统故障了，导致仓储系统消费到一条订单消息之后，尝试进行发货失败，也就是对这条消费到的消息处理失败。这种情况，怎么处理？</p><h4 id="死信队列的使用：处理失败的消息"><a href="#死信队列的使用：处理失败的消息" class="headerlink" title="死信队列的使用：处理失败的消息"></a>死信队列的使用：处理失败的消息</h4><p>一般生产环境中，如果你有丰富的架构设计经验，都会在使用MQ的时候设计两个队列：一个是<strong>核心业务队列</strong>，一个是<strong>死信队列</strong>。</p><p>核心业务队列，就是比如上面专门用来让订单系统发送订单消息的，然后另外一个死信队列就是用来处理异常情况的。</p><p>面试被问到这个问题时，必须要结合你自己的业务实践经验来说。</p><p>比如说要是第三方物流系统故障了，此时无法请求，那么仓储系统每次消费到一条订单消息，尝试通知发货和配送，都会遇到对方的接口报错。</p><p>此时仓储系统就可以把这条消息拒绝访问，或者标志位处理失败！<strong>注意，这个步骤很重要。</strong></p><p>一旦标志这条消息处理失败了之后，MQ就会把这条消息转入提前设置好的一个死信队列中。</p><p>然后你会看到的就是，在第三方物流系统故障期间，所有订单消息全部处理失败，全部会转入死信队列。</p><p>然后你的仓储系统得专门有一个后台线程，监控第三方物流系统是否正常，能否请求的，不停的监视。</p><p>一旦发现对方恢复正常，这个后台线程就从死信队列消费出来处理失败的订单，重新执行发货和配送的通知逻辑。</p><p><strong>死信队列的使用，其实就是MQ在生产实践中非常重要的一环，也就是架构设计必须要考虑的</strong>。</p><p>整个过程，如下图所示：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/9.jpg" alt=""></p><h2 id="四、Kafka选举"><a href="#四、Kafka选举" class="headerlink" title="四、Kafka选举"></a>四、Kafka选举</h2><p>Kafka中的选举大致可以分为三大类：</p><ul><li>控制器的选举</li><li>分区leader的选举</li><li>消费者相关的选举</li></ul><h4 id="1、控制器选举"><a href="#1、控制器选举" class="headerlink" title="1、控制器选举"></a>1、控制器选举</h4><p>在Kafka集群中会有一个或多个broker，其中有一个broker会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态等工作。</p><p>比如<strong>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本</strong>。再比如当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。</p><p>Kafka Controller的选举是依赖Zookeeper来实现的，在Kafka集群中那个broker能够成功创建/controller这个临时（Ephemeral）节点他就可以成为Kafka Controller。</p><p>这里需要说明一下的是Kafka Controller的实现还是相当复杂的，涉及到各个方面的内容，如果你掌握了Kafka Controller，你就掌握了Kafka的“半壁江山”。</p><h4 id="2、分区leader的选举"><a href="#2、分区leader的选举" class="headerlink" title="2、分区leader的选举"></a>2、分区leader的选举</h4><p>分区leader副本的选举<strong>由Kafka Controller 负责具体实施</strong>。</p><p>当创建分区（创建主题或增加分区都有创建分区的动作）或分区上线（比如分区中原先的leader副本下线，此时分区需要选举一个新的leader上线来对外提供服务）的时候都需要执行leader的选举动作。</p><p>基本思路是按照AR集合中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中。</p><p>一个分区的AR集合在分配的时候就被指定，并且只要不发生重分配的情况，集合内部副本的顺序是保持不变的，而分区的ISR集合中副本的顺序可能会改变。</p><p>注意：这里是根据AR的顺序而不是ISR的顺序进行选举的。这个说起来比较抽象，有兴趣的读者可以手动关闭/开启某个集群中的broker来观察一下具体的变化。</p><p>还有一些情况也会发生分区leader的选举，比如当分区进行重分配（reassign）的时候也需要执行leader的选举动作。</p><p>这个思路比较简单：从重分配的AR列表中找到第一个存活的副本，且这个副本在目前的ISR列表中。</p><p>再比如当发生优先副本（preferred replica partition leader election）的选举时，直接将优先副本设置为leader即可，AR集合中的第一个副本即为优先副本。</p><p>还有一种情况就是当某节点被优雅地关闭（也就是执行ControlledShutdown）时，位于这个节点上的leader副本都会下线，所以与此对应的分区需要执行leader的选举。</p><p>这里的具体思路为：从AR列表中找到第一个存活的副本，且这个副本在目前的ISR列表中，与此同时还要确保这个副本不处于正在被关闭的节点上。</p><h4 id="3、消费者相关的选择"><a href="#3、消费者相关的选择" class="headerlink" title="3、消费者相关的选择"></a>3、消费者相关的选择</h4><p>组协调器GroupCoordinator需要为消费组内的消费者选举出一个消费组的leader，这个选举的算法也很简单，分两种情况分析。</p><ul><li><p><strong>如果消费组内还没有leader，那么第一个加入消费组的消费者即为消费组的leader</strong>。</p></li><li><p><strong>如果某一时刻leader消费者由于某些原因退出了消费组，那么会重新选举一个新的leader，这个重新选举leader的过程又更“随意”了，相关代码如下</strong>：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scala code.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> members = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">MemberMetadata</span>]</span><br><span class="line"><span class="keyword">var</span> leaderId = members.keys.head</span><br></pre></td></tr></table></figure><p>解释一下这2行代码：在GroupCoordinator中消费者的信息是以HashMap的形式存储的，其中key为消费者的member_id，而value是消费者相关的元数据信息。</p><p>leaderId表示leader消费者的member_id，它的取值为HashMap中的第一个键值对的key，这种选举的方式基本上和随机无异。</p><p>总体上来说，消费组的leader选举过程是很随意的。</p><p>到这里就结束了吗？还有分区分配策略的选举呢。</p><p>或许你对此有点陌生，但是用过Kafka的同学或许对partition.assignment.strategy（取值为RangeAssignor、RoundRobinAssignor、StickyAssignor等）这个参数并不陌生。</p><p>每个消费者都可以设置自己的分区分配策略，对消费组而言需要从各个消费者呈报上来的各个分配策略中选举一个彼此都“信服”的策略来进行整体上的分区分配。</p><p>这个分区分配的选举并非由leader消费者决定，而是根据消费组内的各个消费者投票来决定的。</p><p><strong>参考</strong>：<a href="https://mp.weixin.qq.com/s/XvDpq1xxXPzRoRKMO-MxeQ"></a></p><h2 id="五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）"><a href="#五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）" class="headerlink" title="五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）"></a>五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）</h2><h3 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h3><p>其实这是很常见的一个问题，这俩问题基本可以连起来问。既然是消费消息，那肯定要考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？这个是 MQ 领域的基本问题，其实本质上还是问你<strong>使用消息队列如何保证幂等性</strong>，这个是你架构里要考虑的一个问题。</p><h3 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h3><p>回答这个问题，首先大概说一说可能会有哪些重复消费的问题。</p><p>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，挑 Kafka 来举个例子，说说怎么重复消费吧。</p><p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（<strong>定时定期</strong>），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p><p>但是，你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是<strong>没来得及提交 offset，重启之后，少数消息会再次消费一次</strong>。</p><p>例如，数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 <code>offset=153</code> 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1/2 的 offset 并没有提交，kafka 也就不知道你已经消费了 <code>offset=153</code> 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1/2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/10.png" alt=""></p><p><strong>如何保证消息队列消费的幂等性</strong>？</p><p>回答这个问题需要结合业务思考，有如下几个思路：</p><ul><li>比如数据要写库，先根据主键查一下，如果这数据都有了，就别插入了，update 一下。</li><li>比如是写 Redis，那没问题了，因为每次都是 set，天然幂等性。</li><li>比如不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面<strong>加一个全局唯一的 id</strong>，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，就别处理，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/11.png" alt=""></p><h2 id="六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）"><a href="#六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）" class="headerlink" title="六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）"></a>六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）</h2><h2 id="面试官心理分析-1"><a href="#面试官心理分析-1" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>这个是肯定的，用 MQ 有个基本原则，就是<strong>数据不能多一条，也不能少一条</strong>，不能多，就是前面说的[重复消费和幂等性问题。不能少，就是说这数据别搞丢了。那这个问题你必须得考虑一下。</p><p>如果说你这个是用 MQ 来传递非常核心的消息，比如说计费、扣费的一些消息，那必须确保这个 MQ 传递过程中<strong>绝对不会把计费消息给弄丢</strong>。</p><h2 id="面试题剖析-1"><a href="#面试题剖析-1" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>数据的丢失问题，可能出现在<strong>生产者、MQ、消费者</strong>中，从 Kafka 来分析一下。</p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h3 id="1、消费者丢失数据"><a href="#1、消费者丢失数据" class="headerlink" title="1、消费者丢失数据"></a>1、消费者丢失数据</h3><p>唯一可能导致消费者弄丢数据的情况，是消费到了这个消息，然后消费者那边<strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p><p>由于 Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是<strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><p>生产环境碰到的一个问题是Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p><h3 id="2、Kafka弄丢数据"><a href="#2、Kafka弄丢数据" class="headerlink" title="2、Kafka弄丢数据"></a>2、Kafka弄丢数据</h3><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。如果此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p><p>所以此时一般是要求起码设置如下 4 个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h3 id="3、生产者会不会弄丢数据？"><a href="#3、生产者会不会弄丢数据？" class="headerlink" title="3、生产者会不会弄丢数据？"></a>3、生产者会不会弄丢数据？</h3><p>如果按照上述的思路设置了 <code>acks=all</code>，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p><h2 id="七、如何保证消息的顺序性？"><a href="#七、如何保证消息的顺序性？" class="headerlink" title="七、如何保证消息的顺序性？"></a>七、如何保证消息的顺序性？</h2><p>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/12.png" alt=""></p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个<strong>内存 queue</strong>，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/13.png" alt=""></p><!-- 转载， -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kafka知识总结&quot;&gt;&lt;a href=&quot;#Kafka知识总结&quot; class=&quot;headerlink&quot; title=&quot;Kafka知识总结&quot;&gt;&lt;/a&gt;&lt;strong&gt;Kafka知识总结&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;一、讲讲acks参数对消息持久化的影响&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构-循环链表</title>
    <link href="http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</id>
    <published>2022-05-22T05:47:37.000Z</published>
    <updated>2022-05-22T05:47:37.996Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构-链表</title>
    <link href="http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</id>
    <published>2022-05-22T05:47:13.000Z</published>
    <updated>2022-05-22T06:03:09.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h3><p>介绍<br>    链表是有序(是由各个对象的指决定的)的按照线性顺序排序，但是它在内存中是存储如下<br>        <img src='img/链表.png' text='内存中实际结构'><br>        小结：<br>            1）、每个链表是以节点的方式来存储,是链式结构<br>            2）、每个节点包含data域，nex域，指向下有一个节点<br>            3）、如图，发现每个链表的各个节点不一定是连续存放（存储）的<br>            4)、链表分为带头结点和不带头结点的链表，根据是实际需求来确定<br>单链表的应用实例<br>    使用带head头的<font color="red">单向链表</font>实现-水浒英雄传的排行榜管理<br>        1、完成对英雄人物的<strong>增删改查</strong>操作，<br>        2、第一种方法再添加英雄时，直接添加到链表的尾部<br>        3、第二种方式在添加英雄时，根据排名将英雄插入到指定位置（如果存在排名则插入失败，并给出提示！！）</p><h4 id="单链表的创建示意图"><a href="#单链表的创建示意图" class="headerlink" title="单链表的创建示意图"></a>单链表的创建示意图</h4><p><img src="img/单链表创建示意图.png"></p><p>关键代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助节点temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有发现最后，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">//        将最后的这个节点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="第二种插入链表思路"><a href="#第二种插入链表思路" class="headerlink" title="第二种插入链表思路"></a>第二种插入链表思路</h4><p><img src="img/顺序插入链表.png"></p><p>关键代码代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    第二种方式添加英雄，根据排名将英雄插入到指定位置（如果存在这个排名，则添加失败并给出提示~）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//应为头节点不能动，因此我们需要辅助指针（变量）来确立要添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，因此我们找到temp是位于添加位置的前一个结点，否则插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//false标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;<span class="comment">//说明temp已经在链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no)&#123;<span class="comment">//位置找到，就在temp后面添加</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no ==heroNode.no)&#123;<span class="comment">//说明希望添加的herNode已经存在</span></span><br><span class="line">                flag =<span class="keyword">true</span>;<span class="comment">//说明编号存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp =temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;<span class="comment">//不能添加，编号存在</span></span><br><span class="line">            System.out.printf (<span class="string">&quot;准备插入的英雄编号%d已经存在,不能再添加了\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//插入到链表中，temp后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="修改节点的实现"><a href="#修改节点的实现" class="headerlink" title="修改节点的实现"></a>修改节点的实现</h3><p>关键代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   修改节点的信息根据no编号来修改，即no比编号不能改</span></span><br><span class="line"><span class="comment">//    根据newHeroNode的no来修改即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span></span>&#123;</span><br><span class="line"><span class="comment">//        判断为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        找需要修改的节点，根据NO的编号</span></span><br><span class="line"><span class="comment">//        定义一个辅助变量</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag =<span class="keyword">false</span>;<span class="comment">//表示是否找到节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no)&#123;</span><br><span class="line"><span class="comment">//                找到</span></span><br><span class="line">                flag =<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag，判断是否找修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有找到</span></span><br><span class="line">            System.out.printf (<span class="string">&quot;没有找到编号为%d的节点，不能修改\n&quot;</span>,newHeroNode.no);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>思路<br><img src="/img/链表删除节点.png"><br>1、我们先找到需要删除这个节点的前一个结点temp<br>2、temp=temp.next.next<br>3、被删除的节点将不会被其他节点所引用，会被垃圾回收机制回收<br>关键代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1、head不能动，因此我们需要一个temp辅助节点找到待删除结点的前一个结点</span></span><br><span class="line"><span class="comment">//    2、说明我们在比较时，是temp.next.no和待删除结点的no比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//表示是否找到待删除节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;<span class="comment">//已经到了链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">if</span> (temp.next.no ==no)&#123;</span><br><span class="line"><span class="comment">//                找到待删除节点的前一个结点</span></span><br><span class="line">                flag =<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp =temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        判断flag</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;<span class="comment">//找到</span></span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.printf (<span class="string">&quot;要删除的%d节点不存在&quot;</span>,no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><!-- 待完善 --></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;链表（Linked-List）&quot;&gt;&lt;a href=&quot;#链表（Linked-List）&quot; class=&quot;headerlink&quot; title=&quot;链表（Linked List）&quot;&gt;&lt;/a&gt;链表（Linked List）&lt;/h3&gt;&lt;p&gt;介绍&lt;br&gt;    链表是有序(是由</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构-环形队列的实现</title>
    <link href="http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-05-22T05:47:03.000Z</published>
    <updated>2022-05-22T06:02:37.034Z</updated>
    
    <content type="html"><![CDATA[<p>问题分析优化<br>1）目前数组不能复用<br>2）将这个数组使用算法，改进成为一个<font color="red">环形队列</font>（取模的方式）</p><p>环形队列思路如下<br>    1、front变量的含义做一个调整，front就指向队列第一个元素，也就是说arr[front]就是队列的第一元素front的初始值=0<br>    2、rear变量的含义做一个调整；rear指向队列的最后一个元素的后一个位置，应为希望空一个空间作为约定rear的初始值=0<br>    3、当队列满时，条件是（rear + 1）%maxSize == front【满】<br>    4、当队列为空的条件，rear==front空<br>    5、当我们这样分析，队列中有效数据的个数（rear + maxSize - front）% maxSize<br>代码实现：<br>```java<br>package com.xiaohuli.queue;</p><p>import java.util.Scanner;</p><p>/**</p><ul><li>@Author: oyster</li><li>@Description: TODO</li><li>@DateTime: 2022/1/30 0:37<br>**/<br>public class CircleArrayQueue {<br> public static void main(String[] args) {<pre><code> //测试 System.out.println (&quot;测试数组模拟环形队列是否可用&quot;); //创建一个队列 CircleArray arrayQueue = new CircleArray (3); char key = &#39; &#39;;//接受用户收入 Scanner scanner = new Scanner (System.in); boolean loop = true; //输出一个菜单 while (loop) &#123;     System.out.println (&quot;s(show):显示队列&quot;);     System.out.println (&quot;e(exit):退出队列&quot;);     System.out.println (&quot;a(add):添加数据到队列&quot;);     System.out.println (&quot;g(get):从队列取出数据&quot;);     System.out.println (&quot;h(head):查看队列头的数据&quot;);     key = scanner.next ().charAt (0);//接收一个字符串     switch (key) &#123;         case &#39;s&#39;:             arrayQueue.showQueue ();             break;         case &#39;a&#39;:             System.out.println (&quot;输入一个数&quot;);             int value = scanner.nextInt ();             arrayQueue.addQueue (value);             break;         case &#39;g&#39;://取出数据             try &#123;                 int res = arrayQueue.getQueue ();                 System.out.printf (&quot;取出的数据为%d\n&quot;, res);             &#125; catch (Exception e) &#123;                 System.out.println (e.getMessage ());//获取异常信息             &#125;             break;         case &#39;h&#39;://查看队列头的数据             try &#123;                 int res = arrayQueue.headQueue ();                 System.out.printf (&quot;队列头的数据是%d\n&quot;, res);             &#125; catch (Exception e) &#123;                 System.out.println (e.getMessage ());             &#125;             break;         case &#39;e&#39;://退出             scanner.close ();//如果不关掉会报异常信息             loop = false;             break;         default:             break;     &#125; &#125; System.out.println (&quot;程序退出~~~~~~~~&quot;);</code></pre> }</li></ul><p>}</p><p>class CircleArray {<br>    private int maxSize;//表示最大容量<br>    //        front初始化为0<br>    private int front;//队列头<br>    //        rear初始化为0<br>    private int rear;//队列尾<br>    private int[] arr;//该数组用来存放数据，模拟队列</p><pre><code>public CircleArray(int arrMaxSize) &#123;    maxSize = arrMaxSize;    arr = new int[maxSize];&#125;//判断队列是否为满public boolean isFull() &#123;    return (rear + 1) % maxSize == front;&#125;//判断队列是否为空public boolean isEmpty() &#123;    return rear == front;&#125;//添加数据到队列public void addQueue(int n) &#123;</code></pre><p>//          判断队列是满<br>        if (isFull ()) {<br>            System.out.println (“队列满，不能加入数据~”);<br>            return;<br>        }<br>        //直接将数据加入<br>        arr[rear] = n;<br>        //将rear后移,这里必须考虑取模<br>        rear = (rear + 1) % maxSize;<br>    }</p><pre><code>//        获取队列的数据，出队列public int getQueue() &#123;</code></pre><p>//            判断是否为空<br>        if (isEmpty ()) {<br>//                通过抛出异常<br>            throw new RuntimeException (“队列为空，不能取数据”);<br>        }<br>        //这里需要分析出front是指向队列的第一个元素<br>//            1、先将front对应的值保留到一个临时变量<br>//            2、将front后移<br>//            3、将临时保存的变量返回<br>        int value = arr[front];<br>        front = (front + 1) % maxSize;<br>        return value;<br>    }</p><pre><code>//        显示队列中所有数据public void showQueue() &#123;    //遍历    if (isEmpty ()) &#123;        System.out.println (&quot;队列为空&quot;);        return;    &#125;    //思路：从front开始遍历，遍历多少个元素    //动脑筋    for (int i = front; i &lt; front + size (); i++) &#123;        System.out.printf (&quot;arr[%d]=%d\n&quot;, i % maxSize, arr[i % maxSize]);    &#125;&#125;//求出当前数列有效数据的个数public int size() &#123;</code></pre><p>//            rear = 1<br>//            maxSize = 3<br>//            front =0<br>        return (rear + maxSize - front) % maxSize;<br>    }</p><pre><code>//        显示队列头数据，注意不是取出数据public int headQueue() &#123;    if (isEmpty ()) &#123;        throw new RuntimeException (&quot;队列为空，不存在数据~~·&quot;);    &#125;    return arr[front];&#125;</code></pre><p>}</p><p>// 待完善</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问题分析优化&lt;br&gt;1）目前数组不能复用&lt;br&gt;2）将这个数组使用算法，改进成为一个&lt;font color=&quot;red&quot;&gt;环形队列&lt;/font&gt;（取模的方式）&lt;/p&gt;
&lt;p&gt;环形队列思路如下&lt;br&gt;    1、front变量的含义做一个调整，front就指向队列第一个元素，也</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构-队列</title>
    <link href="http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</id>
    <published>2022-05-22T05:46:29.000Z</published>
    <updated>2022-05-22T06:06:19.607Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>基本介绍<br>1、队列是一个有序列表，可以用数组或是链表实现<br>2、遵循先入先出原则<sup><a href="#fn_先入先出" id="reffn_先入先出">先入先出</a></sup><br>3、使用数组队列示意图（暂缺）</p><p>数组模拟队列思路<br>    1、对列本身是有序列表，若使用数据结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量<br>    2、因为队列的输出，输入都是从前后端处理的，因此需要两个变量front及rear分别记录前后端的变化的下标，front会随着数据的输出而改变，而rear则是随着数据输入而改变<br>    3、当我们将数据存入队列时称为“addQueue”,addQueue的处理需要有两个步骤<br>    3.1 将尾指针往后移，rear加1，当front==rear【空】<br>    3.2 若指针rear小于队列的最大下标maxSize-1 <sup><a href="#fn_数组队列" id="reffn_数组队列">数组队列</a></sup>，则将数据存入rear所指数组元素中，否则将无法存入数据，rear = maxSize-1【队列满】<br>数组代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaohuli.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: oyster</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/1/29 18:32</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue arrayQueue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key =<span class="string">&#x27; &#x27;</span>;<span class="comment">//接受用户收入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner (System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;e(exit):退出队列&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;h(head):查看队列头的数据&quot;</span>);</span><br><span class="line">            key =scanner.next ().charAt (<span class="number">0</span>);<span class="comment">//接收一个字符串</span></span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> :</span><br><span class="line">                    arrayQueue.showQueue ();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println (<span class="string">&quot;输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt ();</span><br><span class="line">                    arrayQueue.addQueue (value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:<span class="comment">//取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res =arrayQueue.getQueue ();</span><br><span class="line">                        System.out.printf (<span class="string">&quot;取出的数据为%d\n&quot;</span>,res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println (e.getMessage ());<span class="comment">//获取异常信息</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="comment">//查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = arrayQueue.headQueue ();</span><br><span class="line">                        System.out.printf (<span class="string">&quot;队列头的数据是%d\n&quot;</span>,res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                       System.out.println (e.getMessage ());</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="comment">//退出</span></span><br><span class="line">                    scanner.close ();<span class="comment">//如果不关掉会报异常信息</span></span><br><span class="line">                    loop =<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (<span class="string">&quot;程序退出~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//使用数组模拟队列-编写一个ArrayQueue</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示最大容量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用来存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列构造器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span></span>&#123;</span><br><span class="line">            maxSize =arrMaxSize;</span><br><span class="line">            arr =<span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">            front =-<span class="number">1</span>;<span class="comment">//指向队列头部，分析front是指向队列头的前一个位置</span></span><br><span class="line">            rear = -<span class="number">1</span>;<span class="comment">//指向队列尾，指向队列尾的数据（即就是队列最后的一个数据）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为满</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear == maxSize-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear == front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加数据到队列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//          判断队列是满</span></span><br><span class="line">            <span class="keyword">if</span> (isFull ())&#123;</span><br><span class="line">                System.out.println (<span class="string">&quot;队列满，不能加入数据~&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear++;<span class="comment">//让rear后移</span></span><br><span class="line">            arr[rear]=n;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        获取队列的数据，出队列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//            判断是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (isEmpty ())&#123;</span><br><span class="line"><span class="comment">//                通过抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">&quot;队列为空，不能取数据&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            front++;<span class="comment">//front后移</span></span><br><span class="line">            <span class="keyword">return</span> arr[front];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        显示队列中所有数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">if</span> (isEmpty ())&#123;</span><br><span class="line">                System.out.println (<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">                System.out.printf (<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        显示队列头数据，注意不是取出数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty ())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">&quot;队列为空，不存在数据~~·&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr[front+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote id="fn_数组队列"><sup>数组队列</sup>. 数组的下标的都是从0开始的<a href="#reffn_数组队列" title="Jump back to footnote [数组队列] in the text."> &#8617;</a></blockquote><blockquote id="fn_先入先出"><sup>先入先出</sup>. 先存入队列的数据，要先取出，后存入的数据要后取出。<a href="#reffn_先入先出" title="Jump back to footnote [先入先出] in the text."> &#8617;</a></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;队列&quot;&gt;&lt;a href=&quot;#队列&quot; class=&quot;headerlink&quot; title=&quot;队列&quot;&gt;&lt;/a&gt;队列&lt;/h3&gt;&lt;p&gt;基本介绍&lt;br&gt;1、队列是一个有序列表，可以用数组或是链表实现&lt;br&gt;2、遵循先入先出原则&lt;sup&gt;&lt;a href=&quot;#fn_先入先出&quot; i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构-稀疏数组</title>
    <link href="http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</id>
    <published>2022-05-22T05:46:18.000Z</published>
    <updated>2022-05-22T06:00:21.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="稀疏数组和队列"><a href="#稀疏数组和队列" class="headerlink" title="稀疏数组和队列"></a>稀疏数组和队列</h2><h4 id="需求编写一个五子棋程序中，有存盘退出和续上盘功能"><a href="#需求编写一个五子棋程序中，有存盘退出和续上盘功能" class="headerlink" title="需求编写一个五子棋程序中，有存盘退出和续上盘功能"></a>需求编写一个五子棋程序中，有<strong>存盘退出</strong>和<strong>续上盘</strong>功能</h4><p><img src="/img/稀疏数组.png"></p><p>分析问题：因为存在太多重复数据，所以采用稀疏数组进行压缩，以减少空间利用</p><p>基本介绍<br>当一个数组中大部分元素为0，或者为同一个值的时，，<br>处理方式<br>    记录数组一共有几行几列，有多少个不同的的值<br>    把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p><font color="red">应用实例</font><p><img src="/img/稀疏数组的过程.png"></p><p>二维数组转稀疏数组的思路<br>    1、遍历原始的二维数组，得到有效数据的个数sum<br>    2、根据sum就可以创建稀疏数组sparrseArr int[sum +1][3]<br>    3、将二维数组的有效数据存入到稀疏数组</p><p>稀疏数组转二维数组的思路<br>    1、先读取稀疏数组的第一行，根据第一行还原二维数组，比如稀疏数组后几行的数据，并赋予原始的二维数组即上面的chessArr2= int[11][11]<br>    2、在读取可剩余数据即可```<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//      将二维数组转稀疏数组</span></span><br><span class="line"><span class="comment">//        先遍历二维数组 得到非0数据个数</span></span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2、创建相应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum +<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//        给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历二维数组，将非0 的值存放到sparseArr中</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count用于记录是第几个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">11</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; <span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] !=<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>]=i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>]=j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        输出稀疏数组的形式</span></span><br><span class="line">        System.out.println ();</span><br><span class="line">        System.out.println (<span class="string">&quot;得到的稀疏数组如下形式&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">            System.out.printf (<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>,sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//           将稀疏数组 --》 恢复成二维数组</span></span><br><span class="line"><span class="comment">//            1.先读取第一行还原原始二维数组数据</span></span><br><span class="line">            <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"><span class="comment">//            2.读取稀疏数组后几行的数据（第二行），并赋给原始的二维数据即可</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">                    chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//四、将稀疏数组保存到磁盘上，如map.data</span></span><br><span class="line">        String path = <span class="string">&quot;D:\\idea项目\\DataStructures\\src\\main\\resources\\map.data&quot;</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File (path);</span><br><span class="line">            System.out.println(<span class="string">&quot;将稀疏数组保存到磁盘并命名为map.data&quot;</span>);</span><br><span class="line">            FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            OutputStreamWriter osw =<span class="keyword">new</span> OutputStreamWriter (out,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;开始存入二维数组~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length ; i++) &#123;</span><br><span class="line">                osw.write (sparseArr[i][<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+sparseArr[i][<span class="number">1</span>]+<span class="string">&quot;,&quot;</span>+sparseArr[i][<span class="number">2</span>]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            osw.close ();<span class="comment">//关闭输出流</span></span><br><span class="line">            out.close ();<span class="comment">//关闭输出流</span></span><br><span class="line">            System.out.println (<span class="string">&quot;存储成功~~&quot;</span> );</span><br><span class="line"><span class="comment">//              开始读取磁盘中的二维数组</span></span><br><span class="line">            System.out.println (<span class="string">&quot;读取磁盘中的稀疏数组并还原为二维组~~~&quot;</span>);</span><br><span class="line">            FileInputStream inp = <span class="keyword">new</span> FileInputStream (path);</span><br><span class="line">            InputStreamReader reader = <span class="keyword">new</span> InputStreamReader (inp,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;开始读取------&quot;</span>);</span><br><span class="line">            <span class="comment">//StringBuffer主要是做一个缓冲的作用</span></span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer ();</span><br><span class="line">            <span class="keyword">while</span> (reader.ready ())&#123;</span><br><span class="line">                sb.append ((<span class="keyword">char</span>) reader.read ());</span><br><span class="line">            &#125;</span><br><span class="line">            inp.close ();<span class="comment">//关闭输入流</span></span><br><span class="line">            reader.close ();<span class="comment">//关闭输入流</span></span><br><span class="line">            String ss = sb.toString ();</span><br><span class="line">            System.out.printf(<span class="string">&quot;从磁盘读取的字符串\n%s\n&quot;</span>,ss);</span><br><span class="line">            String[] read = sb.toString ().split (<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="comment">//恢复成稀疏数组</span></span><br><span class="line">            <span class="keyword">int</span> arseArr[][] =<span class="keyword">new</span> <span class="keyword">int</span>[read.length/<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">int</span> sum1 =<span class="number">0</span>;</span><br><span class="line">            arseArr[<span class="number">0</span>][<span class="number">0</span>] =Integer.parseInt (read[<span class="number">0</span>]);</span><br><span class="line">            arseArr[<span class="number">0</span>][<span class="number">1</span>] = Integer.parseInt (read[<span class="number">1</span>]);</span><br><span class="line">            arseArr[<span class="number">0</span>][<span class="number">2</span>] = Integer.parseInt (read[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span> ;i&lt;read.length; i +=<span class="number">3</span>)&#123;</span><br><span class="line">                sum1++;</span><br><span class="line">                arseArr[sum1][<span class="number">0</span>] = Integer.parseInt (read[i]);</span><br><span class="line">                arseArr[sum1][<span class="number">1</span>] =Integer.parseInt (read[i+<span class="number">1</span>]);</span><br><span class="line">                arseArr[sum1][<span class="number">2</span>] =Integer.parseInt (read[i+<span class="number">2</span>]);</span><br><span class="line">            &#125;            </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;稀疏数组和队列&quot;&gt;&lt;a href=&quot;#稀疏数组和队列&quot; class=&quot;headerlink&quot; title=&quot;稀疏数组和队列&quot;&gt;&lt;/a&gt;稀疏数组和队列&lt;/h2&gt;&lt;h4 id=&quot;需求编写一个五子棋程序中，有存盘退出和续上盘功能&quot;&gt;&lt;a href=&quot;#需求编写一个五子棋</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据结构概念与引入</title>
    <link href="http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BC%95%E5%85%A5/"/>
    <id>http://yoursite.com/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BC%95%E5%85%A5/</id>
    <published>2022-05-22T05:45:30.000Z</published>
    <updated>2022-05-22T05:59:46.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据结构与算法的关系"><a href="#数据结构与算法的关系" class="headerlink" title="数据结构与算法的关系"></a>数据结构与算法的关系</h2><pre><code>数据data（structure）是一门研究组织数据的方式的学科，有了编程语言也就有了数据结构，程序 = 数据结构＋算法算法就是对现实事务进行高度抽象数据结构是算法的基础</code></pre><p><font color=blue> 实际开发遇到的问题</font>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    String str </span>= <span class="string">&quot;java java ,java hello hello&quot;</span></span><br><span class="line">    String newStr = str.replaceAll(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;尚佳谷&quot;</span>)</span><br><span class="line">    System.out.print(<span class="string">&quot;newStr+&quot;</span>+newStr);</span><br></pre></td></tr></table></figure></p><p>数据结构包含： 线性结构 非线结构</p><p><font color="red">线性结构</font><br>作为最常用的数据结构，其特点数据元素之间存在一对一的线性关系<br>线性结构有两种不同的存储结构，及顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的<br>链式存储的线性表称为链表，链表的元不一定是连续的，元素节点存放数据元素以及相邻的元素的地址信息<br>线性结构常见的有：数组、列表、链表、栈</p><p><font color="red">非线性结构</font><br>包含：二维数组、多维数组、广义表、树结构、图结构</p><!-- 待完善 -->]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据结构与算法的关系&quot;&gt;&lt;a href=&quot;#数据结构与算法的关系&quot; class=&quot;headerlink&quot; title=&quot;数据结构与算法的关系&quot;&gt;&lt;/a&gt;数据结构与算法的关系&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;数据data（structure）是一门研究组织数据的方式的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>“关于微服务的疑难问题以及解决方案”</title>
    <link href="http://yoursite.com/2022/05/22/%E2%80%9C%E5%85%B3%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%9D/"/>
    <id>http://yoursite.com/2022/05/22/%E2%80%9C%E5%85%B3%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%9D/</id>
    <published>2022-05-22T05:37:04.000Z</published>
    <updated>2022-05-22T05:37:04.354Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
