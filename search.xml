<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>魔改记录</title>
      <link href="/2024/09/10/%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/09/10/%E9%AD%94%E6%94%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java-集合</title>
      <link href="/2022/06/25/java-%E9%9B%86%E5%90%88/"/>
      <url>/2022/06/25/java-%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>java集合就像一种容器，可以<font color="blue">动态的</font>把多个对象的引用放入容器</p><blockquote><p>集合框架概述<br>集合、数组都是对多个数据进行存储操作的结构，简称java容器</p><blockquote><p>数组在内存存储方面的特点</p><blockquote><p>数组初始化以后长度就确定<br>数组声明的类型，就决定进行元素初始化的类型<br>数组在存储数据方面的弊端<br>数组初始化以后，长度不可变<br>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高<br>数组存储的数据是有序的、可以重复的,对于无序的、不可重复的需求不能得到很好的满足。—&gt;存储数据单一</p></blockquote></blockquote></blockquote><p>Java的集合类可以用于存储数量不等的<font color="red">对象</font>，还可以保存<br>具有映射关系的关联数组（有点像链表的形式）</p><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><p>Collection接口：单列数据，定义了存取一组对象的方法的合集<br>&gt;</p><blockquote><blockquote><blockquote><p><font color="red">List:</font>元素有序、可重复的集合<br>—-&gt; ArrList、LinkedList、Vector</p><p><font color="red">Set:</font>元素无序、不可重复的集合<br>—-&gt;HashSet、LinkedHashSet、TreeSet<br><img src="img/collection继承树.png"></p></blockquote></blockquote></blockquote><h4 id="常用集合方法"><a href="#常用集合方法" class="headerlink" title="常用集合方法"></a>常用集合方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">CollectionText</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add(Object e);  将元素E添加到集合Coll中</span></span><br><span class="line">    coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    coll.add(<span class="number">123</span>);<span class="comment">//自动装箱</span></span><br><span class="line">    coll.add(<span class="keyword">new</span> Data()); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// size()：获取添加元素的个数</span></span><br><span class="line">    System.out.println(coll.size());<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// addAll(Collection cll1):将一个完整的集合中元素添加给另外一个集合</span></span><br><span class="line">    Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll1.add(<span class="number">2345</span>);</span><br><span class="line">    coll1.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    coll.addAll(coll1);</span><br><span class="line">    System.out.println(coll.size());<span class="comment">//6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//isEmpty():判断当前集合是否为空</span></span><br><span class="line">     System.out.println(coll.isEmpty());</span><br><span class="line"></span><br><span class="line">     <span class="comment">//clear():清空当前元素</span></span><br><span class="line">        coll.clear()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="contains-Object-obj"><a href="#contains-Object-obj" class="headerlink" title="contains(Object obj)"></a>contains(Object obj)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Text</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test111</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">21</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> Data);</span><br><span class="line">        <span class="comment">//contains(Object obj)判断当前集合中是否包含Obj</span></span><br><span class="line">        <span class="keyword">boolean</span> contains = coll.contains(<span class="number">123</span>);</span><br><span class="line">        System.out.println(contains)<span class="comment">//true</span></span><br><span class="line">        System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>)))) <span class="comment">//true</span></span><br><span class="line">        <span class="comment">// containsAlll(Collection coll);判断形参从coll1中的所有元素是否都存在于目标集合中</span></span><br><span class="line">        Collection coll1 = ArrayList(<span class="number">123</span>,<span class="number">4567</span>);</span><br><span class="line">        System.out.println(coll.containsAll(coll1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> name;</span><br><span class="line">    <span class="keyword">private</span> age;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-Object-obj"><a href="#remove-Object-obj" class="headerlink" title="remove(Object obj)"></a>remove(Object obj)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//remove(Object obj) 从当前集合中移除obk元素</span></span><br><span class="line">    Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="keyword">false</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">21</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> Data);</span><br><span class="line">    coll.remove(<span class="number">123</span>);</span><br><span class="line">    System.out.println(coll)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//removeAll(Collection coll1) 从当前集合中移除coll1中所有元素</span></span><br><span class="line">    Collection coll1 = Arrays.asList(<span class="number">123</span>,<span class="number">4567</span>)</span><br><span class="line">    coll.removeAll(coll1);</span><br><span class="line">    System.out.println(coll);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- ### 习题--><!-- 1、什么是枚举类？枚举类的对象声明的修饰符都有哪些>枚举类：类中的对象的个数是确定的，有限个public static final2、什么是元注解？说说Rettention和Target元注解的作用给>元注解:对现有注解进行解释说明的注解Rettention：指明所修饰的注解的生命周期，SOURCE CLASS RUNTIMETarget:3、说说你所理解的集合框架都有哪些接口，存储数据都有什么特点>元素有序、可重复的集合ArrList、LinkedList、Vector元素无序、不可重复的集合HashSet、LinkedHashSet、TreeSet4、比较throw和throws的异同>同throw:生成一个异常对象，并抛出。使用在方法内部<->自动抛出throws:处理异常的方式。使用在方法声明处的末尾<->try-catch-finally5、谈谈你对同步代码块中同步监视器和共享数据的理解及各自要求>同步监视器:俗称锁>>①任何一个类的对象都可以被称为锁②多个线程共用一把锁共享数据：多个线程共同操作的数据，即共享数据需要使用同步机制将操作共享数据的代码包起来 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java-枚举类和注解</title>
      <link href="/2022/06/24/java-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/06/24/java-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>1、jdk5.0新增的功能<br>2、Annotation 其实就是代码里面的特殊标记，这些标记可以在编译，类加载，运行时被加载，并在程序员不改变原逻辑的情况下，在源文件中嵌入一些补充信息。<br>3、在javaSe中，注解的使用目的比较简单，列如标记过时的功能，忽略警告等，在javaEE中注解占据更重要的的角色，列如来配置应用程序的人任何切面，替代SE遗留的大量xml配置和繁重代码。</p><h3 id="内置的基本注解"><a href="#内置的基本注解" class="headerlink" title="内置的基本注解"></a>内置的基本注解</h3><blockquote><p>jdk内置的三个基本注解<br>@Override:限定重写父类方法，该注解只能用于方法<br>@Deprecated:用于表示所修饰的元素(类方法等)已过时，通常是因为所修饰的结构危险<br>@SuppressWarnings:抑制编译器警告</p></blockquote><h3 id="自定义注解注解"><a href="#自定义注解注解" class="headerlink" title="自定义注解注解"></a><font color="red">自定义注解<sup><a href="#fn_注解" id="reffn_注解">注解</a></sup></font></h3><blockquote><p>①注解声明为:@interface,参照@SuppressWarnings定义<br>Annotation的成员变量在Annotation的定义中为无参方法的形式来声明其值定义了该成员的名字和类型,配置类型为八种基本数据类型(一般情况下只有一个成员变量参数名使用value(),默认值设置则用<font color="red">default&lt;/font &gt;来)<br>②内部定义成员,通常使用value来表示<br>③可以指定成员的默认值,使用defalu来定义<br>④如果自定义注解没有成员,则是一个<font color="blue">标识</font>作用</p></blockquote><font color="red">如果注解有成员,在使用注解时需要传入值</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个注解,传入一个字符串给这个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="title">defalut</span><span class="params">(<span class="string">&quot;words&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用这个注解</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;hellos&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人走路!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元Annotation用于修饰其他Annotation的定义(元数据<sup><a href="#fn_元数据" id="reffn_元数据">元数据</a></sup>)<br>jdk5.0提供了4个标准的meta-Annotation的类型分别是</p><blockquote><p><font color="red">@Retention</font>:只能用于修饰一个Annotation定义,用于指定该Annotation的生命周期,@Retention包含一个<font color="red">RetentionPolicy</font>类型的成员变量,使用时必须为其指定该value成员变量指定的值</p><blockquote><p><font color="red">RetentionPolicy.SOURCE:</font>在源文件中有效(即源文件保留),编译器直接丢弃这种策略的注释<br>   <font color="red">RetentionPolicy.CLASS:</font>在class文件中有效(即class保留),当运行java程序时,JVM不会保留注解,这是默认值<br>   <font color="red">RetentionPolicy.RUNTIME:</font>在运行时有效(即运行时保留),当运行java程序时,JVM会保留注解,程序可以通过反射获得该注解<br>   <img src="img/RetentionPolicy流程.png"><br>   <img src="img/RetentionPolicy中的枚举类.png">  </p></blockquote><p><font color="red">@Target</font>:用来修饰Annotation定义,用于指定被修饰的Annotation能用于修饰哪些程序元素,@Target也包含一个名为value的成员变量</p><blockquote><p>详细如下↓</p></blockquote></blockquote><div class="table-container"><table><thead><tr><th>取值(ElementType)</th><th></th><th>取值(ElementType)</th><th></th></tr></thead><tbody><tr><td>CONSTRUCTOR</td><td>用于描述构造器</td><td>PACKAGE</td><td>用于描述包</td></tr><tr><td>FIELD</td><td>用于描述域</td><td>PARAMETER</td><td>用于描述参数</td></tr><tr><td>LOCAL_VARIABLE</td><td>用于描述局部变量</td><td>TRPE</td><td>用于描述类,接口(包含注解类型)或enum声明</td></tr><tr><td>METHOD</td><td>用于描述方法</td><td></td></tr></tbody></table></div><p><img src="img/Target枚举类.png"></p><blockquote><p><font color="red">@Documented</font>:表示所修饰的Annotation类会被Javadoc提取为文档</p><p><font color="red">@Inherited</font>:被它修饰的Annotation会具有<font color="red">继承性</font>,如果某类被注解了Inherited及其子类会自动继承父类级别的注解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Text</span></span><br><span class="line"><span class="comment">//通过反射获取注解信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">textGetAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class clazz Student.class;</span><br><span class="line">    Annotation[] annotation clazz.getAnnotation();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;annotation.length;i++&gt;)&#123;</span><br><span class="line">        System.out.println(annotation[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java8新特性"><a href="#java8新特性" class="headerlink" title="java8新特性"></a>java8新特性</h2><h3 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h3><p>可重复注解：</p><blockquote><p>①在MyAnnotation上声明@Repeatable，成员值为Annotations.class。<br>②MyAnnotation的Target和Retention和MyAnnotations等元注解保持一致。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span><span class="comment">//让其子类具有继承性</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(MyAnnotation.RUNTIME)</span></span><br><span class="line"><span class="meta">@Retget(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAT_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="title">defalut</span><span class="params">(<span class="string">&quot;words&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建的一个类名为 Annotations这里写为class的形式</span></span><br><span class="line"><span class="meta">@Retention(MyAnnotation.RUNTIME)</span></span><br><span class="line"><span class="meta">@Retget(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAT_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations&#123;</span><br><span class="line">    Annotation[] value() defalut(<span class="string">&quot;words&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk8之前的写法</span></span><br><span class="line"><span class="comment">// @MyAnnotation(&#123;@MyAnnotation(value=&quot;shijie&quot;),@MyAnnotation(value=&quot;hellos&quot;)&#125;)</span></span><br><span class="line"><span class="comment">// 重复使用这个注解</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;shijie&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;hellos&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人走路!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h3><p>关于元注解@Target的参数类型ElementType枚举值多了两个</p><blockquote><p><font color="blue">TYPE_PARAMETER,TYPE_USE</font><br>ElementType.TYPE_PARAMETER -&gt; 表示该注解能写在类型变量的声明语句中<br>ElementType.TYPE_USE -&gt; 表示该注解能写在使用类型的任何语句中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(MyAnnotation.RUNTIME)</span></span><br><span class="line"><span class="meta">@Retget(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAT_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="title">defalut</span><span class="params">(<span class="string">&quot;words&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TYPE_PARAMETER</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;@<span class="title">MyAnnotation</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//TYPE_USE</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;<span class="meta">@MyAnnotation</span> String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = (<span class="meta">@MyAnnotation</span> <span class="keyword">int</span> ) <span class="number">10L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote id="fn_注解"><sup>注解</sup>. 自定义注解必须配上注解信息处理流程才有意义(反射实现)<a href="#reffn_注解" title="Jump back to footnote [注解] in the text."> &#8617;</a></blockquote><blockquote id="fn_元数据"><sup>元数据</sup>. 在数据库中对于现有数据的修饰<a href="#reffn_元数据" title="Jump back to footnote [元数据] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>学习计划</title>
      <link href="/2022/06/24/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/"/>
      <url>/2022/06/24/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>Java 学习路线一条龙版 by 鱼皮。</p><p>原创不易，请勿抄袭，违者必究！</p><p>大家好，我是鱼皮。现在网上的编程资料实在太多了，而且人人肯定都说自己的最好，那就导致大家又不知道怎么选了。大部分的博主推荐资源，也就是把播放量高的视频说一遍，水一期视频，没有一条很清晰的学习路线。</p><p>所以今天我的这个 Java 学习路线就做做减法，给大家来个一条龙服务，Java 要学的知识点、对应的最佳学习资源和预计要花费的时间，都安排的明明白白的，不用选了，有计划了，也别再迷茫和纠结了，就无脑跟着学就行了。</p><p>大纲<br>实在太长了，没办法全部展开，只能放个大纲了。。。</p><p>图片<br>鱼皮 - Java 学习路线 一条龙版本<br>路线特点<br>最新，完整一条龙，从入门到入土（⭐ 表示推荐学习）</p><p>给出目标、学习建议、关键知识点、最优资源以及各类资源推荐（视频、书籍、文档、项目、工具等）</p><p>鱼皮自己是 Java 开发者，融入个人经历 + 思考，让路线有灵魂</p><p>划分阶段、更有计划，且在最后给出持续学习的方向、探索 Java 程序员发展的无限可能</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先呢，我们要了解 Java 的应用场景和就业方向，看看和自己的学习目的是否一致，目前，Java 的岗位需求多，是后台开发的主流编程语言，功能强大，还是很值得学习的。</p><p>那大家可以看我的视频了解：<a href="https://www.bilibili.com/video/BV1y3411r7pX/">https://www.bilibili.com/video/BV1y3411r7pX/</a></p><h2 id="阶段-1：Java-入门"><a href="#阶段-1：Java-入门" class="headerlink" title="阶段 1：Java 入门"></a>阶段 1：Java 入门</h2><p>目标<br>培养兴趣、快速上手</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>准备好一款在线、随时随地写代码的工具，不用在本地去安装和配置，是初学者的好帮手</p><p>推荐网站 - 菜鸟工具：<a href="https://c.runoob.com/compile/10">https://c.runoob.com/compile/10</a><br>准备一款记笔记的软件，学编程的过程中老师的思路、自己遇到的问题、解决问题的方法、心得感悟、遇到的好资料，都要记下来哦，好记性不如烂笔头，可以帮助你事半功倍。</p><p>推荐软件 Typora：<a href="https://www.typora.io/">https://www.typora.io/</a><br>推荐使用 Markdown 语法编写，鱼皮教程：<a href="https://www.bilibili.com/video/BV1no4y1k7YT/">https://www.bilibili.com/video/BV1no4y1k7YT/</a><br>想学好编程，别背代码，要多写，把这句话刻到脑子里。</p><p>选视频和找资料的小技巧：多看评论区、多看隔壁评论区，不要看过期的视频。</p><h2 id="Java-编程基础（45-天）"><a href="#Java-编程基础（45-天）" class="headerlink" title="Java 编程基础（45 天）"></a>Java 编程基础（45 天）</h2><h2 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h2><p>Java 特点（看不懂没事，别背！）</p><p>环境搭建</p><h4 id="Java-基础语法"><a href="#Java-基础语法" class="headerlink" title="Java 基础语法"></a>Java 基础语法</h4><p>数据类型<br>流程控制<br>数组</p><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>方法<br>重载<br>封装<br>继承<br>多态<br>抽象类</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>枚举</p><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><p>String<br>日期时间</p><h4 id="集合类"><a href="#集合类" class="headerlink" title="　集合类"></a>　集合类</h4><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><h4 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h4><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><h3 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h3><p>一定要持续学习，不能断！</p><p>跟着书上的例子敲代码后，自主编写代码，并完成课后练习。</p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>视频</p><blockquote><p>⭐ 韩顺平 - 零基础 30 天学会 Java：<a href="https://www.bilibili.com/video/BV1fh411y7R8（900">https://www.bilibili.com/video/BV1fh411y7R8（900</a> 多集，顺序安排很合理，每个知识真正的打碎了，通俗、有示例、有实战、有思想）<br>文档<br>⭐ 菜鸟教程：<a href="https://www.runoob.com/java/java-tutorial.html（可以在线练习）">https://www.runoob.com/java/java-tutorial.html（可以在线练习）</a><br>廖雪峰 Java 教程：<a href="https://www.liaoxuefeng.com/wiki/1252599548343744">https://www.liaoxuefeng.com/wiki/1252599548343744</a><br>书籍<br>《Head First Java》<br>在线游戏<br>Codegym：<a href="https://codegym.cc/zh（玩玩前几关培养兴趣不错，但后面收费了）">https://codegym.cc/zh（玩玩前几关培养兴趣不错，但后面收费了）</a></p></blockquote><h3 id="Java-8（3-天）"><a href="#Java-8（3-天）" class="headerlink" title="Java 8（3 天）"></a>Java 8（3 天）</h3><p>知识<br>Stream API<br>Lambda 表达式<br>新日期时间 API<br>接口默认方法</p><h3 id="资源-1"><a href="#资源-1" class="headerlink" title="资源"></a>资源</h3><blockquote><p>视频<br>⭐ 宋红康 - 全网最全Java零基础入门教程：<a href="https://www.bilibili.com/video/BV1Kb411W75N（只看">https://www.bilibili.com/video/BV1Kb411W75N（只看</a> Java 8 部分即可）<br>文&gt;档<br>⭐ 菜鸟教程：<a href="https://www.runoob.com/java/java8-new-features.html">https://www.runoob.com/java/java8-new-features.html</a><br>书籍<br>《Java 8 实战》<br>工具<br>⭐ 在线编写运行  Java 8：<a href="https://www.tutorialspoint.com/compile_java8_online.php">https://www.tutorialspoint.com/compile_java8_online.php</a><br>项目<br>Java 8 小代码片段：<a href="https://github.com/biezhi/30-seconds-of-java8">https://github.com/biezhi/30-seconds-of-java8</a><br>尾声</p></blockquote><h2 id="阶段-2：巩固基础"><a href="#阶段-2：巩固基础" class="headerlink" title="阶段 2：巩固基础"></a>阶段 2：巩固基础</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>想学好编程，计算机基础知识要学好。</p><p>比如算法，是程序员的灵魂。学好算法有助于我们理解程序、开拓思路，因此也是很多公司面试时考察的关键，在找工作前，还是要刷个上百道算法题目的。</p><p>我们这个阶段的目标是：熟练使用 Java 语言来编写程序，巩固 Java 的基础。</p><p>那直接用 Java 来写算法题目，一举两得，岂不美哉？</p><h3 id="Java-基础（30-天）"><a href="#Java-基础（30-天）" class="headerlink" title="Java 基础（30 天）"></a>Java 基础（30 天）</h3><p>学习建议<br>建议大家去阅读 《Java 核心技术卷 1》，这本书堪称经典，是帮助你复习巩固  Java 的不二之选，其中图形界面章节可以选择不看。</p><p>之后可以刷牛客的 Java 练习题，检验自己的水平，我当时刷了两遍。</p><p>资源</p><p>书籍</p><blockquote><p>⭐《Java 核心技术卷 1》<br>练习<br>⭐ 牛客题库：<a href="https://www.nowcoder.com/intelligentTest">https://www.nowcoder.com/intelligentTest</a></p></blockquote><h3 id="数据结构与算法-45"><a href="#数据结构与算法-45" class="headerlink" title="数据结构与算法(45)"></a>数据结构与算法(45)</h3><h4 id="知识-1"><a href="#知识-1" class="headerlink" title="知识"></a>知识</h4><p>时间 / 空间复杂度分析</p><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><blockquote><p>数组<br>字符串<br>队列<br>栈<br>链表<br>集合<br>哈希表<br>二叉树</p></blockquote><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><blockquote><p>排序<br>双指针<br>查找<br>分治<br>动态规划<br>递归<br>回溯<br>贪心<br>位运算<br>DFS<br>BFS<br>图</p></blockquote><h4 id="学习建议-1"><a href="#学习建议-1" class="headerlink" title="学习建议"></a>学习建议</h4><p>学算法一定要多思考、多练习！！！</p><p>在复习 Java、巩固基础的过程中，每天可以坚持用 Java 做 2 - 3 道算法题目。</p><p>不用担心看不懂，直接进入 LeetCode 学习板块 LeetBook，提供了免费的教程，文字、图解、动画讲算法、在线练习应有尽有，从 0 开始，跟着学习基础知识、跟着教程刷一些同类题目，培养算法思路。</p><p>之后再由简单到复杂、由通过率高到低，自主刷题，多看题解，举一反三。</p><p>有条件的朋友也可以试着参与竞赛，没什么门槛，可以帮助你集中精神，而且周赛的题目还是挺友好的~</p><p>资源</p><h4 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h4><blockquote><p>⭐ 刷了 1000 多道算法题，一点心得：<a href="https://t.1yb.co/oT9q（鱼皮原创）">https://t.1yb.co/oT9q（鱼皮原创）</a></p></blockquote><h4 id="在线教程"><a href="#在线教程" class="headerlink" title="在线教程"></a>在线教程</h4><blockquote><p>⭐ LeetCode LeetBook：<a href="https://leetcode-cn.com/leetbook/">https://leetcode-cn.com/leetbook/</a></p></blockquote><h4 id="在线刷题"><a href="#在线刷题" class="headerlink" title="在线刷题"></a>在线刷题</h4><blockquote><p>⭐ LeetCode：<a href="https://leetcode-cn.com/">https://leetcode-cn.com/</a></p></blockquote><h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><blockquote><p>⭐《小灰的漫画算法》<br>⭐《剑指 Offer》<br>《程序员代码面试指南》<br>图解算法数据结构：<a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/">https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/</a><br>LeetCode 101（C++）：<a href="https://github.com/changgyhub/leetcode_101">https://github.com/changgyhub/leetcode_101</a><br>LeetCode 题解（C++）：<a href="https://github.com/soulmachine/leetcode">https://github.com/soulmachine/leetcode</a><br>LeetCode Cookbook（Go 语言）：<a href="https://github.com/halfrost/LeetCode-Go">https://github.com/halfrost/LeetCode-Go</a><br>视频<br>尚硅谷 Java 数据结构与算法：<a href="https://www.bilibili.com/video/BV1E4411H73v（难度比面试的要求大一些，适合希望更全面学习的朋友）">https://www.bilibili.com/video/BV1E4411H73v（难度比面试的要求大一些，适合希望更全面学习的朋友）</a><br>Leetcode 真题解析：<a href="https://www.bilibili.com/video/BV1a54y1b74k">https://www.bilibili.com/video/BV1a54y1b74k</a><br>工具<br>VisuAlgo 数据结构和算法动态可视化：<a href="https://visualgo.net/zh">https://visualgo.net/zh</a><br>数据结构可视化：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a><br>网站<br>五分钟学算法：<a href="https://www.cxyxiaowu.com/">https://www.cxyxiaowu.com/</a></p></blockquote><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h3><h4 id="知识-2"><a href="#知识-2" class="headerlink" title="　知识"></a>　知识</h4><h5 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h5><blockquote><p>HTTP / HTTPS 协议<br>网络模型<br>UDP / TCP 协议<br>网络安全<br>域名解析<br>操作系统<br>进程、线程<br>进程 / 线程间通讯方式<br>进程调度算法<br>进程 / 线程状态<br>死锁<br>内存管理</p></blockquote><h4 id="学习建议-2"><a href="#学习建议-2" class="headerlink" title="学习建议"></a>学习建议</h4><p>在巩固基础期间，我建议大家多去了解计算机基础知识，比如操作系统、计算机网络。</p><p>但这一块知识说实话挺枯燥的，对吧，你说说我现在项目都不会做，你又让我看这些理论，是不是想让我头秃。</p><p>我的建议是，可以先看有趣的课外书，比如《图解 HTTP》等等，对基础知识先有个大致的印象，等后面有时间了再系统学习。</p><p>比如还在校园就跟着学校的进度学习就成，自学的话可以看下 《计算机网络微课堂》、 《清华操作系统原理》视频，有实力的小伙伴，能看懂大黑书就更好了。</p><h4 id="资源-2"><a href="#资源-2" class="headerlink" title="资源"></a>资源</h4><p>视频</p><blockquote><p>《计算机网络微课堂》：<a href="https://www.bilibili.com/video/BV1c4411d7jb">https://www.bilibili.com/video/BV1c4411d7jb</a><br>《清华操作系统原理》：<a href="https://www.bilibili.com/video/BV1uW411f72n">https://www.bilibili.com/video/BV1uW411f72n</a><br>书籍<br>⭐《图解 HTTP》<br>《网络是怎样连接的》<br>⭐《图解 TCP / IP》<br>《编码》<br>《30天自制操作系统》<br>《计算机网络-自顶向下方法》（难度较大，不推荐新手看）<br>《现代操作系统》（难度较大，不推荐新手看）<br>《深入理解计算机系统》（难度较大，不推荐新手看）</p></blockquote><p>尾声</p><blockquote><p>巩固基础要花至少 1 个月的时间，当你读完《Java 核心技术卷1》并且不用查询文档也能熟练地用 Java 做题时，就可以接着往下了。</p></blockquote><h2 id="阶段-3：Java-企业开发基础"><a href="#阶段-3：Java-企业开发基础" class="headerlink" title="阶段 3：Java 企业开发基础"></a>阶段 3：Java 企业开发基础</h2><p>目标<br>面向薪资编程，学习实际工作要用的技术，并能 独立 做出一个具有完整功能的 Java Web 项目。</p><h3 id="MySQL-数据库（7-天）"><a href="#MySQL-数据库（7-天）" class="headerlink" title="MySQL 数据库（7 天）"></a>MySQL 数据库（7 天）</h3><p>企业中大部分业务数据都是用关系型数据库存储的，因此数据库是后台开发同学的必备技能，其中 MySQL 数据库是目前的主流，也是面试时的重点。</p><h4 id="知识-3"><a href="#知识-3" class="headerlink" title="知识"></a>知识</h4><p>基本概念</p><blockquote><p>MySQL 搭建<br>SQL 语句编写<br>约束<br>索引<br>事务<br>设计数据库表<br>性能优化</p></blockquote><h4 id="学习建议-3"><a href="#学习建议-3" class="headerlink" title="学习建议"></a>学习建议</h4><p>其中，SQL 语句编写 和 设计数据库表 这两个能力一定要有！</p><p>比如让你做一个学生管理系统，你要能想到需要哪些表，比如学生表、班级表；每个表需要哪些字段、字段类型。</p><p>这就要求大家多写 SQL、多根据实际的业务场景去练习设计能力。</p><h4 id="资源-3"><a href="#资源-3" class="headerlink" title="资源"></a>资源</h4><p>视频</p><blockquote><p>⭐ 老杜 - mysql入门基础 + 数据库实战：<a href="https://www.bilibili.com/video/BV1Vy4y1z7EX（较新、内容相对精炼，有习题）">https://www.bilibili.com/video/BV1Vy4y1z7EX（较新、内容相对精炼，有习题）</a><br>尚硅谷 - MySQL基础教程：<a href="https://www.bilibili.com/video/BV1xW411u7ax（小姐姐讲课，但感觉音质一般）">https://www.bilibili.com/video/BV1xW411u7ax（小姐姐讲课，但感觉音质一般）</a><br>在线练习<br>⭐ SQL 自学网：<a href="http://xuesql.cn/">http://xuesql.cn/</a><br>⭐ SQL 在线运行：<a href="https://www.bejson.com/runcode/sql/">https://www.bejson.com/runcode/sql/</a><br>文档<br>SQL - 菜鸟教程：<a href="https://www.runoob.com/sql/sql-tutorial.html">https://www.runoob.com/sql/sql-tutorial.html</a><br>MySQL - 菜鸟教程：<a href="https://www.runoob.com/mysql/mysql-tutorial.html">https://www.runoob.com/mysql/mysql-tutorial.html</a></p></blockquote><h3 id="开发框架（60-天）"><a href="#开发框架（60-天）" class="headerlink" title="开发框架（60 天）"></a>开发框架（60 天）</h3><p>Java 之所以能成为主流的企业开发语言，很大一部分原因是它完善的框架生态，用好框架，不仅能够大大提升开发效率，还能提高项目的稳定性、减少维护成本。</p><p>开发框架是后台开发工作中不可或缺的，也是面试考察的重点，一定要好好学！</p><p>不知道 Java 能做什么的朋友们，学完开发框架，就会有答案啦。</p><p>下面给大家推荐的都是企业中应用最多的主流开发框架，知识点比较零碎，就放在一起讲了。</p><h4 id="知识-4"><a href="#知识-4" class="headerlink" title="知识"></a>知识</h4><p>Java Web<br>描述：Java 网页应用开发基础</p><p>前端基础</p><blockquote><p>XML<br>JSON<br>Servlet<br>Filter<br>Listener<br>JSP<br>JSTL<br>Cookie<br>Session</p></blockquote><p>Spring 5</p><blockquote><p>描述：Java 轻量级应用框架<br>IOC<br>AOP<br>事务</p></blockquote><h5 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h5><blockquote><p>描述：Java 轻量级 web 开发框架<br>什么是 MVC？<br>请求与响应<br>Restful API<br>拦截器<br>配置<br>执行过程</p></blockquote><h5 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h5><blockquote><p>描述：数据访问框架，操作数据库进行增删改查等操作<br>增删改查<br>全局配置<br>动态 SQL<br>缓存<br>和其他框架的整合<br>逆向工程</p></blockquote><h5 id="MyBatis-Plus"><a href="#MyBatis-Plus" class="headerlink" title="MyBatis Plus"></a>MyBatis Plus</h5><blockquote><p>描述：Mybatis 的增强工具，能够简化开发、提高效率<br>引入<br>通用 CRUD<br>条件构造器<br>代码生成器<br>插件扩展<br>自定义全局操作</p></blockquote><h5 id="SpringBoot-2"><a href="#SpringBoot-2" class="headerlink" title="SpringBoot 2"></a>SpringBoot 2</h5><blockquote><p>描述：简化 Spring 应用的初始搭建以及开发过程，提高效率<br>常用注解<br>资源整合<br>高级特性<br>本地热部署</p></blockquote><h5 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h5><blockquote><p>描述：Spring 的安全管理框架<br>用户认证<br>权限管理<br>Maven / Gradle<br>描述：项目管理工具<br>构建<br>依赖管理<br>插件<br>配置<br>子父工程</p></blockquote><p>学习建议<br>由于技术较多，且框架之间存在一定的联系，因此建议大家看同一系列的视频教程（尚硅谷、狂神说等等都可以），以保证学习内容的连续以及体验上的一致。</p><p>学这些技术的时候，千万不能懒 ！一定要多记笔记，并且跟着老师写代码。原理部分不要太过纠结，先以能跟着敲出代码、写出可运行的项目为主，有些东西做出来也能帮助你更好地理解理论。</p><p>学习顺序挺重要的，建议按我推荐的顺序学，不要一上手就学 SpringBoot。只有先学习下自己整合框架的方法，才能帮你理解 SpringBoot 解决的问题，感受到它的方便和高效。</p><p>Maven / Gradle 当工具用就好，面试基本不问，跟着框架教程去用就行了，先不用花太多时间去深入学。</p><h4 id="资源-4"><a href="#资源-4" class="headerlink" title="资源"></a>资源</h4><p>视频（按顺序看）</p><blockquote><p>⭐ 尚硅谷最新版 JavaWeb 全套教程：<a href="https://www.bilibili.com/video/BV1Y7411K7zz（前端部分最好也看下）">https://www.bilibili.com/video/BV1Y7411K7zz（前端部分最好也看下）</a><br>⭐ 尚硅谷 - Spring 5 框架最新版教程（idea版）：<a href="https://www.bilibili.com/video/BV1Vf4y127N5">https://www.bilibili.com/video/BV1Vf4y127N5</a><br>⭐ 尚硅谷 - SpringMVC 2021 最新教程：<a href="https://www.bilibili.com/video/BV1Ry4y1574R">https://www.bilibili.com/video/BV1Ry4y1574R</a><br>⭐ 尚硅谷 - MyBatis 实战教程全套完整版：<a href="https://www.bilibili.com/video/BV1mW411M737">https://www.bilibili.com/video/BV1mW411M737</a><br>⭐ 尚硅谷 - MyBatisPlus 教程：<a href="https://www.bilibili.com/video/BV1Ds411E76Y">https://www.bilibili.com/video/BV1Ds411E76Y</a><br>Maven 零基础入门教程：<a href="https://www.bilibili.com/video/BV1TW411g7hP（搞不懂">https://www.bilibili.com/video/BV1TW411g7hP（搞不懂</a> Maven 可以看看）<br>⭐ 雷丰阳 2021 版 SpringBoot2 零基础入门：<a href="https://www.bilibili.com/video/BV19K4y1L7MT">https://www.bilibili.com/video/BV19K4y1L7MT</a><br>尚硅谷 - SpringSecurity 框架教程：<a href="https://www.bilibili.com/video/BV15a411A7kP">https://www.bilibili.com/video/BV15a411A7kP</a></p></blockquote><h3 id="开发规范（3-天）"><a href="#开发规范（3-天）" class="headerlink" title="开发规范（3 天）"></a>开发规范（3 天）</h3><p>开发不规范，同事两行泪。</p><p>开发规范是团队开发中必须遵守的，有利于提高项目的开发效率、降低维护成本。</p><p>知识<br>代码规范<br>代码风格<br>命名<br>其他规则<br>提交规范<br>学习建议<br>简单过一遍大厂团队的规范手册就好了，以后做项目的时候能想起来的话就去使用，或者从书中、网上查规范，再去遵守。</p><p>项目做得多了，自然会养成好的习惯，不用刻意去记（毕竟每个团队规范也不完全相同，背了也没用）。</p><p>资源<br>书籍</p><p>⭐ 阿里巴巴 Java 开发手册：<a href="https://developer.aliyun.com/graph/java（搜索《Java开发手册》）">https://developer.aliyun.com/graph/java（搜索《Java开发手册》）</a><br>视频</p><p>华山版《Java开发手册》独家讲解：<a href="https://developer.aliyun.com/live/1201">https://developer.aliyun.com/live/1201</a><br>文档</p><p>Google Java Style Guide：<a href="https://google.github.io/styleguide/javaguide.html（谷歌">https://google.github.io/styleguide/javaguide.html（谷歌</a> Java 代码规范）</p><h3 id="Git（3-天）"><a href="#Git（3-天）" class="headerlink" title="Git（3 天）"></a>Git（3 天）</h3><p>此前大家可能听说过 GitHub，一流的代码开源托管平台。</p><p>Git 和它可不一样，是一个版本控制工具，可以更好地管理和共享项目代码，比如把自己的代码传到 GitHub 上、或者从远程下载。</p><p>无论自己做项目、还是团队开发，Git 都是现在不可或缺的神器。</p><p>知识<br>工作区<br>分支<br>代码提交、推送、拉取、回退、重置<br>分支操作<br>代码合并、解决冲突<br>标签<br>cherry-pick<br>学习建议<br>每个命令跟着敲一遍，有个大致的印象，会用即可，用的多了自然熟悉了。</p><p>资源<br>视频</p><p>⭐【尚硅谷】5h打通Git全套教程丨2021最新IDEA版 <a href="https://www.bilibili.com/video/BV1vy4y1s7k6">https://www.bilibili.com/video/BV1vy4y1s7k6</a><br>书籍</p><p>猴子都能懂的 Git 入门 <a href="https://backlog.com/git-tutorial/cn/">https://backlog.com/git-tutorial/cn/</a><br>⭐ GitHub 漫游指南 <a href="https://github.phodal.com/">https://github.phodal.com/</a><br>文档</p><p>GitHub 官方文档：<a href="https://docs.github.com/cn">https://docs.github.com/cn</a><br>游戏</p><p>Learning Git Branching：<a href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p><h3 id="Linux（10-天）"><a href="#Linux（10-天）" class="headerlink" title="Linux（10 天）"></a>Linux（10 天）</h3><p>企业中的很多前后台项目都是部署在 Linux 服务器上的，因此很有必要熟悉 Linux 的操作和脚本的编写。</p><p>后面学微服务、学架构都是在多台服务器操作，如果你不熟悉 Linux，会有点吃力。</p><p>知识<br>Linux 系统安装<br>环境变量<br>文件管理<br>用户管理<br>内存管理<br>磁盘管理<br>进程管理<br>网络管理<br>软件包管理<br>服务管理<br>日志管理<br>Linux 内核<br>常用命令<br>常用环境搭建<br>Shell 脚本编程<br>VIM 的使用<br>学习建议<br>多动手实践，建议自己购买一台云服务器，并且在本地搭建 Linux 虚拟机环境。</p><p>一定要自己从 0 开始手敲命令安装软件、部署服务，熟悉整个项目的上线流程。</p><p>每个命令至少要跟着敲一遍，了解它们的作用，并通过自然地练习，熟悉常用的 Linux 命令。</p><p>记不住没关系，用文档查就行了。</p><p>先会用，再理解。</p><p>资源<br>视频</p><p>⭐ 2021 韩顺平 一周学会Linux <a href="https://www.bilibili.com/video/BV1Sv411r7vd（基于">https://www.bilibili.com/video/BV1Sv411r7vd（基于</a> CentOS 7.6 版本较新）<br>书籍</p><p>《鸟哥的 Linux 私房菜 —— 基础篇》<a href="http://cn.linux.vbird.org/linux_basic/linux_basic.php（经典）">http://cn.linux.vbird.org/linux_basic/linux_basic.php（经典）</a><br>文档</p><p>Linux 工具快速教程：<a href="https://linuxtools-rst.readthedocs.io（基础、工具进阶、工具参考）">https://linuxtools-rst.readthedocs.io（基础、工具进阶、工具参考）</a><br>实战</p><p>⭐ 蓝桥云课 Linux 基础入门：<a href="https://www.lanqiao.cn/courses/1">https://www.lanqiao.cn/courses/1</a><br>腾讯云动手实验室：<a href="https://cloud.tencent.com/developer/labs">https://cloud.tencent.com/developer/labs</a><br>阿里云体验实验室：<a href="https://developer.aliyun.com/adc/labs/">https://developer.aliyun.com/adc/labs/</a><br>阿里云知行实验室：<a href="https://start.aliyun.com/">https://start.aliyun.com/</a><br>华为云沙箱实验室：<a href="https://lab.huaweicloud.com/">https://lab.huaweicloud.com/</a><br>社区</p><p>Linux 中国：<a href="https://linux.cn/">https://linux.cn/</a><br>工具</p><p>⭐ Linux 命令搜索：<a href="https://wangchujiang.com/linux-command">https://wangchujiang.com/linux-command</a><br>Linux 命令大全手册：<a href="https://www.linuxcool.com/">https://www.linuxcool.com/</a><br>Linux 命令示例：<a href="http://linux-commands-examples.com/">http://linux-commands-examples.com/</a><br>宝塔 Linux 面板：<a href="https://www.bt.cn/">https://www.bt.cn/</a></p><h3 id="前端基础（14-天）"><a href="#前端基础（14-天）" class="headerlink" title="前端基础（14 天）"></a>前端基础（14 天）</h3><p>虽然 Java 程序员面试时基本不会出现前端相关问题，但是在企业中，往往需要前后端程序员配合完成工作。会一些前端，不仅可以提高你们的协作效率，还能提高自己对整个项目的了解和掌控力，甚至能独立开发出一个完整项目！这点也是能给面试加分的。</p><p>知识<br>HTML<br>CSS<br>JavaScript<br>Ajax<br>Vue<br>学习建议<br>不需要学习太多的前端技术，熟悉下基础的前端三件套，了解前端是如何向后端发送请求来做数据交互的一般就够了。有时间的话可以学下 Vue ，是比较容易上手的主流前端开发框架，Vue + SpringBoot 还是很香的。</p><p>资源<br>参见鱼皮原创的前端学习路线：<a href="https://mp.weixin.qq.com/s/HbzLEt6NOP9Is9F3GOnbUQ">https://mp.weixin.qq.com/s/HbzLEt6NOP9Is9F3GOnbUQ</a></p><h2 id="阶段-4：Java-企业开发进阶"><a href="#阶段-4：Java-企业开发进阶" class="headerlink" title="阶段 4：Java 企业开发进阶"></a>阶段 4：Java 企业开发进阶</h2><p>目标<br>学习更多企业级开发技术和编程思想，能够结合多种技术，独立开发出架构合理的完整系统，解决实际问题 。</p><p>要了解为什么需要这个技术？什么时候用哪些技术？</p><h3 id="设计模式（21-天）"><a href="#设计模式（21-天）" class="headerlink" title="设计模式（21 天）"></a>设计模式（21 天）</h3><p>设计模式是软件开发中解决一类问题的通用方法。</p><p>使用设计模式能让你写出更优雅、可维护的代码，也正因如此，很多框架源码都用到了设计模式，你不学很难看懂。</p><p>知识<br>创建型模式：对象实例化的模式，创建型模式用于解耦对象的实例化过程</p><p>单例模式<br>工厂方法模式<br>抽象工厂<br>建造者模式<br>原型模式<br>结构型模式：把类或对象结合在一起形成一个更大的结构</p><p>适配器模式<br>组合模式<br>装饰器模式<br>代理模式<br>享元模式<br>外观模式<br>桥接模式<br>行为型模式：类和对象如何交互，及划分责任和算法</p><p>迭代器模式<br>模板方法模式<br>策略模式<br>命令模式<br>状态模式<br>责任链模式<br>备忘录模式<br>观察者模式<br>访问者模式<br>中介者模式<br>解释器模式<br>学习建议<br>先理解概念，了解每个设计模式的特点和应用场景，再多加练习，运用到实际项目。</p><p>资源<br>书籍</p><p>⭐《图解设计模式》（强烈推荐这本书，正是用 Java 语言实现，图多、有示例代码、有习题和答案，很不错）</p><p>《Head First 设计模式》</p><p>《大话设计模式》</p><p>《设计模式：可复用面向对象软件的基础》（大黑书，有能力的话也可以去读）</p><p>视频</p><p>尚硅谷图解 Java 设计模式：<a href="https://www.bilibili.com/video/BV1G4411c7N4">https://www.bilibili.com/video/BV1G4411c7N4</a><br>文档</p><p>菜鸟教程：<a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a><br>图说设计模式：<a href="https://design-patterns.readthedocs.io/zh_CN/latest/">https://design-patterns.readthedocs.io/zh_CN/latest/</a></p><h3 id="中间件（14-天）"><a href="#中间件（14-天）" class="headerlink" title="中间件（14 天）"></a>中间件（14 天）</h3><p>除了框架外，企业项目开发也会用到大量独立的中间件，以解决某些实际问题，比如提高项目的性能、提高项目的稳定性和可靠性等。</p><p>下面分享几个最常用的主流中间件。</p><p>知识<br>Redis 缓存<br>数据类型</p><p>常用操作</p><p>Java 操作 Redis</p><p>主从模型搭建</p><p>哨兵集群搭建</p><p>日志持久化</p><p>应用场景</p><p>RabbitMQ 消息队列<br>消息队列的作用</p><p>生产消费模型</p><p>交换机模型</p><p>死信队列</p><p>延迟队列</p><p>消息持久化</p><p>Java 操作</p><p>集群搭建</p><p>Nginx 网关<br>Nginx 作用</p><p>正向代理</p><p>反向代理（负载均衡）</p><p>常用命令</p><p>配置</p><p>动静分离（网站部署）</p><p>集群搭建</p><p>学习建议<br>学会如何使用中间件并不难，先能够独立使用，了解他们的应用场景；再用 Java 来操作中间件，和项目相结合。</p><p>跟着视频教程实操一遍即可，可以等到面试前再去深入了解原理和高级特性。</p><p>资源<br>视频</p><p>⭐ 尚硅谷 - 2021 最新 Redis 6 入门到精通教程：<a href="https://www.bilibili.com/video/BV1Rv41177Af（基于">https://www.bilibili.com/video/BV1Rv41177Af（基于</a> Redis 6 的，推荐）<br>⭐ 尚硅谷 - 2021 最新 RabbitMQ 教程：<a href="https://www.bilibili.com/video/BV1cb4y1o7zz（很新很全面）">https://www.bilibili.com/video/BV1cb4y1o7zz（很新很全面）</a><br>⭐ 尚硅谷 - Nginx 教程由浅入深：<a href="https://www.bilibili.com/video/BV1zJ411w7SV（讲的比较全面）">https://www.bilibili.com/video/BV1zJ411w7SV（讲的比较全面）</a><br>⭐ Nginx 鱼皮 - 手把手带你从0搭建个人网站：<a href="https://www.bilibili.com/video/BV1rU4y1J785/">https://www.bilibili.com/video/BV1rU4y1J785/</a> （简单演示 Nginx 部署网站）<br>文档</p><p>Redis 命令参考：<a href="http://redisdoc.com/">http://redisdoc.com/</a><br>Redis 面试题整理：<a href="https://github.com/lokles/Web-Development-Interview-With-Java/blob/main/Redis%E9%97%AE%E9%A2%98.md">https://github.com/lokles/Web-Development-Interview-With-Java/blob/main/Redis%E9%97%AE%E9%A2%98.md</a><br>RabbitMQ 中文文档：<a href="http://rabbitmq.mr-ping.com/">http://rabbitmq.mr-ping.com/</a><br>Nginx 中文文档：<a href="https://www.nginx.cn/doc/index.html">https://www.nginx.cn/doc/index.html</a><br>书籍</p><p>《Redis 实战》（经典）<br>《RabbitMQ 实战：高效部署分布式消息队列》（经典）<br>工具</p><p>⭐ Redis 在线练习：<a href="https://try.redis.io/（强烈推荐）">https://try.redis.io/（强烈推荐）</a><br>⭐ RabbitMQ 在线模拟器：<a href="http://tryrabbitmq.com/">http://tryrabbitmq.com/</a><br>Nginx 配置在线生成：<a href="https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN">https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN</a><br>相关技术</p><p>缓存：Memcached、Ehcache<br>队列：Kafka、ActiveMQ、TubeMQ、RocketMQ<br>网关：HAProxy</p><h3 id="Netty-网络编程（14-天）"><a href="#Netty-网络编程（14-天）" class="headerlink" title="Netty 网络编程（14 天）"></a>Netty 网络编程（14 天）</h3><p>开源的 Java 网络编程框架，用于开发高性能（事件驱动、异步非阻塞）、高可靠的网络服务器和客户端程序。</p><p>很多网络框架和服务器程序都用到了 Netty 作为底层，学好 Netty 不仅可以让我们自己实现高性能服务器，也能更好地理解其他的框架应用、阅读源码。</p><p>知识<br>IO 模型（BIO / NIO）<br>Channel<br>Buffer<br>Seletor<br>Netty 模型<br>WebSocket 编程（动手做个聊天室）<br>学习建议<br>不同于之前学的 SSM 框架，Netty 还是需要一定学习成本的，一方面是国内资源太缺乏，另一方面很多重要的概念（比如 NIO）还是要多动手写代码调试才能理解。</p><p>还是建议先从视频入门，并且不建议在 Netty 上花太多时间，面试的时候一般也就考察一些 Netty 思想。</p><p>资源<br>视频</p><p>⭐ 尚硅谷Netty教程：<a href="https://www.bilibili.com/video/BV1DJ411m7NR">https://www.bilibili.com/video/BV1DJ411m7NR</a></p><p>Netty 技术演讲（中文字幕版）：<a href="https://www.youtube.com/watch?v=I8yy2Cy7dDI">https://www.youtube.com/watch?v=I8yy2Cy7dDI</a></p><p>文档</p><p>Netty 4 用户指南：<a href="https://www.w3cschool.cn/netty_4_user_guide/">https://www.w3cschool.cn/netty_4_user_guide/</a><br>书籍</p><p>《Netty 实战》<br>相关技术</p><p>Vertx：<a href="http://vertxchina.github.io/vertx-translation-chinese/（比">http://vertxchina.github.io/vertx-translation-chinese/（比</a> Netty 简单多了，实在看不懂 Netty 也可以学习下这个）</p><h3 id="微服务（60-天）"><a href="#微服务（60-天）" class="headerlink" title="微服务（60 天）"></a>微服务（60 天）</h3><p>随着互联网的发展，项目越来越复杂，单机且庞大的巨石项目已无法满足开发、运维、并发、可靠性等需求。</p><p>因此，后台架构不断演进，可以将庞大的项目拆分成一个个职责明确、功能独立的细小模块，模块可以部署在多台服务器上，相互配合协作，提供完整的系统能力。</p><p>换言之，想做大型项目，这块儿一定要好好学！</p><p>知识<br>Dubbo<br>架构演进<br>RPC<br>Zookeeper<br>服务提供者<br>服务消费者<br>项目搭建<br>微服务<br>微服务概念<br>Spring Cloud 框架<br>子父工程<br>服务注册与发现<br>注册中心 Eureka、Zookeeper、Consul<br>Ribbon 负载均衡<br>Feign 服务调用<br>Hystrix 服务限流、降级、熔断<br>Resilience4j 服务容错<br>Gateway（Zuul）微服务网关<br>Config 分布式配置中心<br>分布式服务总线<br>分布式链路追踪<br>Spring Cloud Alibaba<br>Nacos 注册、配置中心<br>OpenFeign 服务调用<br>Sentinel 流控<br>Seata 分布式事务<br>接口管理<br>Swagger 接口文档<br>Postman 接口测试<br>学习建议<br>时间不急的话，建议先从 Dubbo 学起，对分布式、RPC、微服务有些基本的了解，再去食用 Spring Cloud 全家桶会更香。</p><p>这部分内容的学习，原理 + 实践都很重要，也不要被各种高大上的词汇唬住了，都是上层（应用层）的东西，基本没有什么算法，跟着视频教程学，其实还是很好理解的。</p><p>分布式相关知识非常多，但这里不用刻意去背，先通过视频教程实战使用一些微服务框架，也能对其中的概念有基本的了解。</p><p>资源<br>视频</p><p>⭐ 尚硅谷 Dubbo 教程：<a href="https://www.bilibili.com/video/BV1ns411c7jV">https://www.bilibili.com/video/BV1ns411c7jV</a></p><p>⭐ 尚硅谷 SpringCloud（H版&amp;alibaba）框架开发教程（微服务分布式架构）：<a href="https://www.bilibili.com/video/BV18E411x7eT（把国外的">https://www.bilibili.com/video/BV18E411x7eT（把国外的</a> Spring Cloud 和国内的 Spring Cloud Alibaba 结合在一起对比着去讲，主流技术栈、知识点都讲到了，真心不错！）</p><p>文档</p><p>Apache Dubbo 官方文档：<a href="https://dubbo.apache.org/zh/">https://dubbo.apache.org/zh/</a><br>Spring Cloud Alibaba 官方文档：<a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md">https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</a><br>⭐ Swagger 教学文档：<a href="https://doc.xiaominfo.com/（跟着快速开始直接用就好了）">https://doc.xiaominfo.com/（跟着快速开始直接用就好了）</a></p><h3 id="容器（7-天）"><a href="#容器（7-天）" class="headerlink" title="容器（7 天）"></a>容器（7 天）</h3><p>将应用和环境进行封装，相互隔离、独立部署、便于移植，提高安全性、提高开发和维护效率。</p><p>便于实现微服务、持续集成和交付。</p><p>知识<br>Docker<br>容器概念<br>镜像<br>部署服务<br>Dockerfile<br>K8S（Kubernetes）<br>架构<br>部署应用<br>暴露服务<br>动态扩缩容<br>学习建议<br>会用 Docker / K8S 部署项目和服务就行，企业一般都有现成的平台直接用，面试考察不多，不用花太多时间。</p><p>资源<br>视频</p><p>⭐【狂神说】Docker 最新超详细版教程通俗易懂：<a href="https://www.bilibili.com/video/BV1og4y1q7M4">https://www.bilibili.com/video/BV1og4y1q7M4</a><br>K8S 视频教程：<a href="https://www.bilibili.com/video/BV1K5411N7j8">https://www.bilibili.com/video/BV1K5411N7j8</a><br>书籍</p><p>《深入浅出 Docker》：<a href="https://www.zhihu.com/pub/reader/119632192">https://www.zhihu.com/pub/reader/119632192</a><br>文档</p><p>Docker — 从入门到实践：<a href="https://vuepress.mirror.docker-practice.com/">https://vuepress.mirror.docker-practice.com/</a><br>菜鸟教程 Docker：<a href="https://www.runoob.com/docker/docker-tutorial.html">https://www.runoob.com/docker/docker-tutorial.html</a><br>国外 Docker 官方文档：<a href="https://docs.docker.com/get-started/">https://docs.docker.com/get-started/</a><br>网站</p><p>Docker 中文社区：<a href="https://www.docker.org.cn/（强烈推荐，有很多">https://www.docker.org.cn/（强烈推荐，有很多</a> Docker 技术文章和学习笔记）<br>Docker Blog：<a href="https://www.docker.com/blog/（国外">https://www.docker.com/blog/（国外</a> Docker 技术博客）<br>镜像源</p><p>Docker Hub：<a href="https://hub.docker.com">https://hub.docker.com</a><br>腾讯软件源：<a href="http://mirrors.tencent.com/#/index">http://mirrors.tencent.com/#/index</a><br>阿里云 Docker 仓库：<a href="https://cr.console.aliyun.com/">https://cr.console.aliyun.com/</a></p><h3 id="CI-CD（3-天）"><a href="#CI-CD（3-天）" class="headerlink" title="CI / CD（3 天）"></a>CI / CD（3 天）</h3><p>持续集成 / 持续交付，贯穿整个研发到项目上线的过程，提高效率。</p><p>大公司一般都有自己的 CI / CD 平台。</p><p>知识<br>什么是 CI / CD</p><p>CI / CD 有什么好处</p><p>使用任一 CI / CD 平台</p><p>学习建议<br>了解它是什么，并且实战使用任一 CI / CD 平台，感受它和传统开发运维到底有什么不同，就足够了。其实很简单，不要花太多时间。</p><p>真正要自己去搭建的时候，跟着官方文档来就行。</p><p>资源<br>视频</p><p>⭐【狂神说】CI/CD到底是什么？十分钟理解企业级DevOps：<a href="https://www.bilibili.com/video/BV1zf4y127vu（讲的非常棒！带你快速理解">https://www.bilibili.com/video/BV1zf4y127vu（讲的非常棒！带你快速理解</a> CI / CD 的作用和部分原理）</p><p>尚硅谷 - Jenkins 持续集成工具教程：<a href="https://www.bilibili.com/video/BV1GW411w7pn（实在要用到">https://www.bilibili.com/video/BV1GW411w7pn（实在要用到</a> Jenkins 再去学）</p><p>文档</p><p>Jenkins 官方文档：<a href="https://www.jenkins.io/zh/">https://www.jenkins.io/zh/</a> （有很多案例，要用的时候查一下就行了）<br>实战平台</p><p>⭐ 微信云托管：<a href="https://cloud.weixin.qq.com/cloudrun（直播演示过，鱼皮后面会给大家出视频教程）">https://cloud.weixin.qq.com/cloudrun（直播演示过，鱼皮后面会给大家出视频教程）</a></p><p>前端托管 Webify：<a href="https://cloud.tencent.com/product/webify（鱼皮给大家出过视频教程的">https://cloud.tencent.com/product/webify（鱼皮给大家出过视频教程的</a> <a href="https://www.bilibili.com/video/BV11V411p7vf/）">https://www.bilibili.com/video/BV11V411p7vf/）</a></p><h2 id="阶段-5：项目实战"><a href="#阶段-5：项目实战" class="headerlink" title="阶段 5：项目实战"></a>阶段 5：项目实战</h2><p>目标<br>综合所学技术从 0 到 1 开发和上线一个全面、有特色的、可以写进简历的个人项目。</p><p>学习建议<br>其实在之前的框架学习视频中应该就做过几个项目了，但相对不够完整和体系化。</p><p>有想法的同学可以做任何自己想做的项目，推荐参加一些作品类竞赛，练手、拿奖、收获项目经历一举三得。</p><p>暂时没想法的朋友，建议先跟着专门带做项目的视频教程做 1 - 2 套 Java 完整项目，一定要从 0 到 1 自己手写！</p><p>有能力的朋友也可以试着用 GitHub 上的源码来学习啦~</p><p>做一个完整的项目的确很不容易，建议大家根据自己的 时间、兴趣 选择 较新的、有配套源码的 教程，保持耐心。</p><p>如何选择编程学习资源，可以看下我的原创文章：<a href="https://mp.weixin.qq.com/s/mlMql9RJCd7THt6rpGb8UA">https://mp.weixin.qq.com/s/mlMql9RJCd7THt6rpGb8UA</a></p><p>下面推荐一些优质的、较新的项目实战视频教程 + 50 套项目源码。</p><p>视频教程<br>尚硅谷 - 谷粒学院 - 微服务 + 全栈 - 在线教育实战项目：<a href="https://www.bilibili.com/video/BV1dQ4y1A75e（全栈项目，前后端讲得都很全面）">https://www.bilibili.com/video/BV1dQ4y1A75e（全栈项目，前后端讲得都很全面）</a></p><p>尚硅谷 - 尚筹网 - Java项目实战开发教程 - SSM 框架 + 微服务架构：<a href="https://www.bilibili.com/video/BV1bE411T7oZ（500">https://www.bilibili.com/video/BV1bE411T7oZ（500</a> 多集，包含完整的用户权限管理，功能丰富、讲得很细致全面）</p><p>黑马 - 24 小时搞定 Java 毕设电商项目：<a href="https://www.bilibili.com/video/BV13f4y1r7fS">https://www.bilibili.com/video/BV13f4y1r7fS</a></p><p>黑马程序员 Java 项目《传智健康》，超完整的企业级医疗行业项目：<a href="https://www.bilibili.com/video/BV1Bo4y117zV">https://www.bilibili.com/video/BV1Bo4y117zV</a></p><p>黑马程序员 Java 项目《万信金融》企业级开发实战，互联网金融行业解决方案：<a href="https://www.bilibili.com/video/BV1Ub4y1f7rk">https://www.bilibili.com/video/BV1Ub4y1f7rk</a></p><p>黑马程序员 Java 项目 SaaS 移动办公完整版《iHRM 人力资源管理系统》，跨行业 SaaS 办公整合性解决方案：<a href="https://www.bilibili.com/video/BV18A411L7UX">https://www.bilibili.com/video/BV18A411L7UX</a></p><p>黑马程序员 Java 大型分布式微服务闪聚支付项目，Java 移动支付全生态系统：<a href="https://www.bilibili.com/video/BV17v411V79c">https://www.bilibili.com/video/BV17v411V79c</a></p><p>黑马程序员 Java 项目《好客租房》：<a href="https://www.bilibili.com/video/BV1sZ4y1F7PD">https://www.bilibili.com/video/BV1sZ4y1F7PD</a></p><p>项目源码（50 套）<br>电商秒杀<br>天猫整站 J2EE：<a href="https://how2j.cn/module/115.htm">https://how2j.cn/module/115.htm</a></p><p>天猫整站 SSM：<a href="https://how2j.cn/module/134.html">https://how2j.cn/module/134.html</a></p><p>天猫整站 Springboot：<a href="https://how2j.cn/module/156.html">https://how2j.cn/module/156.html</a></p><p>mall-learning：<a href="https://github.com/macrozheng/mall-learningmall（学习教程，架构、业务、技术要点全方位解析）">https://github.com/macrozheng/mall-learningmall（学习教程，架构、业务、技术要点全方位解析）</a></p><p>SpringBoot 电商商城系统 Mall4j：<a href="https://github.com/gz-yami/mall4j">https://github.com/gz-yami/mall4j</a></p><p>SpringBoot 完整电商系统 Mall：<a href="https://github.com/macrozheng/mall（包括前台商城系统及后台管理系统，基于">https://github.com/macrozheng/mall（包括前台商城系统及后台管理系统，基于</a> SpringBoot+MyBatis 实现）</p><p>newbee-mall：<a href="https://github.com/newbee-ltd/newbee-mall">https://github.com/newbee-ltd/newbee-mall</a> （一套电商系统，包括 newbee-mall 商城系统及 newbee-mall-admin 商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发）</p><p>paascloud-master：<a href="https://github.com/paascloud/paascloud-master（基于">https://github.com/paascloud/paascloud-master（基于</a> spring cloud + vue + oAuth2.0，前后端分离商城系统）</p><p>mall-swarm：<a href="https://github.com/macrozheng/mall-swarm（一套微服务商城系统，采用了">https://github.com/macrozheng/mall-swarm（一套微服务商城系统，采用了</a> Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台方便快速搭建系统）</p><p>onemall：<a href="https://github.com/YunaiV/onemall（mall">https://github.com/YunaiV/onemall（mall</a> 商城，基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba）</p><p>litemall：<a href="https://github.com/linlinjava/litemall（又一个小商城，litemall">https://github.com/linlinjava/litemall（又一个小商城，litemall</a> = Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端）</p><p>xmall：<a href="https://github.com/Exrick/xmall">https://github.com/Exrick/xmall</a> （基于SOA架构的分布式电商购物商城 前后端分离 前台商城:Vue全家桶 后台管理系统）</p><p>miaosha：<a href="https://github.com/qiurunze123/miaosha">https://github.com/qiurunze123/miaosha</a> （秒杀系统设计与实现）</p><p>SecKill：<a href="https://github.com/hfbin/Seckill（基于">https://github.com/hfbin/Seckill（基于</a> SpringBoot+Mybatis+Redis+RabbitMQ 秒杀系统）</p><p>博客论坛<br>Mblog：开源 Java 博客系统</p><p>halo：一个优秀的开源博客发布应用</p><p>forum-java：一款用 Java（spring boot） 实现的现代化社区（论坛/问答/BBS/社交网络/博客）系统平台</p><p>vhr：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。</p><p>favorites-web:云收藏 Spring Boot 2.X 开源项目。云收藏是一个使用 Spring Boot 构建的开源网站，可以让用户在线随时随地收藏的一个网站，在网站上分类整理收藏的网站或者文章。</p><p>community：码问，开源论坛、问答系统，现有功能提问、回复、通知、最新、最热、消除零回复功能。技术栈 Spring、Spring Boot、MyBatis、MySQL/H2、Bootstrap</p><p>NiterForum：尼特社区-NiterForum-一个论坛/社区程序。后端Springboot/MyBatis/Maven/MySQL，前端Thymeleaf/Layui。可供初学者，学习、交流使用。</p><p>VBlog：V部落，Vue+SpringBoot实现的多用户博客管理平台!</p><p>NiceFish：SpringBoot/SpringCloud 前后端分离项目</p><p>My-Blog：My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验。</p><p>My-Blog-layui：layui 版本的 My-Blog : A simple &amp; beautiful blogging system implemented with spring-boot &amp; layui &amp; thymeleaf &amp; mybatis My Blog 是由  SpringBoot + Layui + Mybatis + Thymeleaf 等技术实现的 Java  博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验</p><p>symphony：Java 实现的现代化社区</p><p>管理系统<br>Spring-Cloud-Admin：Cloud-Admin 是国内首个基于 Spring Cloud 微服务化开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关 API 管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。核心技术采用 Spring Boot2 以及 Spring Cloud Gateway 相关核心组件，前端采用 vue-element-admin 组件。</p><p>bootshiro：基于 springboot+shiro+jwt 的资源无状态认证权限管理系统后端</p><p>悟空CRM：基于jfinal+vue+ElementUI的前后端分离CRM系统</p><p>EL-ADMIN：基于 SpringBoot 的后台管理系统</p><p>pig：基于 Spring Boot 2.2、 Spring Cloud Hoxton &amp; Alibaba、 OAuth2 的 RBAC 权限管理系统。</p><p>FEBS-Shiro：Spring Boot 2.1.3，Shiro1.4.0 &amp; Layui 2.5.4 权限管理系统。</p><p>Spring Boot-Shiro-Vue：基于Spring Boot-Shiro-Vue 的权限管理</p><p>studentmanager：基于springboot+mybatis学生管理系统</p><p>jshERP：华夏ERP基于SpringBoot框架和SaaS模式，立志为中小企业提供开源好用的ERP软件，目前专注进销存+财务功能。主要模块有零售管理、采购管理、销售管理、仓库管理、财务管理、报表查询、系统管理等。支持预付款、收入支出、仓库调拨、组装拆卸、订单等特色功能。拥有库存状况、出入库统计等报表。同时对角色和权限进行了细致全面控制，精确到每个按钮和菜单。</p><p>HotelSystem：酒店管理系统 Java,tomcat,mysql,servlet,jsp实现，没有使用任何框架</p><h4 id="开发平台"><a href="#开发平台" class="headerlink" title="开发平台"></a>开发平台</h4><p>open-capacity-platform：微服务能力开发平台<br>jeecg-boot：JeecgBoot是一款基于BPM的低代码平台！前后端分离架构 SpringBoot 2.x，SpringCloud，Ant  Design&amp;Vue，Mybatis-plus，Shiro，JWT，支持微服务。强大的代码生成器让前后端代码一键生成，实现低代码开发！<br>其他<br>学之思在线考试系统：一款 java + vue 的前后端分离的考试系统</p><p>PassJava-Platform：一款面试刷题的 Spring Cloud 开源系统</p><p>kkFileView：使用spring boot打造文件文档在线预览项目</p><p>dynamic-datasource：一个基于springboot的快速集成多数据源的启动器</p><p>moti-cloud：莫提网盘，基于 SpringBoot+MyBatis+ThymeLeaf+BootStrap，适合初学者</p><p>threadandjuc：three-high-import 高可用\高可靠\高性能，三高多线程导入系统（该项目意义为理论贯通)</p><p>proxyee-down：http下载工具，基于http代理，支持多连接分块下载</p><p>hosp_order：医院预约挂号系统，基于 SSM 框架</p><p>趋势投资 SpringCloud</p><p>DiyTomcat</p><h2 id="阶段-6：Java-高级"><a href="#阶段-6：Java-高级" class="headerlink" title="阶段 6：Java 高级"></a>阶段 6：Java 高级</h2><p>目标<br>不满足于能做，而是通过更 深入 和 广泛 的学习，实现高质量的代码和更优秀的架构，培养解决问题的能力。</p><h3 id="并发编程（21-天）"><a href="#并发编程（21-天）" class="headerlink" title="并发编程（21 天）"></a>并发编程（21 天）</h3><p>对 Java 后端开发程序员来说，懂得如何利用有限的系统资源来提高系统的性能是很重要的，也是大厂面试考察的重点，因此并发编程（尤其是 Java 并发包的使用）这块的知识很重要。</p><p>把它放到高级，是因为在学并发编程前，需要有一定的编程经验、了解一定的操作系统知识。</p><p>知识<br>线程和进程<br>线程状态<br>并行和并发<br>同步和异步<br>Synchronized<br>Volatile 关键字<br>Lock 锁<br>死锁<br>可重入锁<br>线程安全<br>线程池<br>JUC 的使用<br>AQS<br>Fork Join<br>CAS<br>学习建议<br>并发编程入门不难，依然是 先学会使用 基础的 Java 并发包， 再通过大量地实践和测试，了解一些原理，才能真正掌握何时使用、如何更合理地使用并发编程。</p><p>资源<br>视频</p><p>⭐【尚硅谷】大厂必备技术之JUC并发编程2021最新版：<a href="https://www.bilibili.com/video/BV1Kw411Z7dF（特点是短、精、新）">https://www.bilibili.com/video/BV1Kw411Z7dF（特点是短、精、新）</a><br>黑马程序员全面深入学习Java并发编程：<a href="https://www.bilibili.com/video/BV16J411h7Rd（讲的很细、全面深入）">https://www.bilibili.com/video/BV16J411h7Rd（讲的很细、全面深入）</a><br>书籍</p><p>⭐《Java并发编程实战》（国外的经典）<br>⭐《Java 并发编程艺术》（国人写的，理论思想内容较多，有时间建议反复看）<br>项目</p><p>⭐ Java 并发知识点总结：<a href="https://github.com/CL0610/Java-concurrency">https://github.com/CL0610/Java-concurrency</a></p><h3 id="JVM（30-天）"><a href="#JVM（30-天）" class="headerlink" title="JVM（30 天）"></a>JVM（30 天）</h3><p>想要深入理解 Java，探秘 Java 跨平台的奥秘，一定要了解 Java 底层的虚拟机技术。</p><p>了解虚拟机、掌握虚拟机性能调优方法，有助于你写出更高性能、资源占用更小的优质程序。</p><p>在学习 JVM 的过程中，也能学到很多精妙的设计，开拓思路。</p><p>知识<br>JVM 内存结构<br>JVM 生命周期<br>主流虚拟机<br>Java 代码执行流程<br>类加载<br>类加载器<br>类加载过程<br>双亲委派机制<br>垃圾回收<br>垃圾回收器<br>垃圾回收策略<br>垃圾回收算法<br>StopTheWorld<br>字节码<br>内存分配和回收<br>JVM 性能调优<br>性能分析方法<br>常用工具<br>参数设置<br>学习建议<br>JVM 的知识略显枯燥，建议先看视频，有实操的地方一定要实操！自己多去分析。</p><p>第一遍不理解没有关系，可以再看书来巩固，想要真正学好，《深入理解 Java 虚拟机（第三版）》一定要读。</p><p>如果只是为了通过面试可以直接看更精简的视频，比如狂神的。</p><p>资源<br>视频</p><p>⭐ 尚硅谷宋红康 - JVM 全套教程详解：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ（讲得相当全面！附有实操）">https://www.bilibili.com/video/BV1PJ411n7xZ（讲得相当全面！附有实操）</a></p><p>【狂神说Java】JVM快速入门篇：<a href="https://www.bilibili.com/video/BV1iJ411d7jS（讲得有点浅，但都是面试重点，时间紧的小伙伴可以直接看这个）">https://www.bilibili.com/video/BV1iJ411d7jS（讲得有点浅，但都是面试重点，时间紧的小伙伴可以直接看这个）</a></p><p>书籍</p><p>⭐《深入理解 Java 虚拟机（第三版）》（有理论有实践，内容丰富，不可多得的 JVM 学习神书，就是有点废头发）<br>项目</p><p>⭐ Java 虚拟机底层原理知识总结：<a href="https://github.com/doocs/jvm">https://github.com/doocs/jvm</a><br>实战</p><p>阿里云 JVM 实战：<a href="https://developer.aliyun.com/graph/java/point/64">https://developer.aliyun.com/graph/java/point/64</a><br>架构设计<br>分布式<br>分布式理论</p><p>CAP<br>BASE<br>分布式缓存</p><p>Redis<br>Memcached<br>Etcd<br>一致性算法</p><p>Raft<br>一致性哈希<br>分布式事务</p><p>分布式 id 生成</p><p>分布式服务调用</p><p>分布式存储</p><p>分布式数据库</p><p>分布式文件系统</p><p>分布式协调</p><p>Zookeeper<br>分布式监控</p><p>Prometheus<br>分布式消息队列</p><p>RabbitMQ<br>Kafka<br>Apache Pulsar<br>分布式日志收集</p><p>Elastic Stack<br>Loki<br>分布式搜索引擎</p><p>Elasticsearch<br>分布式链路追踪</p><p>Apache SkyWalking<br>分布式配置中心</p><p>Apollo<br>Nacos<br>高可用<br>主从<br>异地多活<br>容灾备份<br>高并发<br>数据库</p><p>分库分表<br>读写分离<br>缓存</p><p>缓存雪崩<br>缓存击穿<br>缓存穿透<br>负载均衡</p><p>负载均衡算法<br>软硬件负载均衡（2、3、4、7 层）<br>其他<br>监控告警</p><p>领域驱动设计</p><p>应用安全</p><p>线上故障分析</p><p>服务网格</p><p>Serverless</p><p>云原生</p><p>学习建议<br>多看文章多思考</p><h2 id="阶段-7：Java-求职"><a href="#阶段-7：Java-求职" class="headerlink" title="阶段 7：Java 求职"></a>阶段 7：Java 求职</h2><p>目标<br>找到好工作</p><p>建议<br>尽早做规划，可以通过大厂招聘官网的岗位描述来了解岗位的要求</p><p>雕琢一份优秀的简历，推荐阅读：<a href="https://mp.weixin.qq.com/s/wfabzdpOPdq89faFFpZ4NA">https://mp.weixin.qq.com/s/wfabzdpOPdq89faFFpZ4NA</a></p><p>多读面经，坚持刷算法</p><p>多参与面试，持续复盘总结</p><p>资源<br>岗位要求<br>阿里 Java 开发：<a href="https://campus.alibaba.com/position.htm?refno=12699">https://campus.alibaba.com/position.htm?refno=12699</a></p><p>腾讯后台开发：<a href="https://join.qq.com/post_detail.html?pid=1&amp;id=101&amp;tid=2">https://join.qq.com/post_detail.html?pid=1&amp;id=101&amp;tid=2</a></p><p>腾讯全栈开发：<a href="https://join.qq.com/post_detail.html?pid=1&amp;id=137&amp;tid=2">https://join.qq.com/post_detail.html?pid=1&amp;id=137&amp;tid=2</a></p><p>腾讯运营开发：<a href="https://join.qq.com/post_detail.html?pid=1&amp;id=105&amp;tid=2">https://join.qq.com/post_detail.html?pid=1&amp;id=105&amp;tid=2</a></p><p>美团后端开发：<a href="https://campus.meituan.com/jobs?jobFamily=1&amp;jobId=4005&amp;jobType=1&amp;pageNo=2">https://campus.meituan.com/jobs?jobFamily=1&amp;jobId=4005&amp;jobType=1&amp;pageNo=2</a></p><p>华为软件开发：<a href="https://career.huawei.com/reccampportal/portal5/campus-recruitment-detail.html?jobId=176044">https://career.huawei.com/reccampportal/portal5/campus-recruitment-detail.html?jobId=176044</a></p><p>鱼皮经历<br>从 0 开始的编程学习进大厂经历</p><p>⭐ 我学计算机的四年，共勉：<a href="https://mp.weixin.qq.com/s/Nc7Ee2UyrPg6hGseQUCzeg">https://mp.weixin.qq.com/s/Nc7Ee2UyrPg6hGseQUCzeg</a><br>实习经历</p><p>⭐ 我的第一份实习：<a href="https://mp.weixin.qq.com/s/SwGiRzyTkCOOCUXfXPR1Pw">https://mp.weixin.qq.com/s/SwGiRzyTkCOOCUXfXPR1Pw</a></p><p>⭐ 我的第二份实习，字节跳动：<a href="https://mp.weixin.qq.com/s/3q-YIfuZBjPjSnamNwOraw">https://mp.weixin.qq.com/s/3q-YIfuZBjPjSnamNwOraw</a></p><p>知识总结<br>⭐ 牛客 Java 面试宝典：<a href="https://www.nowcoder.com/tutorial/94">https://www.nowcoder.com/tutorial/94</a></p><p>⭐ JavaGuide：<a href="https://snailclimb.gitee.io/javaguide/#/">https://snailclimb.gitee.io/javaguide/#/</a></p><p>⭐ CS-Notes：<a href="http://www.cyc2018.xyz/">http://www.cyc2018.xyz/</a></p><p>阿里 Java 技术图谱：<a href="https://developer.aliyun.com/graph/java">https://developer.aliyun.com/graph/java</a></p><p>面经<br>⭐ 2021 最新 Java 笔试、面试题合集：<a href="https://pan.baidu.com/s/1DE4HAu-DS80n7VOaGpU_KQ（密码：lkw1）">https://pan.baidu.com/s/1DE4HAu-DS80n7VOaGpU_KQ（密码：lkw1）</a></p><p>⭐ 牛客面经：<a href="https://www.nowcoder.com/discuss/experience?tagId=639">https://www.nowcoder.com/discuss/experience?tagId=639</a></p><p>视频<br>⭐ 尚硅谷 2021 逆袭版 Java 面试题第三季：<a href="https://www.bilibili.com/video/BV1Hy4y1B78T">https://www.bilibili.com/video/BV1Hy4y1B78T</a></p><p>⭐ 阿里大佬透彻讲解 Java 面试 500 道必考题：<a href="https://www.bilibili.com/video/BV1yU4y1J7Bb">https://www.bilibili.com/video/BV1yU4y1J7Bb</a></p><h2 id="阶段-8：持续学习"><a href="#阶段-8：持续学习" class="headerlink" title="阶段 8：持续学习"></a>阶段 8：持续学习</h2><p>目标<br>持续追求技术的深度和广度，培养自己的 核心竞争力 和 不可替代性 ，学无止境！</p><p>学习建议<br>自主学习，自主搜索教程，多看书，多阅读技术博客，多实践。</p><p>学习方向<br>框架源码<br>Spring<br>SpringBoot<br>SpringMVC<br>MyBatis<br>Netty<br>Dubbo<br>SpringCloud<br>计算机原理<br>《算法导论》：<a href="https://www.bilibili.com/video/av48922404">https://www.bilibili.com/video/av48922404</a></p><p>《现代操作系统》：<a href="https://www.bilibili.com/video/av9555596">https://www.bilibili.com/video/av9555596</a></p><p>《深入理解计算机系统》：<a href="https://www.bilibili.com/video/av31289365">https://www.bilibili.com/video/av31289365</a></p><p>《编译原理》：<a href="https://www.bilibili.com/video/av17649289">https://www.bilibili.com/video/av17649289</a></p><p>《计算机网络：自顶向下方法》：<a href="https://www.bilibili.com/video/av41404195">https://www.bilibili.com/video/av41404195</a></p><p>《计算机程序的构造和解释》：<a href="https://www.bilibili.com/video/av8515129">https://www.bilibili.com/video/av8515129</a></p><p>《数据库系统概念》：<a href="https://www.bilibili.com/video/av52007695">https://www.bilibili.com/video/av52007695</a></p><p>数据库 / 中间件 / 分布式<br>数据库<br>MySQL<br>PostgreSQL<br>缓存<br>Redis<br>队列<br>Apache Kafka<br>Apache Pulsar<br>搜索引擎<br>Elastic Stack<br>容器<br>Docker<br>K8S<br>解决方案<br>广告<br>电商<br>搜索<br>游戏<br>即时通讯<br>社交<br>CMS<br>ERP<br>OA<br>架构<br>亿级流量架构<br>秒杀系统<br>架构选型能力<br>大数据<br>5V 特点<br>Hadoop<br>HDFS<br>MapReduce<br>Spark<br>Flink<br>Storm<br>Hive<br>HBase<br>Druid<br>Kylin<br>Pig<br>Mahout<br>前沿技术<br>云原生：<a href="https://www.jianshu.com/p/a37baa7c3eff">https://www.jianshu.com/p/a37baa7c3eff</a></p><p>Quasar Framework：<a href="http://www.quasarchs.com/">http://www.quasarchs.com/</a></p><p>自学 Java 专题资源<br>GitHub Java 专区：<a href="https://github.com/topics/java">https://github.com/topics/java</a></p><p>GitHub Java 合集：<a href="https://github.com/akullpp/awesome-java">https://github.com/akullpp/awesome-java</a></p><p>StackOverflow：<a href="https://stackoverflow.com/questions/tagged/java（解决问题必备）">https://stackoverflow.com/questions/tagged/java（解决问题必备）</a></p><p>掘金 Java 专区：<a href="https://juejin.cn/tag/Java">https://juejin.cn/tag/Java</a></p><p>美团技术团队：<a href="https://tech.meituan.com/">https://tech.meituan.com/</a></p><p>阿里技术团队：<a href="https://102.alibaba.com/tech/list/">https://102.alibaba.com/tech/list/</a></p><p>有赞技术团队：<a href="https://tech.youzan.com/tag/back-end/">https://tech.youzan.com/tag/back-end/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>密码学下</title>
      <link href="/2022/05/22/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8B/"/>
      <url>/2022/05/22/%E5%AF%86%E7%A0%81%E5%AD%A6%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="经典加密"><a href="#经典加密" class="headerlink" title="经典加密"></a>经典加密</h2><p>在数字计算机没有发明之前，加密都是对字符进行加密，一般采用的方法是字母替换，我把它称为 经典加密 。</p><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>简单的字母替换规则可以通过对字母表进行循环移位而来，最早记载的凯撒（Caesar）密码就是采用这种方式。凯撒密码是传说中的凯撒大帝发明，加密时将明文中的每个字母都按照其在字母表中的顺序向后移动固定数目生成密文。例如，当偏移量是右移3(+3)的时候形成下面的字母替换表：</p><blockquote><p>+——+—————————————+<br>|明文|ABCDEFGHIJKLMNOPQRSTUVWXYZ|<br>+——+—————————————+<br>|密文|DEFGHIJKLMNOPQRSTUVWXYZABC|<br>+——+—————————————+</p></blockquote><p>对应我们的明文 <font color="red">GAME404</font> 就变成了密文 <font color="red"> JDPH404 </font>。解密时候再把密文在字母表中左移3(-3)得到明文 GAME404。这种情况下凯撒密码的秘钥就是单个数字3。</p><p>凯撒密码现在看来是比较小儿科，但是在2000多年前，是了不起的发明，为凯撒部队的保密工作做了贡献。即使是到现在，军事上的信息保密需求，任然是密码学前进的最大动力。</p><blockquote><p>这里数字忽略加密，采用原文传输</p></blockquote><h2 id="ROT13加密"><a href="#ROT13加密" class="headerlink" title="ROT13加密"></a>ROT13加密</h2><p>rot13（rotate by 13 places）也是一种简易的替换式密码，是凯撒密码的变种。rot13将明文偏移13位形成密文，因为英文总共26位，所以密文再偏移13位后会循环回到原文，非常巧妙的设计，加密和解密使用同一个方法。这是公式:  <font color="red">rot13(rot13(xxx))=xxx</font>。在python3中默认带rot_13的算法实现, 下面是用例:</p><blockquote><p>➜  ~ echo “game404” | python -m encodings.rot_13<br>tnzr404<br>➜  ~ echo “tnzr404” | python -m encodings.rot_13<br>game404</p></blockquote><h2 id="随机单表替换"><a href="#随机单表替换" class="headerlink" title="随机单表替换"></a>随机单表替换</h2><p>采用位移形成的字母替换，有明显的规律。加密中最要的一点是 随机 ，所以可以使用随机的方式形成字母替换表:</p><blockquote><p>+——+—————————————+<br>|明文|ABCDEFGHIJKLMNOPQRSTUVWXYZ|<br>+——+—————————————+<br>|密文|ZEBRASCDFGHIJKLMNOPQTUVWXY|<br>+——+—————————————+</p></blockquote><p>这样加密和解密都必须持有  <font color="red">ZEBRASCDFGHIJKLMNOPQTUVWXY</font> 这个完整的密码本，长度为26位，而不是3或者13这样的单位秘钥。<br>随机单表替换，初看无法得到具体信息。但是一些密码破译专家，也是数学家就可以看到一些统计规律。比如明文 hello game 加密后的密文  <font color="red">daiil czja</font>。因为在英语中字母e是频率最高的字符，根据前面的密文表现，可以初步推断 e-&gt;a。如果我们再掌握更多的密文，分析其中的统计规律，使用类似求解数独的方式，破译密码。</p><h2 id="维吉尼亚多表替换密码"><a href="#维吉尼亚多表替换密码" class="headerlink" title="维吉尼亚多表替换密码"></a>维吉尼亚多表替换密码</h2><p>单表替换容易透露统计规律，自然的改进思路就是使用多表替换，每个字母采用不同的替换规则，让规律不好捉摸。比如下面的维吉尼亚多表:<br><img src="img/维吉尼亚多表替换.png"></p><blockquote><p>此密码曾被误以为由布莱斯•德•维吉尼亚所创，所以才叫作维吉尼亚密码，实际上最著名的一种为吉奥万•巴蒂斯塔•贝拉索于1585年推出。它于1863年之前一直未被破解。法国人称它作“不能破译的密码”。<br>维吉尼亚密码中,表格的第一行只需直接填上26个字母,然后以下每一行的字母都是向左偏移一格，形成对称结构。这叫作表格横移,数学上每一列同余26。<br>这种密码需要使用一个关键字来作为密钥，关键字按字循环使用。</p></blockquote><p>假设关键字是CAT,明文的第一个字由C加密,第二个字由A加密,第三个则由T加密,然后再回到C加密,一直重复。加密按照上边的密码表,例如明文BALL用CAT作关键字时会得到密文DAEN,同一个字母L会加密成2个不同字母EN。现实中,维吉尼亚密码的关键字非常长，破解难度提高了很多。<br>维吉尼亚密码的密码本是规则的，所以破解的关键在于找到关键字。具体破解办法还是要从统计规律入手，进行暴力破解。<br>恩尼格玛密码机<br>人为制作的密码本是规则且有限，所以聪明的人想出了制作密码机器。恩尼格玛密码机(德語：Enigma)是第二次世界大战时的纳粹德国使用的密码机。关于恩尼格玛密码机和图灵的故事非常精彩和传奇，也有很多文章介绍。这里我只是简单介绍一小小部分。恩尼格玛密码机大概长这样:</p><p>看起来和一个机械打字机类似，顶部的转子用来旋转设置秘钥，转子内部自动生成不同的密码表，底部的键盘用来键入明文，每个明文经过机器转换加密后输出到中间的灯泡，记录下灯泡的位置就得到密文。解密的时候设置好相同的转子位置，然后输入密文，就得到了明文。<br>因为恩尼格玛密码机加密非常复杂，不犯错的情况下人肉难以快速破解。所以后来大神图灵登场，设计了“炸弹机”，用机器来破解机器，从此开启了计算机的新时代。<br>数字加密<br>在数字世界里，字符不再是不可分割。经典场景中字符A是原子的，没法拆分成左半个A和右半个A。数字世界0和1才是原子的，字符可以分解成不同的0和1组合，比如:</p><blockquote><blockquote><blockquote><p>a = “a”<br>print(a, ord(a), bin(ord(a)))<br>a 97 0b1100001</p></blockquote></blockquote></blockquote><p>字符a的ASCII码是97，对应的二进制是8位001100001。这样我们就可以把a打散成两部分，比如左边6位0011000，右边2位01，再和别的字符重新排列。<br>base64<br>所谓Base64，就是说选出64个字符——小写字母a-z、大写字母A-Z、数字0-9、符号”+”、”/“（再加上作为垫字的”=”，实际上是65个字符）——作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。这种加密方式因为密码本公开，所以一般只是称为base64 编码，而不叫做base64 加密。<br>阮一峰老师的Base64笔记介绍的非常好，大家可以通过尾部的参考链接去查看。我偷懒简单整理一下。先是base64的码表:<br>码值    字符    码值    字符    码值    字符    码值    字符<br>0    A    16    Q    32    g    48    w<br>1    B    17    R    33    h    49    x<br>2    C    18    S    34    i    50    y<br>3    D    19    T    35    j    51    z<br>4    E    20    U    36    k    52    0<br>5    F    21    V    37    l    53    1<br>6    G    22    W    38    m    54    2<br>7    H    23    X    39    n    55    3<br>8    I    24    Y    40    o    56    4<br>9    J    25    Z    41    p    57    5<br>10    K    26    a    42    q    58    6<br>11    L    27    b    43    r    59    7<br>12    M    28    c    44    s    60    8<br>13    N    29    d    45    t    61    9<br>14    O    30    e    46    u    62    +<br>15    P    31    f    47    v    63    /</p><p>然后部分ASCII码表:<br>二进制    十进制    十六进制    图形<br>…<br>0100 1101    77    4D    M<br>…<br>0110 0001    97    61    a<br>…<br>0110 1110    110    6E    n</p><p>那么base64的编码过程如下:</p><p>AESDESAES 代表高级加密标准Advanced Encryption StandardDES代表数据加密标准Data Encryption Standard创作日期为1999年。创作日期为1976年。面向字节。面向位。密钥长度可以是 128 位、192 位和 256 位。DES 中的密钥长度为 56 位。轮数取决于密钥长度：10（128 位）、12（192 位）或 14（256 位）DES涉及16轮相同操作该结构基于置换-置换(substitution-permutation)网络。该结构基于Feistel网络。AES 的设计原理是开放的。DES 的设计原理是封闭的。对此的选择过程是秘密的，但接受了公开的公众评论。选择过程是秘密的。AES 比 DES 密码更安全，是事实上的世界标准。DES 很容易被破解，因为它有已知的漏洞。3DES（三重 DES）是 DES 的一种变体，它比通常的 DES 更安全。AES 中的轮次是：字节替换、移位行、混合列和密钥加法DES 中的轮是：扩展、使用轮密钥的 XOR 操作、替换和置换AES 可以加密 128 位的明文。DES 可以加密 64 位的明文。AES 密码是从旁通道方密码派生的。DES密码源自路西法密码。AES 由 Vincent Rijmen 和 Joan Daemen 设计。DES 由 IBM 设计。没有已知的针对 AES 的密码分析攻击，但可能会针对 AES 实施进行侧信道攻击。Biclique 攻击比蛮力攻击具有更好的复杂性，但仍然无效。针对 DES 的已知攻击包括暴力破解、线性密码分析和差分密码分析。<br>DES的算法比较复杂，我简单总结一下大概步骤：</p><p>准备64位的明文和64位的密钥<br>秘钥经过16次调度，形成16个子秘钥<br>每个子秘钥，通过从秘钥64位摘取56位，分成左右各28位的L端和R端。然后L端和R端各自左移指定轮次的位数，然后拼接L端和R端。这个过程是字节的重组。最后对形成的秘钥在进行一次置换。得到48位的子秘钥。<br>重复上面的步骤3，直到得到16个48位子秘钥<br>明文的64位根据置换表进行一次置换，再拆分成L端和R端各32位<br>循环执行L，R = R，F(L，子秘钥)16次，就是把R端复制给L，然后把32位的L和48位的子秘钥使用f函数进行加密。<br>最后把L和R拼接后进行再进行一次置换得到密文</p><p>可以看到算法中关键点, F函数。 Feistel函数重点是把32位的一半明文和48位的子秘钥，混合得出一个32位的等长秘钥。这个过程依赖一个不透明的预制机制S盒，所以其实不收大家信任，怀疑算法留有后门。这个过程，我们可以把它想象成接水管游戏，不同的输入经过内部管道处理，输出特定的结果:</p><p>DES加密的思想，总结起来就是二进制位的重组和替换。DES和AES都是成熟的算法，一般情况下我们不需要实现它。出于安全性考虑，DES已经弃用，现在实际业务中一般直接利用AES的API即可。下面是完整的实现:<br>from base64 import b64encode, b64decode<br>from Crypto.Cipher import AES<br>from Crypto.Util.Padding import pad, unpad</p><p>def ase_cbc():<br>    data = b”secret”<br>    key = b”jSOlan6Co5Ac2HiT”<br>    cipher = AES.new(key, AES.MODE_CBC, iv=key[:AES.block_size])<br>    ct_bytes = cipher.encrypt(pad(data, AES.block_size))<br>    ciphertext = b64encode(ct_bytes).decode(‘utf-8’)<br>    print(ciphertext)<br>    ct = b64decode(b64encode(ct_bytes).decode())<br>    cipher = AES.new(key, AES.MODE_CBC, iv=key[:AES.block_size])<br>    dat = unpad(cipher.decrypt(ct), AES.block_size)<br>    print(dat)</p><p> svhpgz4vi1AgHDtdt8aaww==<br> b’secret’</p><p>明文是6个字节，秘钥是16个字节<br>创建一个ase的算法实现，这使用cbc模式<br>使用pad方法先对明文数据进行补齐<br>对明文进行加密得到密文，密文是二进制<br>因为二进制密文打印会乱码，所以将其使用base64编码转换成ascii字符<br>解密则是加密的逆过程</p><p>非对称加密算法<br>前一篇文章介绍过非对称加密的一些思路，和对称加密不同的是秘钥分成一个秘钥对：私钥+公钥。公钥用于加密，私钥永于解密。在介绍非对称加密的算法实现之前，我们先看看物理世界的非对称加密模拟，有助于我们理解非对称加密的基本逻辑。</p><p>上面是我简单画的一个非对称加密信箱，分成上下2个盒子，中间是联通的。上方盒子需要使用四角星的钥匙打开，下方盒子需要使用五角星的的钥匙打开。那么一个信息加密传输过程大概如下:</p><p>发送方甲用自己的锁把上方盒子用四角星锁锁住，然后把信箱传递给接收方乙。<br>接收方乙收到信箱后把下方盒子用五角星锁锁住，然后把信息回传给发送方甲。<br>甲用四角星钥匙打开上方盒子，塞入信件，然后把信箱和信件一起传递给乙。<br>乙用五角星钥匙打开下方盒子，取出信件。完成一次信息加密传输。</p><p>在这个信息传递过程中，甲乙的钥匙都分别自己保管，没有经过运输。甲用四角星钥匙加锁，乙用五角星钥匙解锁，而且信件都在信箱中。这样保证了信息传递是安全的。<br>1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字命名，叫做RSA算法，现在是非对称加密的标准。算法主要采用的是质数因式分解这样一个”盒子”比如下面一个等式:<br>n = 61×53 = 3233</p><p>61和53的乘积，大家口算或者笔算有可能可以计算出来，但是反过来求3233是那两个质数的乘积却非常难。在非对称加密情况下，我们选择一个随机数，比如17。使用(3233，17)这样的信息组成公钥，然后使用类似(3233,17<em>61/17</em>65)这样的信息组成私钥。公钥只是私钥的一部分信息，这样公钥加密的信息，逻辑上私钥肯定可以解密。而且通过公钥的3233，很难推断出私钥中的61*53。当然非对称加密的数学验证比这个举例要严谨和复杂的多，我这里只是尝试举例，帮助理解。<br>加密示例:<br>def rsa_enc():<br>    from Crypto.PublicKey import RSA<br>    from Crypto.Random import get_random_bytes<br>    from Crypto.Cipher import AES, PKCS1_OAEP</p><pre><code>data = &quot;I met aliens in UFO. Here is the map.&quot;.encode(&quot;utf-8&quot;)file_out = open(&quot;encrypted_data.bin&quot;, &quot;wb&quot;)recipient_key = RSA.import_key(open(&quot;public.pem&quot;).read())session_key = get_random_bytes(16)# Encrypt the session key with the public RSA keycipher_rsa = PKCS1_OAEP.new(recipient_key)enc_session_key = cipher_rsa.encrypt(session_key)# Encrypt the data with the AES session keycipher_aes = AES.new(session_key, AES.MODE_EAX)ciphertext, tag = cipher_aes.encrypt_and_digest(data)[file_out.write(x) for x in (enc_session_key, cipher_aes.nonce, tag, ciphertext)]file_out.close()</code></pre><p>秘钥可以使用代码生成，也可以使用OpenSSL工具生成，这里我使用上一篇文章中的秘钥<br>导入rsa公钥<br>随机一个AES秘钥，然后使用rsa公钥加密这个秘钥<br>使用AES加密信息<br>将AES秘钥密文，AES的随机数，iv和密文写入结果</p><p>解密示例:<br>from Crypto.PublicKey import RSA<br>from Crypto.Cipher import AES, PKCS1_OAEP</p><p>file_in = open(“encrypted_data.bin”, “rb”)</p><p>private_key = RSA.import_key(open(“private.pem”).read())</p><p>enc_session_key, nonce, tag, ciphertext = \<br>   [ file_in.read(x) for x in (private_key.size_in_bytes(), 16, 16, -1) ]</p><p> Decrypt the session key with the private RSA key<br>cipher_rsa = PKCS1_OAEP.new(private_key)<br>session_key = cipher_rsa.decrypt(enc_session_key)</p><p> Decrypt the data with the AES session key<br>cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)<br>data = cipher_aes.decrypt_and_verify(ciphertext, tag)<br>print(data.decode(“utf-8”))</p><p>导入rsa私钥<br>读取结果，并按位从中解析出aes私钥密文，随机数，iv和剩下的密文信息<br>使用rsa私钥从aes秘钥的密文中解析出aes密钥明文<br>使用aes秘钥解密密文信息</p><p>这一对过程的重点是，rsa仅仅加密aes的私钥，私钥的密文进行传输 。encrypted_data.bin是二进制的，直接使用文本方式查看会是乱码，我们可以转换为base64方式查看:<br>✗ base64 encrypted_data.bin<br>w+ii4VVphO1ulHjrUy4fcc7CuLxaxJTQuzTtgIqvoot3ivBcRWwxV/1rNqIA2fsddYq8AIRo7jV9xoxbUK9ll8LQdM5S0N9eBakM6wzEwnN9PFrJEKN7VdmTqxnzC7go5tS2qNR173xcJKTX3UXKBTLbKXkafj9k2Bk9g93hRh19Uka/S5AqD43dFjIyI2ogxZNkN0v5E6uAyINlhGO8jCHAN0yhu4S5zz0ph7mFAVfXQkNDuotcdmsRfPpEi641BI/fEGE=</p><p>散列算法<br>散列函数（Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表，用来表示信息完整性。<br>散列函数数学逻辑并不难，首先需要一个奇函数，保证每一个输入可以得到一个唯一的输出:</p><p>然后我们再从输出结果中进行信息摘取部分，这样来保证摘要比原文要短，因为摘要比原文长，那就没有价值。我们可以自己随便设想一个哈希算法:</p><p>函数取值 y=2f(x)+3<br>将结果转换为二进制后循环左移3位<br>将二进制结果拆分成左右两段并还原成2个十进制数<br>使用2个十进制数相乘<br>结果再转换为二进制数据，取其前8位转换成16进制得到哈希值</p><p>根据抽屉原理，9个苹果放到8个箱子，一定有一个箱子会有2个苹果。信息摘要算法一定会有冲突，只是好的算法信息冲突的概率会非常非常低。我们上面的设想的哈希算法，仅仅8位，冲突的概率非常高。好的散列函数在输入域中很少出现散列冲突，知名的算法有MD5和SHA。<br>MD5信息摘要演算法5（MD5 Message-Digest Algorithm 5）是散列算法的一种，可以产生出一個128位（16个字节(BYTES)）的散列值（hash value），一般表示为32位十六进制数字。<br>SHA安全散列算法（Secure Hash Algorithm ）也是一个系列的散列算法。最早SHA-1，正式发布的第一代算法可以生成一个被称为消息摘要的160位（20字节）散列值，散列值通常的呈现形式为40个十六进制数。<br>这两种算法都被我国的 王小云 教授破解了，所以这2种算法都被认为安全性不足，不再建议使用，目前较多使用sha256算法。sha256是sha-2算法的变种，输出是256位(32字节)的摘要值，同属sha-2的还有SHA-224，SHA-512等。2015年还推出了sha算法的第3个版本，即sha3。<br>下面是md5和sha256的示例:<br>def hash_sample():<br>    import hashlib<br>    plaintext = “game404”<br>    result = hashlib.md5(plaintext.encode())<br>    md5 = result.hexdigest()<br>    print(md5, len(md5))<br>    result = hashlib.sha256(plaintext.encode())<br>    s256 = result.hexdigest()<br>    print(s256, len(s256))</p><h1 id="e935208860777d1584d3586a9e93e160-32"><a href="#e935208860777d1584d3586a9e93e160-32" class="headerlink" title="e935208860777d1584d3586a9e93e160 32"></a>e935208860777d1584d3586a9e93e160 32</h1><h1 id="c56afda14db3e8b61eb83f17540401ec983e91e92375826d2842e29c8a4db437-64"><a href="#c56afda14db3e8b61eb83f17540401ec983e91e92375826d2842e29c8a4db437-64" class="headerlink" title="c56afda14db3e8b61eb83f17540401ec983e91e92375826d2842e29c8a4db437 64"></a>c56afda14db3e8b61eb83f17540401ec983e91e92375826d2842e29c8a4db437 64</h1><p>license实现<br>了解完所有算法的模型后，license的实现就非常简单了。我们先设置license信息:<br>{<br>    “name”:”game404”，<br>    “expiryDate”: 20220220<br>}</p><p>然后我们将其dump成字符后使用ras签名, 完整代码如下:<br>def rsa_sign():<br>    from Crypto.PublicKey import RSA<br>    from Crypto.Cipher import AES<br>    from Crypto.Signature import PKCS1_v1_5<br>    from Crypto.Hash import SHA256<br>    import json</p><pre><code>license_object = &#123;    &quot;name&quot;: &quot;game404&quot;,    &quot;expiryDate&quot;: 20220220&#125;plaintext = json.dumps(license_object)file_out = open(&quot;encrypted_license.bin&quot;, &quot;wb&quot;)private_key = RSA.import_key(open(&quot;private.pem&quot;).read())# rsa签名cipher_rsa = PKCS1_v1_5.new(private_key)digest = SHA256.new()digest.update(plaintext.encode(&quot;utf-8&quot;))signature = cipher_rsa.sign(digest)# aes加密session_key = get_random_bytes(16)cipher_aes = AES.new(session_key, AES.MODE_EAX)ciphertext, tag = cipher_aes.encrypt_and_digest(plaintext.encode(&quot;utf-8&quot;))# 写licensefile_out.write(b&quot;&quot;.join([session_key, cipher_aes.nonce, tag, signature, ciphertext]))file_out.close()</code></pre><p>证书我们可以base64后发送出去:<br>F4IBtZOODAE5XSdluFynrk8e01gSKwVftivMg+eucfD7j5nCdMZhIcjGyLjQ5miV4Y6mAOooajNypWVL+GTVleXoLUQzqf0hLG02ytuIZ3QlCbGXVn3sofePq+IhwDBH5x2CECwHofzuNH0LbQLlW7LbwXxOl8xvGOw1gCvUgGo8Uuqli0cgrijqKO+n72Rb4Is0KW8EMjvPvaaLodbEhUc2iCLDiDDLXpBvcWsMZeW+AVgfpr6jKR9ICyELg4XQ2s84gs3d+EcFjaFjAzwygBuLYdqa40pR4G/e</p><p>本地验证证书:<br>def rsa_verify():<br>    from Crypto.PublicKey import RSA<br>    from Crypto.Cipher import AES<br>    from Crypto.Signature import PKCS1_v1_5<br>    from Crypto.Hash import SHA256</p><pre><code>file_in = open(&quot;encrypted_license.bin&quot;, &quot;rb&quot;)public_key = RSA.import_key(open(&quot;public.pem&quot;).read())# 读取licensesession_key, nonce, tag, signature, ciphertext = [file_in.read(x) for x in (16, 16, 16, 128, -1)]# aes解密cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)data = cipher_aes.decrypt_and_verify(ciphertext, tag)print(data.decode(&quot;utf-8&quot;))cipher_rsa = PKCS1_v1_5.new(public_key)digest = SHA256.new()digest.update(data)try:    # 验证签名    cipher_rsa.verify(digest, signature)except ValueError:    pass</code></pre><p>证书实际上不需要保密，只需要验证来源的合法性和完整性。所以我们可以看到aes的秘钥是写入到证书文件中的，合法性和完整性使用rsa算法和sha256算法结合来保证。<br>小结<br>本文我们一起回顾了经典加密和数字加密的演化过程，学习了使用 随机 ，变换 和 重组 等方式构建加密算法。重点了解了aes对称加密算法，rsa非对称加密算法以及sha256摘要算法，并利用它实现了一个商业license的制作。<br>数字加密的尽头，可能是量子计算。首先是量子通讯的不可观测性让量子加密具有巨大优势，如果通讯被偷听会导致量子叠加的坍缩，这样还可以主动识别是否被偷听。这个主动防窃听就非常厉害了，是上面的经典计算机的加密算法都无法实现的。其次量子计算机，在并行计算上也有巨大优势，经典计算机无法快速破解的算法，对量子计算机可能秒破。保密和破解这一矛和盾，又将迎来新的一轮变更。<br>最后，最重要的是我国在量子领域处于第一梯队，起步不晚，发展迅速。从md5的破解，再到量子通讯/计算，中国科学家逐渐登场，以后一定会看到更多 中国名字 和 中国标准 。<br>参考链接</p><p>DES算法原理及实现 www.ruanx.net/des/<br>什么是DES加密 www.cxyxiaowu.com/1478.html<br>费斯妥密码 zh.wikipedia.org/wiki/%E8%B4…<br>Feistel Cipher kysonlok.gitbook.io/blog/crypto…<br>Difference between AES and DES ciphers www.geeksforgeeks.org/difference-…<br>维吉尼亚多表替换加密术 sca.gov.cn/sca/zxfw/20…<br>zh.wikipedia.org/wiki/%E6%81…<br>Base64笔记 www.ruanyifeng.com/blog/2008/0…<br>XOR 加密简介 www.ruanyifeng.com/blog/2017/0…<br>pycryptodome.readthedocs.io/en/latest/s…</p><p>作者：游戏不存在<br>链接：<a href="https://juejin.cn/post/7066794630422986788">https://juejin.cn/post/7066794630422986788</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>密码学</title>
      <link href="/2022/05/22/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/2022/05/22/%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="安全防护"><a href="#安全防护" class="headerlink" title="安全防护"></a>安全防护</h2><p>密码学<sup><a href="#fn_密码学" id="reffn_密码学">密码学</a></sup>主要的解决的问题可以分为以下三点<br>    1、 防窃听，就是防止文件在传输过程中的被第三方读取。明信片在邮递过程中，信息可以被任何接触到的人看到，信息就泄露了。解决这个问题，最简单的办法，加一个密封的信封。这样信息在传递过程中就是安全的，其它人看不到。</p><pre><code>2、 防伪造是指防止信息的来源被第三方伪造。传统的信件防伪方法有印章，3、防篡改是指防止信息被第三方修改。传统的方法是使用蜡丸/火漆来包装信息，完整的蜡丸/火漆表示信息未被修改。网络中防窃听的方法是发送方把原文信息进行数字加密，传输密文，接收方只有使用秘钥才可以解开，保证信息的私密性。防伪造的方法是数字签名，发送方给信息附加一个数字签名，表明信息来源的真实性。防篡改的方式是数字摘要，对信息形成一个唯一的摘要，任何微小的原文修改都会导致数字摘要变化，从而保证信息的完整性。</code></pre><h2 id="加密和签名"><a href="#加密和签名" class="headerlink" title="加密和签名"></a>加密和签名</h2><p>加密和解密是一个对称操作，使用秘钥对原文进行加密得到密文，再使用同一秘钥对密文进行解密得到原文。</p><p>这种使用 唯一秘钥 的加密方式叫做 对称加密 。对称加密执行效率很高，但是在网络中如何安全的传输秘钥是个问题？秘钥无法安全传输，加密就达不到防护效果。<br>下面是使用openssl工具进行对称加密的演示:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># echo &quot;123abc&quot; | openssl enc -e -aes-128-cbc -pass pass:game404 -base64 -md sha1</span><br><span class="line">U2FsdGVkX1+wwmevh948fa38juYRyBxYYcdL2rWBhMQ=</span><br><span class="line">...</span><br><span class="line"># echo &quot;U2FsdGVkX1+wwmevh948fa38juYRyBxYYcdL2rWBhMQ=&quot; | openssl enc -d -aes-128-cbc -pass pass:game404 -base64 -md sha1</span><br><span class="line">123abc</span><br></pre></td></tr></table></figure></p><p>非对称加密 可以解决秘钥传输的安全问题。在非对称加密中使用一对秘钥: 私钥+公钥。私钥发送方(通常是服务端)保存，公钥通过网络对外发布，可以有多个接收方（通常是客户端）。客户端使用公钥加密后的密文，只能够在服务端使用私钥进行解密，即使再使用公钥也无法完成密文解密。<br>当然也可以反过来，使用私钥“加密”信息，公钥“解密”信息。但是由于公钥有多个，任何持有公钥的客户端，都可以对信息进行解密，所以这种私钥“加密”的信息，起不到保密的作用。只可以用来验证信息来源的唯一性，这个过程通常叫做 签名 和 验签。<br>私钥和公钥还有一个主要特点：公钥是通过私钥生成的，通过公钥很难推断出私钥，这样由于私钥的唯一性，可以做到信息保密。<br>总结一下口诀: 公钥加密，私钥解密；私钥签名，公钥验签 。<br>同样使用openssl工具创建非对称加密的私钥:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl genrsa -out private.pem 1024</span></span><br><span class="line">Generating RSA private key, 1024 bit long modulus</span><br><span class="line">...............++++++</span><br><span class="line">.++++++</span><br><span class="line">e is 65537 (0x10001)</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat private.pem</span></span><br><span class="line">-----BEGIN RSA PRIVATE KEY-----</span><br><span class="line">MIICXAIBAAKBgQDj73NhxbtD0lNJtYA5bWrMRKYhN07r6BYOKqsFMm9N91ZtvW/R</span><br><span class="line">7w87XO6WSt5uqVzBgQAHshQZNh0PNeBp8DpwIQYArG9x/ZZhZnTIsD3wUpbMbp5E</span><br><span class="line">EF4IBgw1284IKtpvV8a7HJzNchl4//bFGkAU/flIP1Upl6ZkOMk6KP76wQIDAQAB</span><br><span class="line">AoGALAqdWbvyBhXCoBBg2TfKFfQBwZNFPZHXiR83ckafeQocehHLZF3zrH21X/bR</span><br><span class="line">acJxuLXrQpFnDsQE82ZumSmgsKJK27yKIrf4eM7IKB0n6vK8WK9V+3L2FFg+p19i</span><br><span class="line">v9sA/sXZuJ7tNmXcbk3Vsqgv0ZRcro1I5PKZJUKZU3yoakECQQD9prACGI6igdMQ</span><br><span class="line">2YhZvuZPZ1zQPjuCBG046+WKXKFUO/IrLJbvvmpz218wzKdL/24A/dZwZHs/KOOh</span><br><span class="line">FYf11DoJAkEA5gvM98VOA+dGmf/KGy5Fx3CgFW+lEojDaNAFo1ZJY1kr6FJIY9H3</span><br><span class="line">n1mxXbXNObvBKi5FMQVgvsiCCHotw0BI+QJBALCxbgh3vNydXT9umZoS7nK/yRrT</span><br><span class="line">TzbaCI/PXB4POt7nx2Gl9Rra5WMBnQTse1nofGO6b6fphyVPQYpT6lsn1KkCQGg7</span><br><span class="line">JI2G6kg+e/C+wtX560foMcBEq6hwKwnMZyGQsQPAnXJQBdikg+vBeemZu/jSpzzz</span><br><span class="line">ZgpGA4Wt16z7nsx+zhECQCnN3OhSpOlT9Pq8CVXDMVNilutSbnNuO996k89Jg/zR</span><br><span class="line">s1XIN4zfEDxWLJi9N/iZ0BK7JnwtKMZ3Z+9IStWGqkg=</span><br><span class="line">-----END RSA PRIVATE KEY-----</span><br></pre></td></tr></table></figure><br>根据私钥创建公钥:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl rsa -<span class="keyword">in</span> private.pem -pubout -out public.pem</span></span><br><span class="line">writing RSA key</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat public.pem</span></span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDj73NhxbtD0lNJtYA5bWrMRKYh</span><br><span class="line">N07r6BYOKqsFMm9N91ZtvW/R7w87XO6WSt5uqVzBgQAHshQZNh0PNeBp8DpwIQYA</span><br><span class="line">rG9x/ZZhZnTIsD3wUpbMbp5EEF4IBgw1284IKtpvV8a7HJzNchl4//bFGkAU/flI</span><br><span class="line">P1Upl6ZkOMk6KP76wQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure><br>对信息进行加密的部分过程:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> openssl rsautl -sign -<span class="keyword">in</span> license.md5 -out license -inkey private.pem</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> base64 license</span></span><br><span class="line">hkBRNnalRvi21K+dnOvAg8W3V/ntheouUhlJelwvzzW3CMZbKw08z4TQzV4Qkx0DU7YgiUOdCNvn</span><br><span class="line">KWRdxVnj4jatqLZeMJp9BOYI3SrdzsQETzXQOV/37L+s6nA4T+EM8YfsdgoEfyt5GYezBqQW3Iii</span><br><span class="line">fppNQ4e67qSTBqpfD88=</span><br></pre></td></tr></table></figure><br>在非对称加密过程中还存在2个问题:</p><blockquote><p>1、 私钥加密无法达到保密效果，服务端响应信息无法加密。<br>  2、要求明文信息必须小于秘钥长度。</p></blockquote><p>一种容易想到的方法是让每个客户端也生成一对私钥+公钥，这样服务端使用客户端的公钥加密响应信息。这种方法的副作用是服务端需要保存所有的客户端公钥，实现成本较高，一般非金融类业务不会这样处理。对于明文信息必须小于秘钥长度，可采用明文分段方式进行加密，这种方法的副作用是效率更低。</p><p>比较好的解决上述2个问题的方法是把对称加密和非对称加密结合起来。客户端随机生成一个对称秘钥，然后使用公钥加密秘钥，服务端收到密文信息后解密得到秘钥。服务端使用秘钥对响应信息进行对称加密，客户端使用秘钥解密信息。这样就解决了服务端响应信息的加密问题。以后客户端再发送请求信息，都可以使用这个秘钥进行对称加密，同时也解决非对称加密效率低和秘钥长度的问题。流程如下:</p><p>步骤客户端服务端1生成对称秘钥-2公钥加密对称秘钥-3-私钥解密获得对称秘钥4使用对称秘钥加密请求明文-5-使用对称秘钥解密请求密文6-使用对称秘钥加密响应明文7使用对称秘钥解密响应明文-</p><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>使用对称加密+非对称加密的结合，还有秘钥伪造的安全问题。假设客户端请求A网站服务，需要先获取A网站的公钥。如果在网络传输中B网站使用自己的公钥进行伪装替换，客户端错误的把B网站的公钥当做A网站的公钥。那么客户端发送给A网站的信息就可以被B网站窃取。</p><p>解决的办法就需要使用 证书。由一个专业的安全机构，给A网站颁发一个证书。证书实际上就是把A网站的公钥使用自己的私钥包装一下。同时这个机构还会和操作系统配合，提前在操作系统中预制自己的公钥。这样通讯中获取到A站点的证书后，使用操作系统提供的安全机构公钥解密得到A站点的公钥，从而解决公钥伪造问题。以上处理方式就是https协议的安全基础。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>摘要一个应用场景是公示信息的完整性。下载网站在提供软件下载的时候，一般还会提供一个数字摘要，用来防止流氓软件捆绑。比如下面pypy软件包的摘要信息:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pypy3.9-v3.7.8 sha256:</span><br><span class="line">---------------------</span><br><span class="line">89dd0399a89a04b58c22e9b773747258807996bd5071dbf996a85bf8af432393  pypy3.9-v7.3.8rc1-linux32.tar.bz2</span><br><span class="line">f3f90203afcf7ee359e8c8a871bfaa06d96f926781fd94fb81f471dcd32f7332  pypy3.9-v7.3.8rc1-linux64.tar.bz2</span><br><span class="line">9a5d7217d8173bbdf1c7351b34651fee0596b0bcfe6fe4becae150d4a5469487  pypy3.9-v7.3.8rc1-osx64.tar.bz2</span><br><span class="line">4651d804341046be824af0ca35b7ebbbb6d5cdcef0d4a373891398dba182d010  pypy3.9-v7.3.8rc1-src.tar.bz2</span><br><span class="line">c4db62a854c2cc994d46fac0105a8e3bd4273093b9844c1f7cb69118fae6df72  pypy3.9-v7.3.8rc1-src.zip</span><br><span class="line">ad214e4a44c893dc503e7e0b6f6bdfa7523db80b9d4890523f8ee96339d05fc9  pypy3.9-v7.3.8rc1-win64.zip</span><br></pre></td></tr></table></figure></p><p>通过特定的散列算法，对 pypy3.9-v7.3.8rc1-linux32.tar.bz2 计算得到值为 89dd0399a89a04b58c22e9b773747258807996bd5071dbf996a85bf8af432393 的摘要。下载完成后比较一下摘要就知道软件包的完整性。</p><p>下面是另外一个摘要算法md5的示例:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ echo &quot;123456789&quot; | md5sum</span><br><span class="line">b2cfa4183267af678ea06c7407d4d6d8  -</span><br><span class="line">➜  ~ echo &quot;123456789&quot; | md5sum</span><br><span class="line">b2cfa4183267af678ea06c7407d4d6d8  -</span><br><span class="line">➜  ~ echo &quot;1&quot; | md5sum</span><br><span class="line">b026324c6904b2a9cb4b88d6d61c81d1  -</span><br><span class="line">➜  ~ echo &quot;123456780&quot; | md5sum</span><br><span class="line">9af763c0ffc99c565a6a9460e1a2ca7e  -</span><br></pre></td></tr></table></figure></p><p>散列函数形成的摘要都具有下面几个特点:</p><p>1、单向 只能够从tar包得到一个摘要值，从摘要值是无法还原完整的tar包<br>2、结果确定 同一个算法对每个输入的计算结果是确定<br>3、结果定长 可以看到字符串”1”和”123456789”得到的结果长度都是一样的<br>4、结果分散无规律 可以看到字符串”123456780”和”123456789”，仅仅变动了1个字符，摘要却变化非常大<br>5、效率高 工程上摘要的计算非常快速</p><p>下面是摘要算法的一些应用场景。</p><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>因为摘要算法的确定性，所以可以用来进行去重。对于数据是否变更，仅仅需要比较信息的摘要指是否变动:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if data[&quot;targets_md5&quot;] != self.route_data.get(&quot;targets_md5&quot;, None):</span><br><span class="line">    do_update()</span><br><span class="line">else:</span><br><span class="line">    log.info(&quot;update_router_info targets not changed !&quot;)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure></p><h2 id="密码保护"><a href="#密码保护" class="headerlink" title="密码保护"></a>密码保护</h2><p>系统存储用户密码时，并不记录密码本身，仅记录密码的散列值。这样只有用户自己知道密码的明文。校验密码时，只要输入的密码正确，得到的散列值一定是一样的，表示校验通过。即使系统的数据库不小心产生泄露问题，也不会导致用户的密码泄露。<br>很多用户习惯使用同一个密码访问所有网站，比如A网站和B网站使用同一个密码，假设网站都是明文存储用户名和密码。A网站是大站点，网络安全处理比较好。但是B网站是小站点，发送了数据库泄露。这样攻击者利用盗取数据中的用户名和密码，从而拿到用户在A网站的重要信息。<br>md5算中123456789的值固定是b2cfa4183267af678ea06c7407d4d6d8，所以即使使用散列存储，也可以反向推断值为b2cfa4183267af678ea06c7407d4d6d8的密码明文是123456789。这种攻击方法一般称为 彩虹表，就是利用一些常用密码的散列值进行推测密码明文。解决这个问题的方法是 加盐 。加盐是一个通俗说法，利用散列算法的分散特性，在明文中混入一个其它数据，这样得到密文就会产生大的变化。校验的时候只要保证使用相同的盐，就可以确定明文是正确。</p><blockquote><p>明文+盐值 —&gt; 密文</p></blockquote><h2 id="接口签名"><a href="#接口签名" class="headerlink" title="接口签名"></a>接口签名</h2><p>摘要算法还可以用来做服务之间接口的安全认证。比如某个接口的参数如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appid： wxd930ea5d5a258f4f</span><br><span class="line">mch_id： <span class="number">10000100</span></span><br><span class="line">device_info： <span class="number">1000</span></span><br><span class="line">body： test</span><br><span class="line">nonce_str： ibuaiVcKdpRxkhJA</span><br></pre></td></tr></table></figure><br>对接口的参数信息进行拼接，形成一个原始的字符串:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringA=<span class="string">&quot;appid=wxd930ea5d5a258f4f&amp;body=test&amp;device_info=1000&amp;mch_id=10000100&amp;nonce_str=ibuaiVcKdpRxkhJA&quot;</span>;</span><br></pre></td></tr></table></figure><br>结合参数信息和秘钥形成一个摘要签名:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MD5签名方式：</span><br><span class="line">stringSignTemp=stringA+<span class="string">&quot;&amp;key=192006250b4c09247ec02edce69f6a2d&quot;</span> <span class="comment">//注：key为商户平台设置的密钥key</span></span><br><span class="line">sign=MD5(stringSignTemp).toUpperCase()=<span class="string">&quot;9A0A8659F005D6984697E2CA0A9CF3B7&quot;</span> <span class="comment">//注：MD5签名方式</span></span><br></pre></td></tr></table></figure><br>因为秘钥进行双方服务器存放，不进过网络传输。所以每个请求可以通过验证签名确定来源和信息的完整性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文我们了解了密码学的一些应用场景和解决问题的目的。目的这个很重要，可以让我们知道 加密，签名，摘要 都在保护什么。加密是保护信息的私密性，签名是保护信息来源真实性，摘要是保护信息的完整性。进而可以根据自己的需求，灵活的应用，比如创建一个自己的授权证书license。<br>下一节我会介绍一些算法的具体实现，以及如何实现一个license。</p><blockquote id="fn_密码学"><sup>密码学</sup>. 转自 <a href="https://juejin.cn/post/7064372860990521357">游戏不存在</a><a href="#reffn_密码学" title="Jump back to footnote [密码学] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>居酒屋hex的优化之路o</title>
      <link href="/2022/05/22/%E5%B1%85%E9%85%92%E5%B1%8B%E7%9A%84hexo%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AFo/"/>
      <url>/2022/05/22/%E5%B1%85%E9%85%92%E5%B1%8B%E7%9A%84hexo%E7%9A%84%E4%BC%98%E5%8C%96%E4%B9%8B%E8%B7%AFo/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程-email详解</title>
      <link href="/2022/05/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-email%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/05/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-email%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收-垃圾回收机制算法</title>
      <link href="/2022/05/22/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2022/05/22/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><blockquote><p>定义：<font color="#ad6598">当一个对象没有引用指向它</font>，这个对象就成为无用的内存（垃圾），就必须进行回收，以便用于后续其它对象的内存分配垃圾回收是<sup><a href="#fn_delect" id="reffn_delect">delect</a></sup></p></blockquote><h3 id="垃圾回收的实现算法"><a href="#垃圾回收的实现算法" class="headerlink" title="垃圾回收的实现算法"></a>垃圾回收的实现算法</h3><blockquote><p>引用计算算法<sup><a href="#fn_引用计算" id="reffn_引用计算">引用计算</a></sup></p><pre><code>- 实现简单，判断效率也很高，在大部分情况下它都是一个不错的算法。但是java语言并没有选用引用计数算法来管理内存，其中最主要的原因&lt;font color=&quot;#ad6598&quot;&gt;它很难解决对象之间相互循环引用&lt;/font&gt;的问题</code></pre><p>可达性分析算法（根搜索算法）<sup><a href="#fn_可达性分析" id="reffn_可达性分析">可达性分析</a></sup></p><pre><code>- 在java语言中，可以作为GC Roots对象的包含如下几种-- 1. 虚拟机栈帧（栈帧中的本地变量表）中引用的对象-- 2. 方法区中的类静态属性引用的对象-- 3. 方法区中的常量引用对象-- 4. 本地方法栈中JNI的引用的对象- 对象引用-强引用[^强引用]-- 只要引用存在，垃圾回收器永远不会回收-- obj对象对后面new Object有一个强引用，只有当obj这个引用被释放之后，对象才会被释放[^释放]掉- 对象引用-软引用[^软引用]-- 非必要引用，内存溢出之前进行回收，可以通过代码实现-- 软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引取值，无需从繁忙的真是来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正来源查询这些数据- 对象引用-弱引用[^弱引用]-- 在第二次垃圾回收的时候在进行回收-- 弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收-虚引用（幽灵/幻影引用）[^幽灵引用]-- 在垃圾回收时回收，无法通过引用取到对象值-- 虚引用主要用于检测对象是否已经从内存中删除</code></pre></blockquote><h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><blockquote><p>分代垃圾回收的提出<br>    —在java代码中，java语言没有显式的提供分配内存和删除内存方法。一些开发人员将引用对象设置为null或者调用system.gc()<sup><a href="#fn_system" id="reffn_system">system</a></sup>来释放内存<br>    — 在java中，由于开发人员没有在代码 中显式删除内存，所有垃圾回收器会去发现不需要（垃圾）的对象，然后删除它们，释放内存<br>    — 分代垃圾回收器是基于以下两个假设而创建的。<br>    — 1. 绝大多数对象在短时间内变得不可达<br>    — 2. 只有少量年老对象引用年轻对象</p><pre><code>- &lt;font color=&quot;#ad6598&quot;&gt;年轻代和老年代&lt;/font&gt;-- 年轻代：新创建的对象都存放在这里。因为大多数对象很快变得不可达，所以大多数对象在年轻代中创建，然后消失。当对象从这块内存区域消失时，我们说&lt;font color=&quot;#1ba784&quot;&gt;发生一次“minor GC”[^minorGC]&lt;/font&gt;-- 老年代：没有变的不可达，存活下来的年轻代对象被复制到这里。区域一般大于年轻代，这就意味着它有更大的规模，GC发生的次数相较于年轻代要小得多，当年轻代对象从老年代消失时，我们说&lt;font color=&quot;#1ba784&quot;&gt;“major GC”(或者“Full GC”)发生[^majorGC]&lt;/font&gt;了</code></pre></blockquote><h4 id="怎么去组织年轻代和老年代呢？"><a href="#怎么去组织年轻代和老年代呢？" class="headerlink" title="怎么去组织年轻代和老年代呢？"></a>怎么去组织年轻代和老年代呢？</h4><h5 id="年轻代组成部分"><a href="#年轻代组成部分" class="headerlink" title="年轻代组成部分"></a><font color="red">年轻代组成部分</font></h5><p>一、年轻代总共有3块空间，1块为Eden<sup><a href="#fn_Eden" id="reffn_Eden">Eden</a></sup>区,2块为Survivor<sup><a href="#fn_Survivor" id="reffn_Survivor">Survivor</a></sup>区.各个空间的执行顺序如下<br>Ⅰ、 绝大多数新创建的对象分配在Eden<br>Ⅱ、 在Eden区发生一次GC，存活的对象移到其中一个Survivor区<br>Ⅲ、 一旦一个Survivor区已满，存活的对象移动到你另外一个Survivor区，然后之前那个空间已满Survivior将置为空，没有任何数据<br>Ⅳ、经过重复多次这样的步骤后依旧存活的对象将被转移到老年区</p><h3 id="垃圾回收经典性算法"><a href="#垃圾回收经典性算法" class="headerlink" title="垃圾回收经典性算法"></a>垃圾回收经典性算法</h3><h4 id="Mark-Sweep（标记清除）算法"><a href="#Mark-Sweep（标记清除）算法" class="headerlink" title="Mark-Sweep（标记清除）算法"></a>Mark-Sweep（标记清除）算法</h4><p><img src="/img/Mark-Sweep.png"></img></p><ol><li><p>这是最基础的垃圾回收算法，之所以说它是最基础<font color="red">它最容易实现</font>，思想也是最简单的，标记清除算法分为两个阶段：标记阶段和清楚阶段。标记阶段的任务是标记出所需要被回收的对象，清除阶段就是回收被标记的对象所占用的的空间</p></li><li><p>从图中可以很容易的看出标记-清楚算法的实现起来比较容易，但是有一个比较严重的问题就是<font color="red">容易产生内存碎片</font>，碎片太多可能导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发一次新的垃圾回收动作。</p></li></ol><h4 id="Copying-复制-算法"><a href="#Copying-复制-算法" class="headerlink" title="Copying(复制)算法"></a>Copying(复制)算法</h4><p><img src="/img/Copying.png"></img></p><ol><li><p>为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来，它可以将可用内存按容量划分大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。</p></li><li><p>这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。</p></li><li><p>很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。</p></li></ol><h4 id="Mark-Compact-标记-整理-算法"><a href="#Mark-Compact-标记-整理-算法" class="headerlink" title="Mark-Compact(标记-整理)算法"></a>Mark-Compact(标记-整理)算法</h4><p><img src="/img/Mark-Compact.png"></p><ol><li>为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它并不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</li></ol><h4 id="Generational-Collection-分代收集-算法"><a href="#Generational-Collection-分代收集-算法" class="headerlink" title="Generational Collection(分代收集)算法"></a>Generational Collection(分代收集)算法</h4><ol><li><p>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。他的核心思想是根据<font color="red">对象存活的生命周期将内存划分为若干个不同的区域</font>一般情况将堆区划分为老年代（Tenured Generation）和新生代（Young Generation）,老年代的特点是<font color="red">每次垃圾收集时只有少量的对象需要被回收</font> ，而新生代的特点是&lt;font color=red”&gt;每次垃圾回收都有大量对象需要被回收&lt;/font&gt;，那么就可以给根据不同代的特点采取更适合的算法</p></li><li><p>目前大部分垃圾收集器对于新生代都采用Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说<font color="red">需要复制的操作次数较少</font>，但是实际上并不是按照1：1的比例来划分新生代的空间的，一般来说将新生代划分为一块较的Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清除原Eden和Survivor空间</p></li><li><p>由于老年代的特点是每次回收都只回收少量对象，一般使用Mark-Compact算法</p></li></ol><p>注意，在堆区之外还有一个代就是<font color="red">永久代(Permanent Generation)</font>，它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量<sup><a href="#fn_废弃常量" id="reffn_废弃常量">废弃常量</a></sup>和无用的类<sup><a href="#fn_无用的类" id="reffn_无用的类">无用的类</a></sup>。</p><blockquote id="fn_方法区"><sup>方法区</sup>. java虚拟机当中的内存的某一个区域<a href="#reffn_方法区" title="Jump back to footnote [方法区] in the text."> &#8617;</a></blockquote><blockquote id="fn_ConstantValue"><sup>ConstantValue</sup>. 是通知虚拟机自动为静态变量赋值，只有被static修饰的变量才可以使用这项属性,在实际情况下只有同时又static和final才会具有ConstantValue这个属性, [<a href="https://blog.csdn.net/honjane/article/details/51835636">参考blog—&gt;楼阁猫</a>]<a href="#reffn_ConstantValue" title="Jump back to footnote [ConstantValue] in the text."> &#8617;</a></blockquote><blockquote id="fn_例如"><sup>例如</sup>. 例如—-&gt; public static final int value = 122;<a href="#reffn_例如" title="Jump back to footnote [例如] in the text."> &#8617;</a></blockquote><blockquote id="fn_应用类"><sup>应用类</sup>. ClassA[] arr =new ClassA()<a href="#reffn_应用类" title="Jump back to footnote [应用类] in the text."> &#8617;</a></blockquote><blockquote id="fn_delect"><sup>delect</sup>. 优先级为：系统级线程<a href="#reffn_delect" title="Jump back to footnote [delect] in the text."> &#8617;</a></blockquote><blockquote id="fn_引用计算"><sup>引用计算</sup>. 它实际上是通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数加一，如果删除对该对象的引用，那么它的引用计数就减一，当该对象的引用计数为0时，那么该对象就会被回收。[<a href="https://www.jianshu.com/p/1d5fa7f6035c">参考blog —&gt;可文分身</a>]<a href="#reffn_引用计算" title="Jump back to footnote [引用计算] in the text."> &#8617;</a></blockquote><blockquote id="fn_可达性分析"><sup>可达性分析</sup>. null_暂时没写<a href="#reffn_可达性分析" title="Jump back to footnote [可达性分析] in the text."> &#8617;</a></blockquote><blockquote id="fn_强引用"><sup>强引用</sup>. Object obj =new Object()<a href="#reffn_强引用" title="Jump back to footnote [强引用] in the text."> &#8617;</a></blockquote><blockquote id="fn_释放"><sup>释放</sup>. 把这个对象设置为null<a href="#reffn_释放" title="Jump back to footnote [释放] in the text."> &#8617;</a></blockquote><blockquote id="fn_软引用"><sup>软引用</sup>. Object obj =new Object() —&gt; SoftReference<object> sf = new SoftReference<object>(obj) —&gt; obj=aaull  —&gt; sf.get()<a href="#reffn_软引用" title="Jump back to footnote [软引用] in the text."> &#8617;</a></blockquote><blockquote id="fn_弱引用"><sup>弱引用</sup>. Object obj = new Object() —&gt; WeakReference<Object> wf = new WeakRerence<Object>(obj) —&gt; obj = null —&gt; wf.get() //有时候返回null —&gt; wf.isEnQueued()<a href="#reffn_弱引用" title="Jump back to footnote [弱引用] in the text."> &#8617;</a></blockquote><blockquote id="fn_幽灵引用"><sup>幽灵引用</sup>. 主要是这一句有所改动 —&gt; PhantomReference<object> pf = new PhantomReference<object>(obj) —&gt; pf.get()  //永远返回 null<a href="#reffn_幽灵引用" title="Jump back to footnote [幽灵引用] in the text."> &#8617;</a></blockquote><p><sup><a href="#fn_无用的类" id="reffn_无用的类">无用的类</a></sup>:1、该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。2、加载该类的 ClassLoader 已经被回收。 3、该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机-生命周期</title>
      <link href="/2022/05/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2022/05/22/Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="java虚拟机"><a href="#java虚拟机" class="headerlink" title="java虚拟机"></a>java虚拟机</h1><p> java虚拟机是一个想象的中的机器，在实际的计算机上通过软件模拟实现，java虚拟机有自己想象的一切</p><h2 id="为什么使用java虚拟机"><a href="#为什么使用java虚拟机" class="headerlink" title="为什么使用java虚拟机"></a>为什么使用java虚拟机</h2><p> 实现java的跨平台特性<br> 把目标代码编译成字节码</p><h3 id="java-虚拟机的生命周期"><a href="#java-虚拟机的生命周期" class="headerlink" title="java 虚拟机的生命周期"></a>java 虚拟机的生命周期</h3><ol><li>一个运行中的java机有一个清晰的任务：执行java程序。程序开始执行时他才运行，程序结束它将一起停止，每个java程序会单独运行一个Java 虚拟机<br>通过命令行启动Java虚拟机: java xxx(类名)<br>java虚拟机总是开始于一个main方法，这个方法必须公有public，返回void,直接接收一个字符串数组，在程序执行时，必须给java虚拟机指明这个包含main方法的类名<br>如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br></pre></td></tr></table></figure><blockquote><ol><li>main方法是程序的起点，它被执行的线程初始化为程序的初始线程。程序中其它线程都有它他来启动，java的线程分为两种:守护线程（daemon）和普通线程（non-daemon）.守护线程是java虚拟机自己使用的线程，比如负责垃圾收集的线程，也可以把自己的程序设置为守护线程。包含main方法的初始线程不是守护线程</li><li>只要java虚拟机中还有普通线程在执行，java虚拟机就不会停止运行，如果有足够的权限，就可以调用exit方法终止程序</li></ol></blockquote><h3 id="java虚拟机的体系结构"><a href="#java虚拟机的体系结构" class="headerlink" title="java虚拟机的体系结构"></a>java虚拟机的体系结构</h3><blockquote><ol><li>在java虚拟机中规范中定义了一系列的子系统、内存区域、数据类型和使用指南。这些组件构成了了java虚拟机的内部结构，他们不仅仅为java虚拟机的实现提供了清晰的内部结构，更加严格规范了java虚拟实现的外部行为</li><li>每一个java虚拟机都有一个类加载器子系统（class loader subsystem），负责加载程序中的类型（类class和接口interface），并赋予唯一的名字。每一个java虚拟机都有一个执行引擎（execution engine）负责执行被加载类中包含的指令。</li></ol></blockquote><h3 id="java虚拟机中使用的数据类型"><a href="#java虚拟机中使用的数据类型" class="headerlink" title="java虚拟机中使用的数据类型"></a>java虚拟机中使用的数据类型</h3><blockquote><ol><li>所有java虚拟机中使用的数据都有明确的数据类型，数据类型和操作都在java虚拟机规定中严格定义。java中的数据类型分为：<font color=#7E7129>原始数据类型（primitive types）</font>和：<font color=#7E7129>引用数据类型(reference type)</font></li><li>在java虚拟机还存在一个java语言中不能使用的的原始数据类型——<font color="red">返回值类型（return）</font>。这种类型被用来实现java程序中的“finally lasses”</li><li>引用类型可能被创建为：类类型（class type） ,接口类型（interface type）,数组类型（array type)。他们都引用被动态创建对象。当引用类型引用null时，说明没有引用任何对象。</li></ol></blockquote><h2 id="虚拟机类加载机制概念"><a href="#虚拟机类加载机制概念" class="headerlink" title="虚拟机类加载机制概念"></a>虚拟机类加载机制概念</h2><h3 id="问题-字节码文件如何被加载到虚拟机的？"><a href="#问题-字节码文件如何被加载到虚拟机的？" class="headerlink" title="问题 字节码文件如何被加载到虚拟机的？"></a>问题 字节码文件如何被加载到虚拟机的？</h3><blockquote><p>虚拟机把描述类的数据从class文件加载到内存中，并对数据进行校验、转换解析和初始化，并最终形成可以被虚拟机直接是使用的java类型<br>java语言里，类的加载和连接过程是在程序运行过程中完成的  —-&gt;保证流畅性和完成性</p></blockquote><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><blockquote><ol><li>加载 loading<ul><li>通过一个类的全限名来获取此类的二进制字节码</li><li>将这个字节码所代表的静态存储结构转化为<sup><a href="#fn_方法区" id="reffn_方法区">方法区</a></sup>的运行时数据结构</li></ul></li><li>验证 verification<ul><li>虚拟机规范：验证输入的字节流<font color="red">是否符合class文件的存储格式</font>，否则抛出一个<font color="red">java.lang.VerifyError</font>异常</li><li>文件格式的验证：<font color="red">验证字节流是否符合class文件格式的规范</font>，并且能被当前版本的虚拟机处理。经过这个阶段的验证，字节流进入内存的方法区中进行存储。</li><li>元数据验证：对<font color="red">类的元数据信息进行语义验证</font>，保证不存在不符合java语言规范的元数据信息。</li><li>字节码验证：进行<font color="red">数据流和控制流分析，对类的方法体进行校验分析</font>，保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。</li><li>符号引用验证:发生在虚拟机<font color="red">将符号引用转化为直接引用的时候（解析阶段）</font>，对常量池中的各种符号引用的信息进行匹配性的校验。</li></ul></li><li>准备 preparation<ul><li>准备阶段是正式为 类变量 分配内存并设置 类变量 初始值（各数值类型的零值）的阶段，这些内存将在方法区中进行分配，但是如果类字段的字段属性表中存在ConstantValue属性，那再准备阶段变量值就会初始化为ConstantValue<sup><a href="#fn_ConstantValue" id="reffn_ConstantValue">ConstantValue</a></sup>属性指定的值<sup><a href="#fn_例如" id="reffn_例如">例如</a></sup></li></ul></li><li>解析 resolution<ul><li>解析阶段是在虚拟机将常量池内的符号引用替换为直接引用的过程</li><li>符号引用：符号引用以一组符号来描述所引用的目，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标<font color="red">并不一定已经加载到内存中</font></li><li>直接引用:直接引用可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。如果有了直接引用，那<font color="red">引用的目标必定已经在内存中存在</font></li></ul></li><li>初始化 initialization<ul><li><clinit>()方法：由编译器自动收集类中所有变量的赋值动作和静态语句块中语句合并产生，收集的顺序是由语句在源文件中出现的顺序决定的。</li><li>该方法与实例构造器不同<init>()不同，不需要显示的调用父类构造器。</li><li><clinit>()方法对于类或接口来不是必须的。</li><li>执行接口的<clinit>()不需要先执行父接口的<clinit>()方法</li><li>虚拟机会保证一个类的<clintt>()方法在<font color="red">多线程环境中被正确的加载和同步</font></li></ul></li><li>使用 using<br> -<font color="#ad6598">类的主要引用：</font><br> —遇到NEW、GETSTATIC、PUTSTATIC、INVOKEESTATIC这四条字节码指令时（使用new实例化对象的时候、读取或设置一个类的静态字段、调用一个类的静态方法）<br> — 使用java.long.reflet包的方法对类进行反射调用的时候<br> — 当初始化一个类的时候，如果发现其父类没有进行初始化，则需要先触发其父类的初始化<br> — 当虚拟机启动时，虚拟机会初始化主类（包含main方法的那个类）<br> -<font color="#ad6598">类的被动引用：</font><br> — 通过子类引用父类的静态字段，不会导致子类初始化（对于静态字段，只有直接定义这个字段的类才会被初始化）<br> — 通过数组来定义类应用类<sup><a href="#fn_应用类" id="reffn_应用类">应用类</a></sup>:触发了一个名为LClassA的类的初始化，它是一个由虚拟机自动生成的、直接继承于Object的类，创建动作由字节码指令newarray触发<br> — 常量会在编译阶段存入调用类的常量池</li></ol></blockquote><p>卸载 unloading</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java网络编程-socket</title>
      <link href="/2022/05/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/"/>
      <url>/2022/05/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/</url>
      
        <content type="html"><![CDATA[<h2 id="URl对象"><a href="#URl对象" class="headerlink" title="URl对象"></a>URl对象</h2><p> ipv4地址（32位，4字节）<br> ipv6地址（128位，16字节）<br> 主机名<br> 端口号 80，21，23，25-1024为保留端口<br> 服务类型 server</p><p>URL类（Uniform Resource Locator） 一致资源定位器的简称，它表示Internet上某一资源的地址<br> URL的组成 Protocol:resourceNam 协议名指的是获取资源所使用的传输协议，如http\ftp\file\等<br>  例如：public URL(String protocol,String host,String file)<br>TCP（Transport Control Protoco!）<br> 面向连接提供可靠的流式数据传输协议<br> URL、URLConnection、Socket、ServerSolet等都可以进行协议网络通信<br>  网络上的两个程序通过双向连接</p><p> Socket（）<br> Socket（InetAddress address,int port）远程目标地址 ，端口号<br> Socket（String host,int prot） 连接主机名，端口号<br> Socket（InetAddress host,int port,InetAddress localAddr,int localPort）<br> Socket(String host,int port,InetAddress localAddr,int localPort）</p><p>思考：<br> java中socket如何实现多客户机制的实现<br> 数据报是如何通信的<br> 广播是如何实现的？<br> 如何实现一个带界面的简单聊天程序？</p><p>TC有建立时间<br>UDP传输有大小限制：64kb内<br>TCP的应用：Telnet,Ftp<br>UDP的应用：ping<br>数据报的方法-&gt;&gt;<br> DatagramSocket()<br> DatagramSocket(int prot)<br> DatagramPacket(byte ibuf[],int ilength) / 接受<br> DatagramPacket(byte ibuf[],int ilength，InetAddress iaddr ,int iport) / 发送</p><p>收<br>DatagramPacket packet = new DatagramPacket(buf,260);<br>socket.receice(packet)</p><p>发<br>DatagramPacket packet = new Datapramcket(buf,buf.length,address,port);<br>socket.send(packet)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java线程-面试题合集</title>
      <link href="/2022/05/22/Java%E7%BA%BF%E7%A8%8B-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/"/>
      <url>/2022/05/22/Java%E7%BA%BF%E7%A8%8B-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java-线程</title>
      <link href="/2022/05/22/Java-%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/05/22/Java-%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="java-线程"><a href="#java-线程" class="headerlink" title="java 线程"></a>java 线程</h2><p>现成的实现和继承两者方式<br>第一种方式 继承thread类 启动线程则是start方法<br>例子<br>测试类 —&gt;&gt;<br> publi class FactorialThreadTester{<br> public static void main (String[] args)<br> {<br>  System.out.println(“main thread starts”);<br>  FactorialThread thread=new FactorialThrea(10);<br>              thread().start() //自动进入rua()方法<br>              System.out.println(“main thread ends”);</p><p> }<br> }</p><p>主代码类 —&gt;&gt;<br>public class FactorialThread extends Thread{<br>    private int num;<br>    public FactorialThread(int num){<br>        this.num=num;<br>    }</p><pre><code>/** * If this thread was constructed using a separate * &lt;code&gt;Runnable&lt;/code&gt; run object, then that * &lt;code&gt;Runnable&lt;/code&gt; object&#39;s &lt;code&gt;run&lt;/code&gt; method is called; * otherwise, this method does nothing and returns. * &lt;p&gt; * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method. * */@Overridepublic void run() &#123;</code></pre><p>//        实现阶乘计算<br>        int i=num;<br>        int result=1;<br>        System.out.println (“new thread started”);<br>        while(i&gt;0){<br>            result=result*i;<br>            i=i-1;<br>        }<br>        System.out.println (“Thread factorial of\t”+num+”\tis\t”+result);<br>        System.out.println (“new thread ends”);<br>    }<br>}</p><p>Thread详解<br>常用api接口<br> public Thread() 构造方法<br> public Thread(Runnable target) 构造新的线程对象<br> public Thread(String name) 构造一个新的线程对象，并同时指定线程名<br> public static Thread currentThread() 返回当前正在运行的线程对象<br> public static void yield() 使当前线程对象暂停，运行别的线程开始<br> public static void sleep(long millis)  使当前线程暂停运行指定毫秒数，但此线程并不会失去已经获得的锁<br> public void start() 启动线程 同时运行两个线程（当前线程以及run()）但是并不是执行线程执行线程去决定于线程调度器<br> public void run() thread的子类应该重写此方法，内容为需要执行的任务代码<br> public void stop() 停止线程运行，释放该线程占用的对象锁<br> public vodi interrupt() 中断此线程<br> public final void jojn() 如果此前启动了线程a，调用jojn方法将等待线程a死亡才能继续执行当前线程<br> public final void jojn(long millis) 如果此前启动了线程a，调用jojn方法将等待指定毫秒数或线程a死亡才能继续执行当前线程<br> public final setPriority(int newPriority) 设置线程优先级<br> public final void set Daemon(Boolean on) 设置是否为后台进程，如果当前运行线程均为后台线程则jvm停止运行。这个方法必须在start（）方法前使用<br> public final void checkAccess() 判断当前线程是否有权力修改调<br>用此方法的线程<br> public void setName(String name) 更改本线程的名称指定参数<br> public final boolean isAlive() 测试线程是否处于活动状态下，如果线程被启动并且没有死亡则返回true</p><p>使用Runnable创建线程</p><p>测试  —&gt;&gt;<br>public class FactorialThreadTester {<br>    public static void main(String[] args) {<br>        System.out.println (“main thread starts”);<br>        FactorialThread thread = new FactorialThread (10);  //实现了Runnable的类<br>        new Thread (thread).start (); //运行FactorialThread的run<br>        String name = new Thread (thread).getName ();<br>        System.out.println (name);<br>        System.out.println (“new thread started,main thread ends”);</p><pre><code>&#125;</code></pre><p>}</p><p>主代码类  —&gt;&gt;<br>public class FactorialThread  implements Runnable{<br>    private int num;</p><pre><code>public FactorialThread(int num) &#123;    this.num = num;&#125;/** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object&#39;s * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see Thread#run() */@Overridepublic void run() &#123;    int i = num;    int result =1;    while(i&gt;0)&#123;        result=result*i;        i=i-1;    &#125;    System.out.println (&quot;The factorial of \t&quot;+num+&quot;\tis\t&quot;+result);    System.out.println (&quot;new thread ends&quot;);&#125;</code></pre><p>}</p><p> 两种线程构造方式的比较<br>使用runnable接口<br> 可以将cpu,代码和数据分离开，形成清晰的数据模型，还可以从其它类继承<br>直接继承thread类<br> 编写简单，直接继承，重写run方法，不能再从其他类继承</p><p>线程数据共享<br> 同一实现Runnable接口对象作为参数创建多个线程<br> 多个线程共享同一对象中的相同数据<br>例子 —&gt;&gt;<br>thread1going to sleep for344<br>thread2going to sleep for344<br>thread3going to sleep for344<br>  备注：应为是runnable实现的线程主体，所以这三个线程就共享了这个对象的私有成员sleepTime，所以都会休眠344毫秒</p><p>一、线程的锁机制<br> 生产者/消费者问题—-&gt;锁机制中经典问题<br>  存票线程结束了，而售票线程经过休眠1秒过后又被线程控制器唤醒，而这时由于存票线程已经结束了就不存在将t.available设置为true就会导致这个线程进入无解循环<br>二、线程的优先级<br>三、多线程的同步控制</p><p> 有时候线程之间彼此不独立，需要”同步”<br>  线程之间的”互斥” （同时运行几个线程需要共享数据 ，共享数据时在某一时刻只允许一个线程访问该共享数据，因此有些方法或程序段在同一时刻只能被一个线程执行，称为监视区）<br>  线程之间的“协作”（多个线程可以在有条件地同时操作共享数据。执行监视区代码的线程在条件满足地情况下可以允许其他线程进入监视区）<br>          线程同步关键字 —&gt;&gt; synchronized 实现互斥<br>  用于指定需要同步地代码段或者方法，也就是监视区<br>  可实现与一个锁的交互。例如<br>   synchronized(对象){代码段}<br>  synchronized：首先判断对象锁是否存在，如果存在则先获取锁，然后就可以执行紧随其后的代码段；如果对象锁不在（已被其他线程拿走），就进入的等待阶段，直至获取锁<br>  synchronized：限定代码执行完成，就会释放所获得锁<br> 注：线程休眠不会释放锁 线程可以获得多个锁 线程损害并发性 说明获取那个对象的锁</p><p>线程的等待 —&gt;&gt;wait<br> 为了更加有效协同不同线程的工作，需要在线程间建立沟通渠道，通过线程间的“对话“，来解同步问题<br> wait来源于-&gt;(java.lang.Ogject) 该线程执行暂停进入等待池，并释放以获得的锁，等待其他线程唤醒</p><p>后台线程<br> 也叫守护线程，通常是为了辅助其它线程而运行的线程<br> 它不妨碍程序终止<br> 一个进程只要还有一个前台线程在运行，这个进程就不会结束；如果一个进程中的所有前台线程都已经结束，那么无论是否还有未结束的后台线程，这个进程都会结束<br> “垃圾回收”便是一个后台线程<br> 如果对某个线程对象在启动（调用start方法）之前调用了setDaemon(true),这个线程自然就成为后台线程</p><p>线程的生命周期<br> 线程从产生到消亡的过程<br> 一个线程在任何时刻都处于不同的状态<br>  诞生状态（刚被创建）-&gt;救赎状态（star已经被执行）-&gt;运行状态-&gt;阻塞状态-&gt;休眠状态-&gt;死亡状态<br> 死锁状态： 线程在运行过程中，其中某一个步骤往往需要满足一些条件才能继续进行下去，如果这个条件不满足，线程将在这个步骤阻塞</p><p>线程的调度<br> 在单cpu的系统中，多个线程需要共享cpu，在任何时间点上实际上只能有一个线程在执行<br> 控制多个线程在统一cpu上以某种规则顺序运行称为线程调度<br> java虚拟机支持一种非常简单，确定的调度算法，叫做固定优先级算法，这个算法基于线程的优先级对其进行调度</p><p>那什么是优先级呢？<br> 每个线程都有一个优先级，其范围都在1和10之间。默认情况下，每个线程的优先级都设置为5（即创建未作任何更改的情况下都为这个）<br> 在线程a运行过程中创建的新的线程对象b，初始状态具有和线程a相同的优先级<br> 如果a是后台线程，则b亦是后台线程<br> 可在线程创建之后的任何时候，通过setPriority(int priority)方法改变其原来的优先级</p><p>固定优先级算法 —&gt;&gt; 基于线程优先级的线程调度<br> 具有较高优先级的线程比优先级较低的线程优先执行<br> 对具有相同优先级的线程，java的处理时随机的<br> 底层操作系统支持的优先级可能会少于10个，这样会造成一些混乱，因此，只能将优先级作为一种很粗略的工具使用，最后控制可以通过yield()来完成<br>  yield() —&gt;&gt; 可以将本线程线程让出cpu资源，让给同等级优先级线程执行，如果同等级优先级只有它一个依旧是它本身执行</p><p>结论：</p><p>线程安全与线程兼容与对立<br> 线程安全的定义<br>  线程安全：当多个线程访问同一对象时，如果不用考虑这些线程在运行环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。 —-From Brian Goetz《Java Concurrency ln Practice》<br> Java线程安全<br>  不可变、绝对线程安全、相对线程安全、线程兼容和对立<br>不可变  final修饰过的、string、枚举类型、Number的子类、Biginteger,BigDecimal(数值类型的高精度实现)<br>绝对线程安全：满足Brian Goetz在《Java Concurrency ln Practice》中定义的线程为绝对线程安全、java API中标注自己是线程安全的类绝大部分不是绝对线程安全的<br>相对线程安全：通常意义上的线程安全，需要保证这个对象单独操作是线程安全的，调用的时候不需要做额外的保证措施，但是对于一些特定顺序的连续调用，就需要在调用时使用同步手段保证调用的正确性<br>线程兼容：对象本身不是线程安全的，但是可以通过在调用端正常地使用同步手段来保证线程对象在并发环境下可以安全使用<br>线程对立：无论 调用端是否采用了同步措施，都无法在多线程环境中并发使用代码</p><p>线程是安全实现： 互斥同步、非阻塞同步、无同步方案</p><p>同步地实现方式：<br>临界区（Critical Section）、互斥量（Mutex）、信号量（Semaphone）<br> synchronized关键字：经过编译后，会在同步块前后形成monitorenter和monitorexit两个字节码<br>  —synchronized 同步块对自己是可以重入的，不会将自己锁死<br>  —同步块在已进入的线程执行完之前，会阻塞后面其他线程进入<br>重入锁ReentrantLock (java.util.concurrent)<br>相比采用synchronized ，重入锁可实现，等待可中断，公平锁、锁可以绑定多个线程<br>synchronized 表现为原生语法层面上的互斥锁，而ReentrantLock 表现为api层面的互斥锁</p><p>非阻塞同步实现方案：<br> 阻塞同步:互斥同步存在的问题是进行线程阻塞和唤醒所带来的性能问题，这种同步被称为阻塞同步（Blocking Synchronization）这是一种悲观并发策略<br> 非阻塞同步：不同于悲观并发策略，而是使用基于冲突检测的乐观并发策略，就是先进行操作，如果没有其他线程征用共享数据，则操作成功，否则就是发生冲突，采取不断重试直到成功为止的策略，这种策略不需要把线程挂起，称为非阻塞同步<br>使用硬件处理器指令进行不断重测策略（jdk1.5）<br> 测试并设置（Test-and-Set）、获取并增加(Fetch-and-Increment)、交换(Swap)、比较并交换（Compare-and-Swap，简称CAS）、加载链接，条件存储（Load-Linked,Store-conditional,简称LL,SC<br> 例如：java实现类AtomicInteger,AtomicDouble等</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Meven使用管理本地依赖</title>
      <link href="/2022/05/22/Meven%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96/"/>
      <url>/2022/05/22/Meven%E4%BD%BF%E7%94%A8%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96/</url>
      
        <content type="html"><![CDATA[<p>mvn install:install-file -Dfile=jar包的位置 -DgroupId=一般是公司名倒序 -DartifactId=唯一型ID -Dversion=版本号 -Dpackaging=jar</p><p>例如：添加fastdfs的jar包<br>1，在jar包所在文件夹，点击鼠标右键-在此处打开命令窗口<br>2，输入命令<br>mvn install:install-file -Dfile=fastdfs_client_v1.20.jar -DgroupId=com.hueason -DartifactId=fastdfs_client -Dversion=1.20 -Dpackaging=jar<br>3，回车，看到install success<br>然后就可以在项目pom文件中引入<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hueason<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastdfs_client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>1、添加本地jar包到maven中   —&gt; commons-dbutils<br>mvn install:install-file -Dfile=commons-dbutils-1.7.jar -DgroupId=site.xinchen -DartifactId=commons-dbutils -Dversion=1.7 -Dpackaging=jar</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式框架-kafka</title>
      <link href="/2022/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6-kafka/"/>
      <url>/2022/05/22/%E5%88%86%E5%B8%83%E5%BC%8F%E6%A1%86%E6%9E%B6-kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka知识总结"><a href="#Kafka知识总结" class="headerlink" title="Kafka知识总结"></a><strong>Kafka知识总结</strong></h1><h2 id="一、讲讲acks参数对消息持久化的影响"><a href="#一、讲讲acks参数对消息持久化的影响" class="headerlink" title="一、讲讲acks参数对消息持久化的影响"></a><strong>一、讲讲acks参数对消息持久化的影响</strong></h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h3><ol><li>写在前面</li><li>如何保证宕机时数据不丢失？</li><li>多副本之间数据如何同步？</li><li>ISR到底指的是什么东西？</li><li>acks参数的含义？</li><li>最后的思考</li></ol><h3 id="1-写在前面"><a href="#1-写在前面" class="headerlink" title="1.写在前面"></a><strong>1.写在前面</strong></h3><p>面试大厂时，一旦简历上写了Kafka，几乎必然会被问到一个问题：说说acks参数对消息持久化的影响？</p><p>这个acks参数在kafka的使用中，是非常核心以及关键的一个参数，决定了很多东西。</p><p>所以无论是为了面试还是实际项目使用，大家都值得看一下这篇文章对Kafka的acks参数的分析，以及背后的原理。</p><h3 id="2-如何保证宕机的时候数据不丢失？（或者kafka如何保证高可用、或者Kafka如何保证高可用）"><a href="#2-如何保证宕机的时候数据不丢失？（或者kafka如何保证高可用、或者Kafka如何保证高可用）" class="headerlink" title="2.如何保证宕机的时候数据不丢失？（或者kafka如何保证高可用、或者Kafka如何保证高可用）"></a><strong>2.如何保证宕机的时候数据不丢失？（或者kafka如何保证高可用、或者Kafka如何保证高可用）</strong></h3><ul><li><p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p></li><li><p>而且Kafka还提供replica<strong>副本机制</strong>，每个partition的数据都会同步到其他机器上，形成自己的多个replica副本。所有replica会选举出来一个leader出来，那么<strong>生产和消费都跟这个leader打交道</strong>，然后其他replica就是follower。写的时候，leader会负责把数据同步到所有follower上去，读的时候就直接读leader上的数据即可。</p></li></ul><p>如果某个broker宕机了，那个broker上的partition在其他机器上都有副本。如果这个宕机的broker上面有某个partition的leader，那么从follower中重新选举一个新的leader出来，然后继续读写新的leader即可，这就是所谓的高可用。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/1.jpg" alt=""></p><h3 id="3-多副本之间数据如何保证同步"><a href="#3-多副本之间数据如何保证同步" class="headerlink" title="3.多副本之间数据如何保证同步"></a>3.<strong>多副本之间数据如何保证同步</strong></h3><p>其实任何一个Partition，只有Leader是对外提供读写服务的，也就是说，如果有一个客户端往一个Partition写入数据，此时一般就是写入这个Partition的Leader副本。</p><p>然后Leader副本接收到数据之后，Follower副本会不停的给他发送请求尝试去拉取最新的数据，拉取到自己本地后，写入磁盘中。如下图所示：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/2.jpg" alt=""></p><h3 id="4-ISR到底指的是什么东西？"><a href="#4-ISR到底指的是什么东西？" class="headerlink" title="4.ISR到底指的是什么东西？"></a><strong>4.ISR到底指的是什么东西？</strong></h3><p>ISR全称是“In-Sync Replicas”，也就是<strong>保持同步的副本</strong>，他的含义就是，跟Leader始终保持同步的Follower有哪些。</p><p>大家可以想一下 ，如果说某个Follower所在的Broker因为JVM FullGC之类的问题，导致自己卡顿了，无法及时从Leader拉取同步数据，那么是不是会导致Follower的数据比Leader要落后很多？</p><p>所以这个时候，就意味着Follower已经跟Leader不再处于同步的关系了。但是只要Follower一直及时从Leader同步数据，就可以保证他们是处于同步的关系的。</p><p>所以每个Partition都有一个ISR，这个ISR里一定会有Leader自己，因为Leader肯定数据是最新的，然后就是那些跟Leader保持同步的Follower，也会在ISR里。</p><h3 id="5-acks参数的含义"><a href="#5-acks参数的含义" class="headerlink" title="5.acks参数的含义"></a><strong>5.acks参数的含义</strong></h3><p>首先这个acks参数，是在KafkaProducer，也就是生产者客户端里设置的</p><p>也就是说，你往kafka写数据的时候，就可以来设置这个acks参数。然后这个参数实际上有三种常见的值可以设置，分别是：<strong>0、1 和 all</strong>。</p><p><strong>第一种选择是把acks参数设置为0</strong>，意思就是我的KafkaProducer在客户端，只要把消息发送出去，不管那条数据有没有在哪怕Partition Leader上落到磁盘，我就不管他了，直接就认为这个消息发送成功了。</p><p>如果你采用这种设置的话，那么你必须注意的一点是，可能你发送出去的消息还在半路。结果呢，Partition Leader所在Broker就直接挂了，然后结果你的客户端还认为消息发送成功了，此时就会<strong>导致这条消息就丢失了</strong>。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/3.jpg" alt=""></p><p><strong>第二种选择是设置 acks = 1</strong>，意思就是说只要Partition Leader接收到消息而且写入本地磁盘了，就认为成功了，不管他其他的Follower有没有同步过去这条消息了。</p><p>这种设置其实是<strong>kafka默认的设置</strong></p><p>也就是说，默认情况下，你要是不管acks这个参数，只要Partition Leader写成功就算成功。</p><p>但是这里有一个问题，万一Partition Leader刚刚接收到消息，Follower还没来得及同步过去，结果Leader所在的broker宕机了，此时也会导致这条消息丢失，因为人家客户端已经认为发送成功了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/4.jpg" alt=""></p><p><strong>最后一种情况，就是设置acks=all</strong>，这个意思就是说，<strong>Partition Leader接收到消息之后，还必须要求ISR列表里跟Leader保持同步的那些Follower都要把消息同步过去</strong>，才能认为这条消息是写入成功了。</p><p>如果说Partition Leader刚接收到了消息，但是结果Follower没有收到消息，此时Leader宕机了，那么客户端会感知到这个消息没发送成功，他会重试再次发送消息过去。</p><p>此时可能Partition 2的Follower变成Leader了，此时ISR列表里只有最新的这个Follower转变成的Leader了，那么只要这个新的Leader接收消息就算成功了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/5.jpg" alt=""></p><h3 id="6-最后的思考"><a href="#6-最后的思考" class="headerlink" title="6.最后的思考"></a><strong>6.最后的思考</strong></h3><p>acks=all 就可以代表数据一定不会丢失了吗？</p><p>当然不是，如果你的Partition只有一个副本，也就是一个Leader，任何Follower都没有，你认为acks=all有用吗？</p><p>当然没用了，因为ISR里就一个Leader，他接收完消息后宕机，也会导致数据丢失。</p><p>所以说，<strong>这个acks=all，必须跟ISR列表里至少有2个以上的副本配合使用</strong>，起码是有一个Leader和一个Follower才可以。</p><p>这样才能保证说写一条数据过去，一定是2个以上的副本都收到了才算是成功，此时任何一个副本宕机，不会导致数据丢失。</p><p><strong>参考</strong>：<a href="https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A">https://mp.weixin.qq.com/s/IxS46JAr7D9sBtCDr8pd7A</a></p><h2 id="二、Kafka参数调优实战"><a href="#二、Kafka参数调优实战" class="headerlink" title="二、Kafka参数调优实战"></a>二、Kafka参数调优实战</h2><h3 id="目录-1"><a href="#目录-1" class="headerlink" title="目录"></a>目录</h3><ol><li>背景引入：很多同学看不懂的Kafka参数</li><li>一段Kafka生产端的示例代码</li><li>内存缓冲的大小</li><li>多少数据打包为一个Batch合适？</li><li>要是一个Batch迟迟无法凑满怎么办？</li><li>最大请求大小</li><li>重试机制</li><li>持久化机制</li></ol><h4 id="1、背景引入：很多同学看不懂的kafka参数"><a href="#1、背景引入：很多同学看不懂的kafka参数" class="headerlink" title="1、背景引入：很多同学看不懂的kafka参数"></a>1、背景引入：很多同学看不懂的kafka参数</h4><p>在使用Kafka的客户端编写代码与服务器交互的时候，是需要对客户端设置很多的参数的。</p><h4 id="2、一段Kafka生产端的示例代码"><a href="#2、一段Kafka生产端的示例代码" class="headerlink" title="2、一段Kafka生产端的示例代码"></a>2、一段Kafka生产端的示例代码</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> props = <span class="keyword">new</span> <span class="type">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>); </span><br><span class="line">props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;buffer.memory&quot;</span>, <span class="number">67108864</span>); </span><br><span class="line">props.put(<span class="string">&quot;batch.size&quot;</span>, <span class="number">131072</span>); </span><br><span class="line">props.put(<span class="string">&quot;linger.ms&quot;</span>, <span class="number">100</span>); </span><br><span class="line">props.put(<span class="string">&quot;max.request.size&quot;</span>, <span class="number">10485760</span>); </span><br><span class="line">props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;1&quot;</span>); </span><br><span class="line">props.put(<span class="string">&quot;retries&quot;</span>, <span class="number">10</span>); </span><br><span class="line">props.put(<span class="string">&quot;retry.backoff.ms&quot;</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">KafkaProducer</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; producer = <span class="keyword">new</span> <span class="type">KafkaProducer</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt;(props);</span><br></pre></td></tr></table></figure><h4 id="3、内存缓冲的大小"><a href="#3、内存缓冲的大小" class="headerlink" title="3、内存缓冲的大小"></a>3、内存缓冲的大小</h4><p>首先看看“<strong>buffer.memory</strong>”这个参数是什么意思？</p><p>Kafka的客户端发送数据到服务器，一般都是要经过<strong>缓冲</strong>的，也就是说，<strong>通过KafkaProducer发送出去的消息都是先进入到客户端本地的内存缓冲里，然后把很多消息收集成一个一个的Batch，再发送到Broker上去的</strong>。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/6.jpg" alt=""></p><p>所以这个“<strong>buffer.memory”的本质就是用来约束KafkaProducer能够使用的内存缓冲的大小的，他的默认值是32MB</strong>。</p><p>你可以先想一下，如果这个内存缓冲设置的过小的话，可能会导致一个什么问题？</p><p>首先要明确一点，那就是在内存缓冲里大量的消息会缓冲在里面，形成一个一个的Batch，每个Batch里包含多条消息。</p><p>然后KafkaProducer有一个Sender线程会把多个Batch打包成一个Request发送到Kafka服务器上去。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/7.jpg" alt=""></p><p>那么如果要是<strong>内存设置的太小</strong>，可能<strong>导致一个问题</strong>：消息快速的写入内存缓冲里面，但是Sender线程来不及把Request发送到Kafka服务器。</p><p>这样是不是会造成内存缓冲很快就被写满？一旦被写满，就会阻塞用户线程，不让继续往Kafka写消息了。</p><p>所以对于“buffer.memory”这个参数应该结合自己的实际情况来进行压测，你需要测算一下在生产环境，你的用户线程会以每秒多少消息的频率来写入内存缓冲。</p><p>比如说每秒300条消息，那么你就需要压测一下，假设内存缓冲就32MB，每秒写300条消息到内存缓冲，是否会经常把内存缓冲写满？经过这样的压测，你可以调试出来一个合理的内存大小。</p><h4 id="4、多少数据打包为一个Batch合适？"><a href="#4、多少数据打包为一个Batch合适？" class="headerlink" title="4、多少数据打包为一个Batch合适？"></a>4、多少数据打包为一个Batch合适？</h4><p>接着你需要思考第二个问题，就是你的“<strong>batch.size</strong>”应该如何设置？<strong>这决定了你的每个Batch要存放多少数据就可以发送出去了</strong>。</p><p>比如说你要是给一个Batch设置成是16KB的大小，那么里面凑够16KB的数据就可以发送了。</p><p>这个<strong>参数的默认值是16KB</strong>，一般可以尝试把这个参数调节大一些，然后利用自己的生产环境发消息的负载来测试一下。</p><p>比如说发送消息的频率就是每秒300条，那么如果比如“batch.size”调节到了32KB，或者64KB，是否可以提升发送消息的整体吞吐量。</p><p>因为理论上来说，提升batch的大小，可以允许更多的数据缓冲在里面，那么一次Request发送出去的数据量就更多了，这样吞吐量可能会有所提升。</p><p>但是<strong>不能无限的大</strong>，过于大了之后，要是数据老是缓冲在Batch里迟迟不发送出去，那么岂不是你发送消息的延迟就会很高，<strong>导致高延迟问题</strong>。</p><p>比如说，一条消息进入了Batch，但是要等待5秒钟Batch才凑满了64KB，才能发送出去。那这条消息的延迟就是5秒钟。</p><p>所以需要在这里按照生产环境的发消息的速率，调节不同的Batch大小自己测试一下最终出去的吞吐量以及消息的 延迟，设置一个最合理的参数。</p><h4 id="5、要是一个Batch迟迟无法凑满怎么办？"><a href="#5、要是一个Batch迟迟无法凑满怎么办？" class="headerlink" title="5、要是一个Batch迟迟无法凑满怎么办？"></a>5、要是一个Batch迟迟无法凑满怎么办？</h4><p>要是一个Batch迟迟无法凑满，此时就需要引入另外一个参数了，“<strong>linger.ms</strong>”</p><p><strong>含义是一个Batch被创建之后，最多过多久，不管这个Batch有没有写满，都必须发送出去了</strong>。</p><p>给大家举个例子，比如说batch.size是16kb，但是现在某个低峰时间段，发送消息很慢。</p><p>这就导致可能Batch被创建之后，陆陆续续有消息进来，但是迟迟无法凑够16KB，难道此时就一直等着吗？</p><p>当然不是，假设你现在设置“linger.ms”是50ms，那么只要这个Batch从创建开始到现在已经过了50ms了，哪怕他还没满16KB，也要发送他出去了。</p><p>所以“linger.ms”决定了你的消息一旦写入一个Batch，最多等待这么多时间，他一定会跟着Batch一起发送出去。</p><p>避免一个Batch迟迟凑不满，导致消息一直积压在内存里发送不出去的情况。<strong>这是一个很关键的参数。</strong></p><p>这个参数一般要非常慎重的来设置，要配合batch.size一起来设置。</p><p>举个例子，首先假设你的Batch是32KB，那么你得估算一下，正常情况下，一般多久会凑够一个Batch，比如正常来说可能20ms就会凑够一个Batch。</p><p>那么你的linger.ms就可以设置为25ms，也就是说，正常来说，大部分的Batch在20ms内都会凑满，但是你的linger.ms可以保证，哪怕遇到低峰时期，20ms凑不满一个Batch，还是会在25ms之后强制Batch发送出去。</p><p>如果要是你把linger.ms设置的太小了，比如说默认就是0ms，或者你设置个5ms，那可能导致你的Batch虽然设置了32KB，但是经常是还没凑够32KB的数据，5ms之后就直接强制Batch发送出去，这样也不太好其实，会导致你的Batch形同虚设，一直凑不满数据。</p><h4 id="6、最大请求大小"><a href="#6、最大请求大小" class="headerlink" title="6、最大请求大小"></a>6、最大请求大小</h4><p><strong>“max.request.size”这个参数决定了每次发送给Kafka服务器请求的最大大小</strong>，同时也会限制你一条消息的最大大小也不能超过这个参数设置的值，这个其实可以根据你自己的消息的大小来灵活的调整。</p><p>给大家举个例子，你们公司发送的消息都是那种大的报文消息，每条消息都是很多的数据，一条消息可能都要20KB。</p><p>此时你的batch.size是不是就需要调节大一些？比如设置个512KB？然后你的buffer.memory是不是要给的大一些？比如设置个128MB？</p><p>只有这样，才能让你在大消息的场景下，还能使用Batch打包多条消息的机制。但是此时“max.request.size”是不是也得同步增加？</p><p>因为可能你的一个请求是很大的，默认他是1MB，你是不是可以适当调大一些，比如调节到5MB？</p><h4 id="7、重试机制"><a href="#7、重试机制" class="headerlink" title="7、重试机制"></a>7、重试机制</h4><p><strong>“retries”和“retries.backoff.ms”决定了重试机制，也就是如果一个请求失败了可以重试几次，每次重试的间隔是多少毫秒</strong>。</p><p>这个大家适当设置几次重试的机会，给一定的重试间隔即可，比如给100ms的重试间隔。</p><h4 id="8、持久化机制"><a href="#8、持久化机制" class="headerlink" title="8、持久化机制"></a>8、持久化机制</h4><p>“acks”参数决定了发送出去的消息要采用什么样的持久化策略，这个涉及到了很多其他的概念，大家可以参考之前专门为“acks”写过的一篇文章。</p><p><strong>参考</strong>：<a href="https://mp.weixin.qq.com/s/YLrGg-jx5ddmHECmdccppw"></a></p><h2 id="三、消息中间件消费到的消息处理失败怎么办？"><a href="#三、消息中间件消费到的消息处理失败怎么办？" class="headerlink" title="三、消息中间件消费到的消息处理失败怎么办？"></a>三、消息中间件消费到的消息处理失败怎么办？</h2><p>消息中间件最核心的作用是：解耦、异步、削峰。</p><p>假如有如下的系统：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/8.jpg" alt=""></p><p>生产中存在这种情况：如果独立仓库系统或者第三方物流系统故障了，导致仓储系统消费到一条订单消息之后，尝试进行发货失败，也就是对这条消费到的消息处理失败。这种情况，怎么处理？</p><h4 id="死信队列的使用：处理失败的消息"><a href="#死信队列的使用：处理失败的消息" class="headerlink" title="死信队列的使用：处理失败的消息"></a>死信队列的使用：处理失败的消息</h4><p>一般生产环境中，如果你有丰富的架构设计经验，都会在使用MQ的时候设计两个队列：一个是<strong>核心业务队列</strong>，一个是<strong>死信队列</strong>。</p><p>核心业务队列，就是比如上面专门用来让订单系统发送订单消息的，然后另外一个死信队列就是用来处理异常情况的。</p><p>面试被问到这个问题时，必须要结合你自己的业务实践经验来说。</p><p>比如说要是第三方物流系统故障了，此时无法请求，那么仓储系统每次消费到一条订单消息，尝试通知发货和配送，都会遇到对方的接口报错。</p><p>此时仓储系统就可以把这条消息拒绝访问，或者标志位处理失败！<strong>注意，这个步骤很重要。</strong></p><p>一旦标志这条消息处理失败了之后，MQ就会把这条消息转入提前设置好的一个死信队列中。</p><p>然后你会看到的就是，在第三方物流系统故障期间，所有订单消息全部处理失败，全部会转入死信队列。</p><p>然后你的仓储系统得专门有一个后台线程，监控第三方物流系统是否正常，能否请求的，不停的监视。</p><p>一旦发现对方恢复正常，这个后台线程就从死信队列消费出来处理失败的订单，重新执行发货和配送的通知逻辑。</p><p><strong>死信队列的使用，其实就是MQ在生产实践中非常重要的一环，也就是架构设计必须要考虑的</strong>。</p><p>整个过程，如下图所示：</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/9.jpg" alt=""></p><h2 id="四、Kafka选举"><a href="#四、Kafka选举" class="headerlink" title="四、Kafka选举"></a>四、Kafka选举</h2><p>Kafka中的选举大致可以分为三大类：</p><ul><li>控制器的选举</li><li>分区leader的选举</li><li>消费者相关的选举</li></ul><h4 id="1、控制器选举"><a href="#1、控制器选举" class="headerlink" title="1、控制器选举"></a>1、控制器选举</h4><p>在Kafka集群中会有一个或多个broker，其中有一个broker会被选举为控制器（Kafka Controller），它负责管理整个集群中所有分区和副本的状态等工作。</p><p>比如<strong>当某个分区的leader副本出现故障时，由控制器负责为该分区选举新的leader副本</strong>。再比如当检测到某个分区的ISR集合发生变化时，由控制器负责通知所有broker更新其元数据信息。</p><p>Kafka Controller的选举是依赖Zookeeper来实现的，在Kafka集群中那个broker能够成功创建/controller这个临时（Ephemeral）节点他就可以成为Kafka Controller。</p><p>这里需要说明一下的是Kafka Controller的实现还是相当复杂的，涉及到各个方面的内容，如果你掌握了Kafka Controller，你就掌握了Kafka的“半壁江山”。</p><h4 id="2、分区leader的选举"><a href="#2、分区leader的选举" class="headerlink" title="2、分区leader的选举"></a>2、分区leader的选举</h4><p>分区leader副本的选举<strong>由Kafka Controller 负责具体实施</strong>。</p><p>当创建分区（创建主题或增加分区都有创建分区的动作）或分区上线（比如分区中原先的leader副本下线，此时分区需要选举一个新的leader上线来对外提供服务）的时候都需要执行leader的选举动作。</p><p>基本思路是按照AR集合中副本的顺序查找第一个存活的副本，并且这个副本在ISR集合中。</p><p>一个分区的AR集合在分配的时候就被指定，并且只要不发生重分配的情况，集合内部副本的顺序是保持不变的，而分区的ISR集合中副本的顺序可能会改变。</p><p>注意：这里是根据AR的顺序而不是ISR的顺序进行选举的。这个说起来比较抽象，有兴趣的读者可以手动关闭/开启某个集群中的broker来观察一下具体的变化。</p><p>还有一些情况也会发生分区leader的选举，比如当分区进行重分配（reassign）的时候也需要执行leader的选举动作。</p><p>这个思路比较简单：从重分配的AR列表中找到第一个存活的副本，且这个副本在目前的ISR列表中。</p><p>再比如当发生优先副本（preferred replica partition leader election）的选举时，直接将优先副本设置为leader即可，AR集合中的第一个副本即为优先副本。</p><p>还有一种情况就是当某节点被优雅地关闭（也就是执行ControlledShutdown）时，位于这个节点上的leader副本都会下线，所以与此对应的分区需要执行leader的选举。</p><p>这里的具体思路为：从AR列表中找到第一个存活的副本，且这个副本在目前的ISR列表中，与此同时还要确保这个副本不处于正在被关闭的节点上。</p><h4 id="3、消费者相关的选择"><a href="#3、消费者相关的选择" class="headerlink" title="3、消费者相关的选择"></a>3、消费者相关的选择</h4><p>组协调器GroupCoordinator需要为消费组内的消费者选举出一个消费组的leader，这个选举的算法也很简单，分两种情况分析。</p><ul><li><p><strong>如果消费组内还没有leader，那么第一个加入消费组的消费者即为消费组的leader</strong>。</p></li><li><p><strong>如果某一时刻leader消费者由于某些原因退出了消费组，那么会重新选举一个新的leader，这个重新选举leader的过程又更“随意”了，相关代码如下</strong>：</p></li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//scala code.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> members = <span class="keyword">new</span> mutable.<span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">MemberMetadata</span>]</span><br><span class="line"><span class="keyword">var</span> leaderId = members.keys.head</span><br></pre></td></tr></table></figure><p>解释一下这2行代码：在GroupCoordinator中消费者的信息是以HashMap的形式存储的，其中key为消费者的member_id，而value是消费者相关的元数据信息。</p><p>leaderId表示leader消费者的member_id，它的取值为HashMap中的第一个键值对的key，这种选举的方式基本上和随机无异。</p><p>总体上来说，消费组的leader选举过程是很随意的。</p><p>到这里就结束了吗？还有分区分配策略的选举呢。</p><p>或许你对此有点陌生，但是用过Kafka的同学或许对partition.assignment.strategy（取值为RangeAssignor、RoundRobinAssignor、StickyAssignor等）这个参数并不陌生。</p><p>每个消费者都可以设置自己的分区分配策略，对消费组而言需要从各个消费者呈报上来的各个分配策略中选举一个彼此都“信服”的策略来进行整体上的分区分配。</p><p>这个分区分配的选举并非由leader消费者决定，而是根据消费组内的各个消费者投票来决定的。</p><p><strong>参考</strong>：<a href="https://mp.weixin.qq.com/s/XvDpq1xxXPzRoRKMO-MxeQ"></a></p><h2 id="五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）"><a href="#五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）" class="headerlink" title="五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）"></a>五、如何保证消息不被重复消费？（如何保证消息消费的幂等性）</h2><h3 id="面试官心理分析"><a href="#面试官心理分析" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h3><p>其实这是很常见的一个问题，这俩问题基本可以连起来问。既然是消费消息，那肯定要考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？这个是 MQ 领域的基本问题，其实本质上还是问你<strong>使用消息队列如何保证幂等性</strong>，这个是你架构里要考虑的一个问题。</p><h3 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h3><p>回答这个问题，首先大概说一说可能会有哪些重复消费的问题。</p><p>首先，比如 RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，挑 Kafka 来举个例子，说说怎么重复消费吧。</p><p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（<strong>定时定期</strong>），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p><p>但是，你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是<strong>没来得及提交 offset，重启之后，少数消息会再次消费一次</strong>。</p><p>例如，数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 <code>offset=153</code> 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1/2 的 offset 并没有提交，kafka 也就不知道你已经消费了 <code>offset=153</code> 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1/2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/10.png" alt=""></p><p><strong>如何保证消息队列消费的幂等性</strong>？</p><p>回答这个问题需要结合业务思考，有如下几个思路：</p><ul><li>比如数据要写库，先根据主键查一下，如果这数据都有了，就别插入了，update 一下。</li><li>比如是写 Redis，那没问题了，因为每次都是 set，天然幂等性。</li><li>比如不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面<strong>加一个全局唯一的 id</strong>，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，就别处理，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/11.png" alt=""></p><h2 id="六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）"><a href="#六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）" class="headerlink" title="六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）"></a>六、如何保证消息的可靠性传输？（如何处理消息丢失的问题？）</h2><h2 id="面试官心理分析-1"><a href="#面试官心理分析-1" class="headerlink" title="面试官心理分析"></a>面试官心理分析</h2><p>这个是肯定的，用 MQ 有个基本原则，就是<strong>数据不能多一条，也不能少一条</strong>，不能多，就是前面说的[重复消费和幂等性问题。不能少，就是说这数据别搞丢了。那这个问题你必须得考虑一下。</p><p>如果说你这个是用 MQ 来传递非常核心的消息，比如说计费、扣费的一些消息，那必须确保这个 MQ 传递过程中<strong>绝对不会把计费消息给弄丢</strong>。</p><h2 id="面试题剖析-1"><a href="#面试题剖析-1" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>数据的丢失问题，可能出现在<strong>生产者、MQ、消费者</strong>中，从 Kafka 来分析一下。</p><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h3 id="1、消费者丢失数据"><a href="#1、消费者丢失数据" class="headerlink" title="1、消费者丢失数据"></a>1、消费者丢失数据</h3><p>唯一可能导致消费者弄丢数据的情况，是消费到了这个消息，然后消费者那边<strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p><p>由于 Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是<strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><p>生产环境碰到的一个问题是Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p><h3 id="2、Kafka弄丢数据"><a href="#2、Kafka弄丢数据" class="headerlink" title="2、Kafka弄丢数据"></a>2、Kafka弄丢数据</h3><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。如果此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p><p>所以此时一般是要求起码设置如下 4 个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code>：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code>（很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h3 id="3、生产者会不会弄丢数据？"><a href="#3、生产者会不会弄丢数据？" class="headerlink" title="3、生产者会不会弄丢数据？"></a>3、生产者会不会弄丢数据？</h3><p>如果按照上述的思路设置了 <code>acks=all</code>，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p><h2 id="七、如何保证消息的顺序性？"><a href="#七、如何保证消息的顺序性？" class="headerlink" title="七、如何保证消息的顺序性？"></a>七、如何保证消息的顺序性？</h2><p>Kafka：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</p><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/12.png" alt=""></p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个<strong>内存 queue</strong>，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><p><img src="https://github.com/XU-ZHOU/Java/blob/master/pictures/13.png" alt=""></p><!-- 转载， -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-循环链表</title>
      <link href="/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-链表</title>
      <link href="/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h3><p>介绍<br>    链表是有序(是由各个对象的指决定的)的按照线性顺序排序，但是它在内存中是存储如下<br>        <img src='img/链表.png' text='内存中实际结构'><br>        小结：<br>            1）、每个链表是以节点的方式来存储,是链式结构<br>            2）、每个节点包含data域，nex域，指向下有一个节点<br>            3）、如图，发现每个链表的各个节点不一定是连续存放（存储）的<br>            4)、链表分为带头结点和不带头结点的链表，根据是实际需求来确定<br>单链表的应用实例<br>    使用带head头的<font color="red">单向链表</font>实现-水浒英雄传的排行榜管理<br>        1、完成对英雄人物的<strong>增删改查</strong>操作，<br>        2、第一种方法再添加英雄时，直接添加到链表的尾部<br>        3、第二种方式在添加英雄时，根据排名将英雄插入到指定位置（如果存在排名则插入失败，并给出提示！！）</p><h4 id="单链表的创建示意图"><a href="#单链表的创建示意图" class="headerlink" title="单链表的创建示意图"></a>单链表的创建示意图</h4><p><img src="img/单链表创建示意图.png"></p><p>关键代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助节点temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有发现最后，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">//        将最后的这个节点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="第二种插入链表思路"><a href="#第二种插入链表思路" class="headerlink" title="第二种插入链表思路"></a>第二种插入链表思路</h4><p><img src="img/顺序插入链表.png"></p><p>关键代码代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    第二种方式添加英雄，根据排名将英雄插入到指定位置（如果存在这个排名，则添加失败并给出提示~）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//应为头节点不能动，因此我们需要辅助指针（变量）来确立要添加的位置</span></span><br><span class="line">        <span class="comment">//因为单链表，因此我们找到temp是位于添加位置的前一个结点，否则插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//false标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;<span class="comment">//说明temp已经在链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no)&#123;<span class="comment">//位置找到，就在temp后面添加</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no ==heroNode.no)&#123;<span class="comment">//说明希望添加的herNode已经存在</span></span><br><span class="line">                flag =<span class="keyword">true</span>;<span class="comment">//说明编号存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp =temp.next;<span class="comment">//后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断flag的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;<span class="comment">//不能添加，编号存在</span></span><br><span class="line">            System.out.printf (<span class="string">&quot;准备插入的英雄编号%d已经存在,不能再添加了\n&quot;</span>,heroNode.no);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//插入到链表中，temp后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="修改节点的实现"><a href="#修改节点的实现" class="headerlink" title="修改节点的实现"></a>修改节点的实现</h3><p>关键代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   修改节点的信息根据no编号来修改，即no比编号不能改</span></span><br><span class="line"><span class="comment">//    根据newHeroNode的no来修改即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span></span>&#123;</span><br><span class="line"><span class="comment">//        判断为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        找需要修改的节点，根据NO的编号</span></span><br><span class="line"><span class="comment">//        定义一个辅助变量</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag =<span class="keyword">false</span>;<span class="comment">//表示是否找到节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no)&#123;</span><br><span class="line"><span class="comment">//                找到</span></span><br><span class="line">                flag =<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag，判断是否找修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//没有找到</span></span><br><span class="line">            System.out.printf (<span class="string">&quot;没有找到编号为%d的节点，不能修改\n&quot;</span>,newHeroNode.no);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h4 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h4><p>思路<br><img src="/img/链表删除节点.png"><br>1、我们先找到需要删除这个节点的前一个结点temp<br>2、temp=temp.next.next<br>3、被删除的节点将不会被其他节点所引用，会被垃圾回收机制回收<br>关键代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//删除节点</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1、head不能动，因此我们需要一个temp辅助节点找到待删除结点的前一个结点</span></span><br><span class="line"><span class="comment">//    2、说明我们在比较时，是temp.next.no和待删除结点的no比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;<span class="comment">//表示是否找到待删除节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;<span class="comment">//已经到了链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">if</span> (temp.next.no ==no)&#123;</span><br><span class="line"><span class="comment">//                找到待删除节点的前一个结点</span></span><br><span class="line">                flag =<span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp =temp.next;<span class="comment">//temp后移,遍历</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        判断flag</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;<span class="comment">//找到</span></span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.printf (<span class="string">&quot;要删除的%d节点不存在&quot;</span>,no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><!-- 待完善 --></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-环形队列的实现</title>
      <link href="/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>问题分析优化<br>1）目前数组不能复用<br>2）将这个数组使用算法，改进成为一个<font color="red">环形队列</font>（取模的方式）</p><p>环形队列思路如下<br>    1、front变量的含义做一个调整，front就指向队列第一个元素，也就是说arr[front]就是队列的第一元素front的初始值=0<br>    2、rear变量的含义做一个调整；rear指向队列的最后一个元素的后一个位置，应为希望空一个空间作为约定rear的初始值=0<br>    3、当队列满时，条件是（rear + 1）%maxSize == front【满】<br>    4、当队列为空的条件，rear==front空<br>    5、当我们这样分析，队列中有效数据的个数（rear + maxSize - front）% maxSize<br>代码实现：<br>```java<br>package com.xiaohuli.queue;</p><p>import java.util.Scanner;</p><p>/**</p><ul><li>@Author: oyster</li><li>@Description: TODO</li><li>@DateTime: 2022/1/30 0:37<br>**/<br>public class CircleArrayQueue {<br> public static void main(String[] args) {<pre><code> //测试 System.out.println (&quot;测试数组模拟环形队列是否可用&quot;); //创建一个队列 CircleArray arrayQueue = new CircleArray (3); char key = &#39; &#39;;//接受用户收入 Scanner scanner = new Scanner (System.in); boolean loop = true; //输出一个菜单 while (loop) &#123;     System.out.println (&quot;s(show):显示队列&quot;);     System.out.println (&quot;e(exit):退出队列&quot;);     System.out.println (&quot;a(add):添加数据到队列&quot;);     System.out.println (&quot;g(get):从队列取出数据&quot;);     System.out.println (&quot;h(head):查看队列头的数据&quot;);     key = scanner.next ().charAt (0);//接收一个字符串     switch (key) &#123;         case &#39;s&#39;:             arrayQueue.showQueue ();             break;         case &#39;a&#39;:             System.out.println (&quot;输入一个数&quot;);             int value = scanner.nextInt ();             arrayQueue.addQueue (value);             break;         case &#39;g&#39;://取出数据             try &#123;                 int res = arrayQueue.getQueue ();                 System.out.printf (&quot;取出的数据为%d\n&quot;, res);             &#125; catch (Exception e) &#123;                 System.out.println (e.getMessage ());//获取异常信息             &#125;             break;         case &#39;h&#39;://查看队列头的数据             try &#123;                 int res = arrayQueue.headQueue ();                 System.out.printf (&quot;队列头的数据是%d\n&quot;, res);             &#125; catch (Exception e) &#123;                 System.out.println (e.getMessage ());             &#125;             break;         case &#39;e&#39;://退出             scanner.close ();//如果不关掉会报异常信息             loop = false;             break;         default:             break;     &#125; &#125; System.out.println (&quot;程序退出~~~~~~~~&quot;);</code></pre> }</li></ul><p>}</p><p>class CircleArray {<br>    private int maxSize;//表示最大容量<br>    //        front初始化为0<br>    private int front;//队列头<br>    //        rear初始化为0<br>    private int rear;//队列尾<br>    private int[] arr;//该数组用来存放数据，模拟队列</p><pre><code>public CircleArray(int arrMaxSize) &#123;    maxSize = arrMaxSize;    arr = new int[maxSize];&#125;//判断队列是否为满public boolean isFull() &#123;    return (rear + 1) % maxSize == front;&#125;//判断队列是否为空public boolean isEmpty() &#123;    return rear == front;&#125;//添加数据到队列public void addQueue(int n) &#123;</code></pre><p>//          判断队列是满<br>        if (isFull ()) {<br>            System.out.println (“队列满，不能加入数据~”);<br>            return;<br>        }<br>        //直接将数据加入<br>        arr[rear] = n;<br>        //将rear后移,这里必须考虑取模<br>        rear = (rear + 1) % maxSize;<br>    }</p><pre><code>//        获取队列的数据，出队列public int getQueue() &#123;</code></pre><p>//            判断是否为空<br>        if (isEmpty ()) {<br>//                通过抛出异常<br>            throw new RuntimeException (“队列为空，不能取数据”);<br>        }<br>        //这里需要分析出front是指向队列的第一个元素<br>//            1、先将front对应的值保留到一个临时变量<br>//            2、将front后移<br>//            3、将临时保存的变量返回<br>        int value = arr[front];<br>        front = (front + 1) % maxSize;<br>        return value;<br>    }</p><pre><code>//        显示队列中所有数据public void showQueue() &#123;    //遍历    if (isEmpty ()) &#123;        System.out.println (&quot;队列为空&quot;);        return;    &#125;    //思路：从front开始遍历，遍历多少个元素    //动脑筋    for (int i = front; i &lt; front + size (); i++) &#123;        System.out.printf (&quot;arr[%d]=%d\n&quot;, i % maxSize, arr[i % maxSize]);    &#125;&#125;//求出当前数列有效数据的个数public int size() &#123;</code></pre><p>//            rear = 1<br>//            maxSize = 3<br>//            front =0<br>        return (rear + maxSize - front) % maxSize;<br>    }</p><pre><code>//        显示队列头数据，注意不是取出数据public int headQueue() &#123;    if (isEmpty ()) &#123;        throw new RuntimeException (&quot;队列为空，不存在数据~~·&quot;);    &#125;    return arr[front];&#125;</code></pre><p>}</p><p>// 待完善</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-队列</title>
      <link href="/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/"/>
      <url>/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>基本介绍<br>1、队列是一个有序列表，可以用数组或是链表实现<br>2、遵循先入先出原则<sup><a href="#fn_先入先出" id="reffn_先入先出">先入先出</a></sup><br>3、使用数组队列示意图（暂缺）</p><p>数组模拟队列思路<br>    1、对列本身是有序列表，若使用数据结构来存储队列的数据，则队列数组的声明如下图，其中maxSize是该队列的最大容量<br>    2、因为队列的输出，输入都是从前后端处理的，因此需要两个变量front及rear分别记录前后端的变化的下标，front会随着数据的输出而改变，而rear则是随着数据输入而改变<br>    3、当我们将数据存入队列时称为“addQueue”,addQueue的处理需要有两个步骤<br>    3.1 将尾指针往后移，rear加1，当front==rear【空】<br>    3.2 若指针rear小于队列的最大下标maxSize-1 <sup><a href="#fn_数组队列" id="reffn_数组队列">数组队列</a></sup>，则将数据存入rear所指数组元素中，否则将无法存入数据，rear = maxSize-1【队列满】<br>数组代码实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiaohuli.queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: oyster</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DateTime</span>: 2022/1/29 18:32</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个队列</span></span><br><span class="line">        ArrayQueue arrayQueue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key =<span class="string">&#x27; &#x27;</span>;<span class="comment">//接受用户收入</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner (System.in);</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop)&#123;</span><br><span class="line">            System.out.println (<span class="string">&quot;s(show):显示队列&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;e(exit):退出队列&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;a(add):添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;g(get):从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;h(head):查看队列头的数据&quot;</span>);</span><br><span class="line">            key =scanner.next ().charAt (<span class="number">0</span>);<span class="comment">//接收一个字符串</span></span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span> :</span><br><span class="line">                    arrayQueue.showQueue ();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println (<span class="string">&quot;输入一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt ();</span><br><span class="line">                    arrayQueue.addQueue (value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:<span class="comment">//取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res =arrayQueue.getQueue ();</span><br><span class="line">                        System.out.printf (<span class="string">&quot;取出的数据为%d\n&quot;</span>,res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                        System.out.println (e.getMessage ());<span class="comment">//获取异常信息</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:<span class="comment">//查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = arrayQueue.headQueue ();</span><br><span class="line">                        System.out.printf (<span class="string">&quot;队列头的数据是%d\n&quot;</span>,res);</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                       System.out.println (e.getMessage ());</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:<span class="comment">//退出</span></span><br><span class="line">                    scanner.close ();<span class="comment">//如果不关掉会报异常信息</span></span><br><span class="line">                    loop =<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println (<span class="string">&quot;程序退出~~~~~~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//使用数组模拟队列-编写一个ArrayQueue</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxSize;<span class="comment">//表示最大容量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> front;<span class="comment">//队列头</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> rear;<span class="comment">//队列尾</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//该数组用来存放数据，模拟队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建队列构造器</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span></span>&#123;</span><br><span class="line">            maxSize =arrMaxSize;</span><br><span class="line">            arr =<span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">            front =-<span class="number">1</span>;<span class="comment">//指向队列头部，分析front是指向队列头的前一个位置</span></span><br><span class="line">            rear = -<span class="number">1</span>;<span class="comment">//指向队列尾，指向队列尾的数据（即就是队列最后的一个数据）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为满</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear == maxSize-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断队列是否为空</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> rear == front;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加数据到队列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//          判断队列是满</span></span><br><span class="line">            <span class="keyword">if</span> (isFull ())&#123;</span><br><span class="line">                System.out.println (<span class="string">&quot;队列满，不能加入数据~&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rear++;<span class="comment">//让rear后移</span></span><br><span class="line">            arr[rear]=n;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        获取队列的数据，出队列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//            判断是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (isEmpty ())&#123;</span><br><span class="line"><span class="comment">//                通过抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">&quot;队列为空，不能取数据&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            front++;<span class="comment">//front后移</span></span><br><span class="line">            <span class="keyword">return</span> arr[front];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        显示队列中所有数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//遍历</span></span><br><span class="line">            <span class="keyword">if</span> (isEmpty ())&#123;</span><br><span class="line">                System.out.println (<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">                System.out.printf (<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        显示队列头数据，注意不是取出数据</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isEmpty ())&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException (<span class="string">&quot;队列为空，不存在数据~~·&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> arr[front+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote id="fn_数组队列"><sup>数组队列</sup>. 数组的下标的都是从0开始的<a href="#reffn_数组队列" title="Jump back to footnote [数组队列] in the text."> &#8617;</a></blockquote><blockquote id="fn_先入先出"><sup>先入先出</sup>. 先存入队列的数据，要先取出，后存入的数据要后取出。<a href="#reffn_先入先出" title="Jump back to footnote [先入先出] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-稀疏数组</title>
      <link href="/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="稀疏数组和队列"><a href="#稀疏数组和队列" class="headerlink" title="稀疏数组和队列"></a>稀疏数组和队列</h2><h4 id="需求编写一个五子棋程序中，有存盘退出和续上盘功能"><a href="#需求编写一个五子棋程序中，有存盘退出和续上盘功能" class="headerlink" title="需求编写一个五子棋程序中，有存盘退出和续上盘功能"></a>需求编写一个五子棋程序中，有<strong>存盘退出</strong>和<strong>续上盘</strong>功能</h4><p><img src="/img/稀疏数组.png"></p><p>分析问题：因为存在太多重复数据，所以采用稀疏数组进行压缩，以减少空间利用</p><p>基本介绍<br>当一个数组中大部分元素为0，或者为同一个值的时，，<br>处理方式<br>    记录数组一共有几行几列，有多少个不同的的值<br>    把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p><font color="red">应用实例</font><p><img src="/img/稀疏数组的过程.png"></p><p>二维数组转稀疏数组的思路<br>    1、遍历原始的二维数组，得到有效数据的个数sum<br>    2、根据sum就可以创建稀疏数组sparrseArr int[sum +1][3]<br>    3、将二维数组的有效数据存入到稀疏数组</p><p>稀疏数组转二维数组的思路<br>    1、先读取稀疏数组的第一行，根据第一行还原二维数组，比如稀疏数组后几行的数据，并赋予原始的二维数组即上面的chessArr2= int[11][11]<br>    2、在读取可剩余数据即可```<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//      将二维数组转稀疏数组</span></span><br><span class="line"><span class="comment">//        先遍历二维数组 得到非0数据个数</span></span><br><span class="line">        <span class="keyword">int</span> sum= <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2、创建相应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum +<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">//        给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历二维数组，将非0 的值存放到sparseArr中</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count用于记录是第几个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">11</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j &lt; <span class="number">11</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] !=<span class="number">0</span>)&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>]=i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>]=j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        输出稀疏数组的形式</span></span><br><span class="line">        System.out.println ();</span><br><span class="line">        System.out.println (<span class="string">&quot;得到的稀疏数组如下形式&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">            System.out.printf (<span class="string">&quot;%d\t%d\t%d\t\n&quot;</span>,sparseArr[i][<span class="number">0</span>],sparseArr[i][<span class="number">1</span>],sparseArr[i][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//           将稀疏数组 --》 恢复成二维数组</span></span><br><span class="line"><span class="comment">//            1.先读取第一行还原原始二维数组数据</span></span><br><span class="line">            <span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"><span class="comment">//            2.读取稀疏数组后几行的数据（第二行），并赋给原始的二维数据即可</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;sparseArr.length;i++)&#123;</span><br><span class="line">                    chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//四、将稀疏数组保存到磁盘上，如map.data</span></span><br><span class="line">        String path = <span class="string">&quot;D:\\idea项目\\DataStructures\\src\\main\\resources\\map.data&quot;</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File (path);</span><br><span class="line">            System.out.println(<span class="string">&quot;将稀疏数组保存到磁盘并命名为map.data&quot;</span>);</span><br><span class="line">            FileOutputStream out = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            OutputStreamWriter osw =<span class="keyword">new</span> OutputStreamWriter (out,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;开始存入二维数组~~~&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length ; i++) &#123;</span><br><span class="line">                osw.write (sparseArr[i][<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+sparseArr[i][<span class="number">1</span>]+<span class="string">&quot;,&quot;</span>+sparseArr[i][<span class="number">2</span>]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            osw.close ();<span class="comment">//关闭输出流</span></span><br><span class="line">            out.close ();<span class="comment">//关闭输出流</span></span><br><span class="line">            System.out.println (<span class="string">&quot;存储成功~~&quot;</span> );</span><br><span class="line"><span class="comment">//              开始读取磁盘中的二维数组</span></span><br><span class="line">            System.out.println (<span class="string">&quot;读取磁盘中的稀疏数组并还原为二维组~~~&quot;</span>);</span><br><span class="line">            FileInputStream inp = <span class="keyword">new</span> FileInputStream (path);</span><br><span class="line">            InputStreamReader reader = <span class="keyword">new</span> InputStreamReader (inp,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            System.out.println (<span class="string">&quot;开始读取------&quot;</span>);</span><br><span class="line">            <span class="comment">//StringBuffer主要是做一个缓冲的作用</span></span><br><span class="line">            StringBuffer sb = <span class="keyword">new</span> StringBuffer ();</span><br><span class="line">            <span class="keyword">while</span> (reader.ready ())&#123;</span><br><span class="line">                sb.append ((<span class="keyword">char</span>) reader.read ());</span><br><span class="line">            &#125;</span><br><span class="line">            inp.close ();<span class="comment">//关闭输入流</span></span><br><span class="line">            reader.close ();<span class="comment">//关闭输入流</span></span><br><span class="line">            String ss = sb.toString ();</span><br><span class="line">            System.out.printf(<span class="string">&quot;从磁盘读取的字符串\n%s\n&quot;</span>,ss);</span><br><span class="line">            String[] read = sb.toString ().split (<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="comment">//恢复成稀疏数组</span></span><br><span class="line">            <span class="keyword">int</span> arseArr[][] =<span class="keyword">new</span> <span class="keyword">int</span>[read.length/<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">int</span> sum1 =<span class="number">0</span>;</span><br><span class="line">            arseArr[<span class="number">0</span>][<span class="number">0</span>] =Integer.parseInt (read[<span class="number">0</span>]);</span><br><span class="line">            arseArr[<span class="number">0</span>][<span class="number">1</span>] = Integer.parseInt (read[<span class="number">1</span>]);</span><br><span class="line">            arseArr[<span class="number">0</span>][<span class="number">2</span>] = Integer.parseInt (read[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">3</span> ;i&lt;read.length; i +=<span class="number">3</span>)&#123;</span><br><span class="line">                sum1++;</span><br><span class="line">                arseArr[sum1][<span class="number">0</span>] = Integer.parseInt (read[i]);</span><br><span class="line">                arseArr[sum1][<span class="number">1</span>] =Integer.parseInt (read[i+<span class="number">1</span>]);</span><br><span class="line">                arseArr[sum1][<span class="number">2</span>] =Integer.parseInt (read[i+<span class="number">2</span>]);</span><br><span class="line">            &#125;            </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构概念与引入</title>
      <link href="/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BC%95%E5%85%A5/"/>
      <url>/2022/05/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构与算法的关系"><a href="#数据结构与算法的关系" class="headerlink" title="数据结构与算法的关系"></a>数据结构与算法的关系</h2><pre><code>数据data（structure）是一门研究组织数据的方式的学科，有了编程语言也就有了数据结构，程序 = 数据结构＋算法算法就是对现实事务进行高度抽象数据结构是算法的基础</code></pre><p><font color=blue> 实际开发遇到的问题</font>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    String str </span>= <span class="string">&quot;java java ,java hello hello&quot;</span></span><br><span class="line">    String newStr = str.replaceAll(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;尚佳谷&quot;</span>)</span><br><span class="line">    System.out.print(<span class="string">&quot;newStr+&quot;</span>+newStr);</span><br></pre></td></tr></table></figure></p><p>数据结构包含： 线性结构 非线结构</p><p><font color="red">线性结构</font><br>作为最常用的数据结构，其特点数据元素之间存在一对一的线性关系<br>线性结构有两种不同的存储结构，及顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的<br>链式存储的线性表称为链表，链表的元不一定是连续的，元素节点存放数据元素以及相邻的元素的地址信息<br>线性结构常见的有：数组、列表、链表、栈</p><p><font color="red">非线性结构</font><br>包含：二维数组、多维数组、广义表、树结构、图结构</p><!-- 待完善 -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>“关于微服务的疑难问题以及解决方案”</title>
      <link href="/2022/05/22/%E2%80%9C%E5%85%B3%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%9D/"/>
      <url>/2022/05/22/%E2%80%9C%E5%85%B3%E4%BA%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E2%80%9D/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/10/hello-world/"/>
      <url>/2021/10/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-yezi-3"></use></svg> 张三 Quick Start### Create a new post<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#[icon-yezi-]"></use></svg> 张三 More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组中最大数对和的最小值</title>
      <link href="/2021/07/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
      <url>/2021/07/20/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="基本分析-amp-证明"><a href="#基本分析-amp-证明" class="headerlink" title="基本分析 &amp; 证明 "></a>基本分析 &amp; 证明 <svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#[icon-yezi-]"></use></svg></h2><svg class="icon" style="width:8em; height:8em" aria-hidden="true"><use xlink:href="#[icon-yezi-3]"></use></svg><blockquote><p>直觉上，我们会认为「尽量让“较小数”和“较大数”组成数对，可以有效避免出现“较大数成对”的现象」。<br>我们来证明一下该猜想是否成立。<br>假定 numsnums 本身有序，由于我们要将 numsnums 拆分成 n / 2n/2 个数对，根据猜想，我们得到的数对序列为：</p></blockquote><p>(nums[0], nums[n - 1]), (nums[1], nums[n - 2]), … , (nums[(n / 2) - 1], nums[n / 2])(nums[0],nums[n−1]),(nums[1],nums[n−2]),…,(nums[(n/2)−1],nums[n/2])</p><font color="brack">换句话说，构成答案的数对必然是较小数取自有序序列的左边，较大数取自有序序列的右边，且与数组中心对称。</font><p>假设最大数对是 (nums[i], nums[j])(nums[i],nums[j])，其中 i &lt; ji&lt;j，记两者之和为 ans = nums[i] + nums[j]ans=nums[i]+nums[j]。</p><p>反证法证明，不存在别的数对组合会比 (nums[i], nums[j])(nums[i],nums[j]) 更优：</p><p>假设存在数对 (nums[p], nums[q])(nums[p],nums[q]) 与 (nums[i], nums[j])(nums[i],nums[j]) 进行调整使答案更优。<br><img src="贪心算法分析.png"></p><blockquote><p>接下来分情况讨论：<br>调整为 (nums[i], nums[p])(nums[i],nums[p]) 和 (nums[q], nums[j])(nums[q],nums[j])：此时最大数对答案为 nums[q] + nums[j]nums[q]+nums[j]，<br>显然nums[q] + nums[j] &gt;= nums[i] + nums[j] = ansnums[q]+nums[j]&gt;=nums[i]+nums[j]=ans。我们要最小化最大数对和，因此该调整方案不会让答案更好；&lt;/br&gt;<br>调整为 (nums[i], nums[q])(nums[i],nums[q]) 和 (nums[p], nums[j])(nums[p],nums[j])：此时最大数对答案为 max(nums[i] + nums[q], nums[p] + nums[j]) = nums[p] + nums[j] &gt;= nums[i] + nums[j] = ansmax(nums[i]+nums[q],nums[p]+nums[j])=nums[p]+nums[j]&gt;=nums[i]+nums[j]=ans。我们要最小化最大数对和，因此该调整方案不会让答案更好；<br>上述分析可以归纳推理到每一个“非对称”的数对配对中。</p></blockquote><font color="red">至此我们得证，将原本对称的数对调整为不对称的数对，不会使得答案更优，即贪心解可取得最优解。</font><h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//nums中的每个元素恰好在一个数组中且最大数的和的值最小.</span></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;n/<span class="number">2</span>;++i)&#123;</span><br><span class="line">            res =Math.max(res, nums[i]+ nums[n-<span class="number">1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>时间复杂度为：O(n log n)，其中n是nums数组的长度，排序的时间长度O(n log n),遍历堆维护最大值的和所需时间为O(n)<br>空间复杂度为：O(log n ),即为排序栈空间开销</p><h2 id="使用的算法设计—论文出处"><a href="#使用的算法设计—论文出处" class="headerlink" title="使用的算法设计—论文出处"></a>使用的算法设计—论文出处</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>分析参考至：宫水三叶</p>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相信科学系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java框架之-spring简介</title>
      <link href="/2021/07/10/java%E6%A1%86%E6%9E%B6%E4%B9%8B-spring%E7%AE%80%E4%BB%8B/"/>
      <url>/2021/07/10/java%E6%A1%86%E6%9E%B6%E4%B9%8B-spring%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>spring 是一个开源框架<br>spring 是一个轻量级、非入侵式框架<br>控制反转（ioc）,面向切面编程（AOP)<br>支持对事务的处理，对框架德整合的支持<br>总结一句话：spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）</p><div class="table-container"><table><thead><tr><th>name</th><th>id</th></tr></thead><tbody><tr><td>张三</td><td>21321</td></tr></tbody></table></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Http&amp;Https区别</title>
      <link href="/2021/07/09/Http-Https%E5%8C%BA%E5%88%AB/"/>
      <url>/2021/07/09/Http-Https%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="荷花娇欲语，愁杀荡舟人。—-李白"><a href="#荷花娇欲语，愁杀荡舟人。—-李白" class="headerlink" title="荷花娇欲语，愁杀荡舟人。— 李白"></a><font color="#c08eaf">荷花娇欲语，愁杀荡舟人。— 李白</font></h3><h2 id="Htpp"><a href="#Htpp" class="headerlink" title="Htpp"></a>Htpp</h2><blockquote><p>HyperText Transfer Protocol：超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议。简单的来说就是发布和接收html页面的方法，用于大多数页面中</p><p><font color="red">http默认工作在TCP协议80端口</font><br>http协议以明文的方式，<font color="red">不提供任何方式加密</font>，如果攻击者截取了服务器端和客户端则所有数据都会被暴露，因此http协议不适合传输一些敏感信息，比如身份证号、密码等、</p></blockquote><h2 id="Https"><a href="#Https" class="headerlink" title="Https"></a>Https</h2><blockquote><p>Hypertext Transfer Protocol Secure：超文本传输安全协议 是一种通过计算机网络进行安全通信的传输协议，Https经由Http进行通信，但利用<font color="red">SSH/TLS进行加密数据包</font>，HTTPS开发的主要目的，<font color="red">是提供网站服务器的安全，保护交互数据的安全性与完整信。</font><br>https默认工作在<font color="red">TCP协议443端口</font>工作流程如下：<br>1、TCP 三次同步握手<br>2、客户端验证服务器数字证书<br>3、DH 算法协商对称加密算法的密钥、hash 算法的密钥<br>4、SSL 安全加密隧道协商完成<br>5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</p><blockquote><p>截至 2018 年 6 月，Alexa 排名前 100 万的网站中有 34.6% 使用 HTTPS 作为默认值，互联网 141387 个最受欢迎网站的 43.1% 具有安全实施的 HTTPS，以及 45% 的页面加载（透过Firefox纪录）使用HTTPS。2017 年3 月，中国注册域名总数的 0.11％使用 HTTPS。根据 Mozilla 统计，自 2017 年 1 月以来，超过一半的网站流量被加密。</p></blockquote></blockquote><h1 id="Http-amp-amp-Https的区别"><a href="#Http-amp-amp-Https的区别" class="headerlink" title="Http&amp;&amp; Https的区别"></a>Http&amp;&amp; Https的区别</h1><blockquote><p>1、HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。<br>2、使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。<br>3、HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。<br>4、http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。<br>5、HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</p></blockquote><h1 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h1><blockquote><p>在TCP/IP协议中，TCP协议通过三次握手建立一个可靠的连接<br><img href="TCP三次握手"><br>第一次握手：客户端尝试连接服务器，向服务器发送 syn 包（同步序列编号Synchronize Sequence Numbers），syn=j，客户端进入 SYN_SEND 状态等待服务器确认<br>第二次握手：服务器接收客户端syn包并确认（ack=j+1），同时向客户端发送一个 SYN包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态<br>第三次握手：第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手<br>简化：<br><img herf="简化"></p></blockquote><h1 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h1><p><img href="HTTPS工作原理"></p><blockquote><p>1、客户端发起 HTTPS 请求这个没什么好说的，就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。<br>2、服务端的配置  采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl 就是个不错的选择，有 1 年的免费服务)。这套证书其实就是一对公钥和私钥，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p><p>3、传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><p>4、客户端解析证书这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p><p>5、传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><p>6、服务端解密信息服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><p>7、传输加密后的信息这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p><p>8、客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p></blockquote><p><a href="https://www.runoob.com/w3cnote/summary-of-network.html#_label0">参考于菜鸟教程_只是为了加强记忆</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令手册</title>
      <link href="/2021/07/09/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/"/>
      <url>/2021/07/09/Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机/重启/注销"></a>关机/重启/注销</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>shutdown -h now</td><td>即刻关机</td></tr><tr><td>shutdown -h 10</td><td>10分钟后关机</td></tr><tr><td>shutdown -h 11:00</td><td>11：00关机</td></tr><tr><td>shutdown -h +10</td><td>预定时间关机（10分钟后）</td></tr><tr><td>shutdown -c</td><td>取消指定时间关机</td></tr><tr><td>shutdown -r now</td><td>重启</td></tr><tr><td>shutdown -r 10</td><td>10分钟之后重启</td></tr><tr><td>shutdown -r 11:00</td><td>定时重启</td></tr><tr><td>reboot</td><td>重启</td></tr><tr><td>init 6</td><td>重启</td></tr><tr><td>init 0</td><td>⽴刻关机</td></tr><tr><td>telinit 0</td><td>关机</td></tr><tr><td>poweroff</td><td>⽴刻关机</td></tr><tr><td>halt</td><td>关机</td></tr><tr><td>sync</td><td>buff数据同步到磁盘</td></tr><tr><td>logout</td><td>退出登录Shell</td></tr></tbody></table></div><h1 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>uname -a</td><td>查看内核/OS/CPU信息</td></tr><tr><td>uname -r</td><td>查看内核版本</td></tr><tr><td>uname -m</td><td>查看处理器架构</td></tr><tr><td>arch</td><td>查看处理器架构</td></tr><tr><td>hostname</td><td>查看计算机名</td></tr><tr><td>who</td><td>显示当前登录系统的⽤户</td></tr><tr><td>who am i</td><td>显示登录时的⽤户名</td></tr><tr><td>whoami</td><td>显示当前⽤户名</td></tr><tr><td>cat /proc/version</td><td>查看linux版本信息</td></tr><tr><td>cat /proc/cpuinfo</td><td>查看CPU信息</td></tr><tr><td>cat /proc/interrupts</td><td>查看中断</td></tr><tr><td>cat /proc/loadavg</td><td>查看系统负载</td></tr><tr><td>uptime</td><td>查看系统运⾏时间、⽤户数、负载</td></tr><tr><td>env</td><td>查看系统的环境变量</td></tr><tr><td>lsusb -tv</td><td>查看系统USB设备信息</td></tr><tr><td>lspci -tv</td><td>查看系统PCI设备信息</td></tr><tr><td>lsmod</td><td>查看已加载的系统模块</td></tr><tr><td>grep MemTotal /proc/meminfo</td><td>查看内存总量</td></tr><tr><td>grep MemFree /proc/meminfo</td><td>查看空闲内存量</td></tr><tr><td>free -m</td><td>查看内存⽤量和交换区⽤量</td></tr><tr><td>date</td><td>显示系统⽇期时间</td></tr><tr><td>cal 2021</td><td>显示2021⽇历表</td></tr><tr><td>top</td><td>动态显示cpu/内存/进程等情况</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>查看io读写/cpu使⽤情况</td></tr><tr><td>查看io读写/cpu使⽤情况</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table></div><h1 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>fdisk -l</td><td>查看所有磁盘分区</td></tr><tr><td>swapon -s</td><td>查看所有交换分区</td></tr><tr><td>df -h</td><td>查看磁盘使⽤情况及挂载点</td></tr><tr><td>df -hl</td><td>同上</td></tr><tr><td>du -sh /dir</td><td>查看指定某个⽬录的⼤⼩</td></tr><tr><td>du -sk * \</td><td>sort -rn</td><td>从⾼到低依次显示⽂件和⽬录⼤⼩</td></tr><tr><td>mount /dev/hda2 /mnt/hda2</td><td>挂载hda2盘</td></tr><tr><td>mount -t ntfs /dev/sdc1 /mnt/usbhd1</td><td>指定⽂件系统类型挂载（如ntfs）</td></tr><tr><td>mount -o loop xxx.iso /mnt/cdrom</td><td>挂 载 iso ⽂ 件</td></tr><tr><td>umount -v /dev/sda1</td><td>通过设备名卸载</td></tr><tr><td>umount -v /mnt/mymnt</td><td>通过挂载点卸载</td></tr><tr><td>fuser -km /mnt/hda1</td><td>强制卸载(慎⽤)</td></tr></tbody></table></div><h1 id="⽤户和⽤户组"><a href="#⽤户和⽤户组" class="headerlink" title="⽤户和⽤户组"></a>⽤户和⽤户组</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>useradd codesheep</td><td>创建⽤户</td></tr><tr><td>userdel -r codesheep</td><td>删除⽤户</td></tr><tr><td>usermod -g group_name user_name</td><td>修改⽤户的组</td></tr><tr><td>usermod -aG group_name user_name</td><td>将⽤户添加到组</td></tr><tr><td>usermod -s /bin/ksh -d /home/codepig –g dev codesheep</td><td>修改⽤户codesheep的登录Shell、主⽬录以及⽤户组</td></tr><tr><td>groups test</td><td>查看test⽤户所在的组</td></tr><tr><td>groupadd group_name</td><td>创建⽤户组</td></tr><tr><td>groupdel group_name</td><td>删除⽤户组</td></tr><tr><td>groupmod -n new_name old_name</td><td>重命名⽤户组</td></tr><tr><td>su - user_name</td><td>su - user_name</td></tr><tr><td>passwd</td><td>修改⼝令</td></tr><tr><td>passwd codesheep</td><td>修改某⽤户的⼝令</td></tr><tr><td>w</td><td>查看活动⽤户</td></tr><tr><td>id codesheep</td><td>查看指定⽤户codesheep信息</td></tr><tr><td>last</td><td>查看⽤户登录⽇志</td></tr><tr><td>crontab -l</td><td>查看当前⽤户的计划任务</td></tr><tr><td>cut -d: -f1 /etc/passwd</td><td>查看系统所有⽤户</td></tr><tr><td>cut -d: -f1 /etc/group</td><td>查看系统所有组</td></tr></tbody></table></div><h1 id="⽹络和进程管理"><a href="#⽹络和进程管理" class="headerlink" title="⽹络和进程管理"></a>⽹络和进程管理</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>ifconfig</td><td>查看⽹络接⼝属性</td></tr><tr><td>ifconfig eth0</td><td>查看某⽹卡的配置</td></tr><tr><td>route -n</td><td>查看路由表</td></tr><tr><td>netstat -lntp</td><td>查看所有监听端⼝</td></tr><tr><td>netstat -antp</td><td>查看已经建⽴的TCP连接</td></tr><tr><td>netstat -lutp</td><td>查看TCP/UDP的状态信息</td></tr><tr><td>ifup eth0</td><td>启⽤eth0⽹络设备</td></tr><tr><td>ifdown eth0</td><td>禁⽤eth0⽹络设备</td></tr><tr><td>iptables -L</td><td>查看iptables规则</td></tr><tr><td>ifconfig eth0 192.168.1.1 netmask 255.255.255.0</td><td>配置ip地址</td></tr><tr><td>dhclient eth0</td><td>以dhcp模式启⽤eth0</td></tr><tr><td>route add -net 0/0 gw Gateway_IP</td><td>配置默认⽹关</td></tr><tr><td>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1</td><td>配置静态路由到达⽹络’192.168.0.0/16’</td></tr><tr><td>route del 0/0 gw Gateway_IP</td><td>删除静态路由</td></tr><tr><td>hostname</td><td>查看主机名</td></tr><tr><td>host <a href="http://www.baidu.com">www.baidu.com</a></td><td>解析主机名</td></tr><tr><td>nslookup <a href="http://www.baidu.com">www.baidu.com</a></td><td>查询DNS记录，查看域名解析是否正常</td></tr><tr><td>ps -ef</td><td>查看所有进程</td></tr><tr><td>ps -ef \</td><td>grep codesheep</td><td>过滤出你需要的进程</td></tr><tr><td>kill -s name</td><td>kill指定名称的进程</td></tr><tr><td>kill -s pid</td><td>kill指定pid的进程</td></tr><tr><td>top</td><td>实时显示进程状态</td></tr><tr><td>vmstat 1 20</td><td>每1秒采⼀次系统状态，采20次</td></tr><tr><td>iostat</td><td>iostat</td></tr><tr><td>sar -u 1 10</td><td>查询cpu使⽤情况（1秒⼀次，共10次）</td></tr><tr><td>sar -d 1 10</td><td>查询磁盘性能</td></tr></tbody></table></div><h1 id="常⻅系统服务命令"><a href="#常⻅系统服务命令" class="headerlink" title="常⻅系统服务命令"></a>常⻅系统服务命令</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>chkconfig —list</td><td>列出系统服务</td></tr><tr><td>service &lt;服务名&gt; status</td><td>查看某个服务</td></tr><tr><td>service &lt;服务名&gt; start</td><td>启动某个服务</td></tr><tr><td>service &lt;服务名&gt; stop</td><td>终⽌某个服务</td></tr><tr><td>service &lt;服务名&gt; restart</td><td>重启某个服务</td></tr><tr><td>systemctl status &lt;服务名&gt;</td><td>查看某个服务</td></tr><tr><td>systemctl start &lt;服务名&gt;</td><td>启动某个服务</td></tr><tr><td>systemctl stop &lt;服务名&gt;</td><td>终⽌某个服务</td></tr><tr><td>systemctl restart &lt;服务名&gt;</td><td>重启某个服务</td></tr><tr><td>systemctl enable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr><tr><td>systemctl disable &lt;服务名&gt;</td><td>关闭⾃启动</td></tr></tbody></table></div><h1 id="⽂件和⽬录操作"><a href="#⽂件和⽬录操作" class="headerlink" title="⽂件和⽬录操作"></a>⽂件和⽬录操作</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cd &lt;⽬录名&gt;</td><td>进⼊某个⽬录</td></tr><tr><td>cd ..</td><td>回上级⽬录</td></tr><tr><td>cd ../..</td><td>回上两级⽬录</td></tr><tr><td>cd</td><td>进个⼈主⽬录</td></tr><tr><td>cd -</td><td>回上⼀步所在⽬录</td></tr><tr><td>pwd</td><td>显示当前路径</td></tr><tr><td>ls</td><td>查看⽂件⽬录列表</td></tr><tr><td>ls -F</td><td>查看⽬录中内容（显示是⽂件还是⽬录）</td></tr><tr><td>ls -l</td><td>查看⽂件和⽬录的详情列表</td></tr><tr><td>ls -a</td><td>查看隐藏⽂件</td></tr><tr><td>ls -lh</td><td>查看⽂件和⽬录的详情列表（增强⽂件⼤⼩易读性）</td></tr><tr><td>ls -lSr</td><td>查看⽂件和⽬录列表（以⽂件⼤⼩升序查看）</td></tr><tr><td>tree</td><td>查看⽂件和⽬录的树形结构</td></tr><tr><td>mkdir &lt;⽬录名&gt;</td><td>创建⽬录</td></tr><tr><td>mkdir dir1 dir2</td><td>同时创建两个⽬录</td></tr><tr><td>mkdir -p /tmp/dir1/dir2</td><td>创建⽬录树</td></tr><tr><td>rm -f file1</td><td>删除’file1’⽂件</td></tr><tr><td>rmdir dir1</td><td>删除’dir1’⽬录</td></tr><tr><td>rm -rf dir1</td><td>删除’dir1’⽬录和其内容</td></tr><tr><td>rm -rf dir1 dir2</td><td>同时删除两个⽬录及其内容</td></tr><tr><td>mv old_dir new_dir</td><td>重命名/移动⽬录</td></tr><tr><td>cp file1 file2</td><td>复制⽂件</td></tr><tr><td>cp dir/* .</td><td>复制某⽬录下的所有⽂件⾄当前⽬录</td></tr><tr><td>cp -a dir1 dir2</td><td>复制⽬录</td></tr><tr><td>cp -a /tmp/dir1 .</td><td>复制⼀个⽬录⾄当前⽬录</td></tr><tr><td>ln -s file1 link1</td><td>创建指向⽂件/⽬录的软链接</td></tr><tr><td>ln file1 lnk1</td><td>创建指向⽂件/⽬录的物理链接</td></tr><tr><td>find / -name file1</td><td>从跟⽬录开始搜索⽂件/⽬录</td></tr><tr><td>find / -user user1</td><td>搜索⽤户user1的⽂件/⽬录</td></tr><tr><td>find /dir -name *.bin</td><td>在⽬录/dir中搜带有.bin后缀的⽂件</td></tr><tr><td>locate &lt;关键词&gt;</td><td>快速定位⽂件</td></tr><tr><td>locate *.mp4</td><td>寻找.mp4结尾的⽂件</td></tr><tr><td>whereis &lt;关键词&gt;</td><td>显示某⼆进制⽂件/可执⾏⽂件的路径</td></tr><tr><td>which &lt;关键词&gt;</td><td>查找系统⽬录下某的⼆进制⽂件</td></tr><tr><td>chmod ugo+rwx dir1</td><td>设置⽬录所有者(u)、群组(g)及其他⼈(o)的读（r）写(w)执⾏(x)权限</td></tr><tr><td>chmod go-rwx dir1</td><td>移除群组(g)与其他⼈(o)对⽬录的读写执⾏权限</td></tr><tr><td>chown user1 file1</td><td>改变⽂件的所有者属性</td></tr><tr><td>chown -R user1 dir1</td><td>改变⽬录的所有者属性</td></tr><tr><td>chgrp group1 file1</td><td>改变⽂件群组</td></tr><tr><td>chown user1:group1 file1</td><td>改变⽂件的所有⼈和群组</td></tr></tbody></table></div><h1 id="⽂件查看和处理"><a href="#⽂件查看和处理" class="headerlink" title="⽂件查看和处理"></a>⽂件查看和处理</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>cat file1</td><td>查看⽂件内容</td></tr><tr><td>cat -n file1</td><td>查看内容并标示⾏数</td></tr><tr><td>tac file1</td><td>从最后⼀⾏开始反看⽂件内容</td></tr><tr><td>more file1</td><td>more file1</td></tr><tr><td>less file1</td><td>类似more命令，但允许反向操作</td></tr><tr><td>head -2 file1</td><td>查看⽂件前两⾏</td></tr><tr><td>tail -2 file1</td><td>查看⽂件后两⾏</td></tr><tr><td>tail -f /log/msg</td><td>实时查看添加到⽂件中的内容</td></tr><tr><td>grep codesheep hello.txt</td><td>在⽂件hello.txt中查找关键词codesheep</td></tr><tr><td>grep ^sheep hello.txt</td><td>在⽂件hello.txt中查找以sheep开头的内容</td></tr><tr><td>grep [0-9] hello.txt</td><td>选择hello.txt⽂件中所有包含数字的⾏</td></tr><tr><td>sed ‘s/s1/s2/g’ hello.txt</td><td>将hello.txt⽂件中的s1替换成s2</td></tr><tr><td>sed ‘/^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有空⽩⾏</td></tr><tr><td>sed ‘/ *#/d; /^$/d’ hello.txt</td><td>从hello.txt⽂件中删除所有注释和空⽩⾏</td></tr><tr><td>sed -e ‘1d’ hello.txt</td><td>从⽂件hello.txt 中排除第⼀⾏</td></tr><tr><td>sed -n ‘/s1/p’ hello.txt</td><td>查看只包含关键词”s1”的⾏</td></tr><tr><td>sed -e ‘s/ *$//‘ hello.txt</td><td>删除每⼀⾏最后的空⽩字符</td></tr><tr><td>sed -e ‘s/s1//g’ hello.txt</td><td>从⽂档中只删除词汇s1并保留剩余全部</td></tr><tr><td>sed -n ‘1,5p;5q’ hello.txt</td><td>查看从第⼀⾏到第5⾏内容</td></tr><tr><td>sed -n ‘5p;5q’ hello.txt</td><td>查看第5⾏</td></tr><tr><td>paste file1 file2</td><td>合并两个⽂件或两栏的内容</td></tr><tr><td>paste -d ‘+’ file1 file2</td><td>合并两个⽂件或两栏的内容，中间⽤”+”区分</td></tr><tr><td>sort file1 file2</td><td>排序两个⽂件的内容</td></tr><tr><td>comm -1 file1 file2</td><td>⽐较两个⽂件的内容(去除’file1’所含内容)</td></tr><tr><td>comm -2 file1 file2</td><td>⽐较两个⽂件的内容(去除’file2’所含内容</td></tr><tr><td>comm -3 file1 file2</td><td>⽐较两个⽂件的内容(去除两⽂件共有部分)</td></tr></tbody></table></div><h1 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>zip xxx.zip file</td><td>压缩⾄zip包</td></tr><tr><td>zip -r xxx.zip file1 file2 dir1</td><td>将多个⽂件+⽬录压成zip包</td></tr><tr><td>unzip xxx.zip</td><td>解压zip包</td></tr><tr><td>tar -cvf xxx.tar file</td><td>创建⾮压缩tar包</td></tr><tr><td>tar -cvf xxx.tar file1 file2 dir1</td><td>将多个⽂件+⽬录打tar包</td></tr><tr><td>tar -tf xxx.tar</td><td>查看tar包的内容</td></tr><tr><td>tar -xvf xxx.tar</td><td>解压tar包</td></tr><tr><td>tar -xvf xxx.tar -C /dir</td><td>将tar包解压⾄指定⽬录</td></tr><tr><td>tar -cvfj xxx.tar.bz2 dir</td><td>创建bz2压缩包</td></tr><tr><td>tar -jxvf xxx.tar.bz2</td><td>解压bz2压缩包</td></tr><tr><td>tar -cvfz xxx.tar.gz dir</td><td>创建gzip压缩包</td></tr><tr><td>tar -zxvf xxx.tar.gz</td><td>解压gzip压缩包</td></tr><tr><td>bunzip2 xxx.bz2</td><td>解压bz2压缩包</td></tr><tr><td>bzip2 filename</td><td>压缩⽂件</td></tr><tr><td>gunzip xxx.gz</td><td>解压gzip压缩包</td></tr><tr><td>gzip filename</td><td>压缩⽂件</td></tr><tr><td>gzip -9 filename</td><td>最⼤程度压缩</td></tr></tbody></table></div><h1 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>rpm -qa</td><td>查看已安装的rpm包</td></tr><tr><td>rpm -q pkg_name</td><td>查询某个rpm包</td></tr><tr><td>rpm -q —whatprovides xxx</td><td>显示xxx功能是由哪个包提供的</td></tr><tr><td>rpm -q —whatrequires xxx</td><td>显示xxx功能被哪个程序包依赖的</td></tr><tr><td>rpm -q —changelog xxx</td><td>显示xxx包的更改记录</td></tr><tr><td>rpm -qi pkg_name</td><td>查看⼀个包的详细信息</td></tr><tr><td>rpm -qd pkg_name</td><td>查询⼀个包所提供的⽂档</td></tr><tr><td>rpm -qc pkg_name</td><td>查看已安装rpm包提供的配置⽂件</td></tr><tr><td>rpm -ql pkg_name</td><td>查看⼀个包安装了哪些⽂件</td></tr><tr><td>rpm -qf filename</td><td>查看某个⽂件属于哪个包</td></tr><tr><td>rpm -qR pkg_name</td><td>查询包的依赖关系</td></tr><tr><td>rpm -ivh xxx.rpm</td><td>安装rpm包</td></tr><tr><td>rpm -ivh —test xxx.rpm</td><td>测试安装rpm包</td></tr><tr><td>rpm -ivh —nodeps xxx.rpm</td><td>安装rpm包时忽略依赖关系</td></tr><tr><td>rpm -e xxx</td><td>卸载程序包</td></tr><tr><td>rpm -Fvh pkg_name</td><td>升级确定已安装的rpm包</td></tr><tr><td>rpm -Uvh pkg_name</td><td>升级rpm包(若未安装则会安装)</td></tr><tr><td>rpm -V pkg_name</td><td>RPM包详细信息校验</td></tr></tbody></table></div><h1 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>yum repolist enabled</td><td>显示可⽤的源仓库</td></tr><tr><td>yum search pkg_name</td><td>搜索软件包</td></tr><tr><td>yum install pkg_name</td><td>下载并安装软件包</td></tr><tr><td>yum install —downloadonly pkg_name</td><td>只 下 载 不 安 装</td></tr><tr><td>yum list</td><td>显示所有程序包</td></tr><tr><td>yum list installed</td><td>查看当前系统已安装包</td></tr><tr><td>yum list updates</td><td>查看可以更新的包列表</td></tr><tr><td>yum check-update</td><td>查看可升级的软件包</td></tr><tr><td>yum update</td><td>更新所有软件包</td></tr><tr><td>yum update pkg_name</td><td>升级指定软件包</td></tr><tr><td>yum deplist pkg_name</td><td>列出软件包依赖关系</td></tr><tr><td>yum remove pkg_name</td><td>删除软件包</td></tr><tr><td>yum clean all</td><td>清除缓存</td></tr><tr><td>yum clean packages</td><td>清除缓存的软件包</td></tr><tr><td>yum clean headers</td><td>清除缓存的header</td></tr></tbody></table></div><h1 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>dpkg -c xxx.deb</td><td>列出deb包的内容</td></tr><tr><td>dpkg -i xxx.deb</td><td>安装/更新deb包</td></tr><tr><td>dpkg -r pkg_name</td><td>移除deb包</td></tr><tr><td>dpkg -P pkg_name</td><td>移除deb包(不保留配置)</td></tr><tr><td>dpkg -l</td><td>查看系统中已安装deb包</td></tr><tr><td>dpkg -l pkg_name</td><td>显示包的⼤致信息</td></tr><tr><td>dpkg -L pkg_name</td><td>查看deb包安装的⽂件</td></tr><tr><td>dpkg -s pkg_name</td><td>查看包的详细信息</td></tr><tr><td>dpkg –unpack xxx.deb</td><td>解开deb包的内容</td></tr></tbody></table></div><h1 id="APT软件⼯具"><a href="#APT软件⼯具" class="headerlink" title="APT软件⼯具"></a>APT软件⼯具</h1><div class="table-container"><table><thead><tr><th>常用命令</th><th>作用</th></tr></thead><tbody><tr><td>apt-cache search pkg_name</td><td>搜索程序包</td></tr><tr><td>apt-cache show pkg_name</td><td>获取包的概览信息</td></tr><tr><td>apt-get install pkg_name</td><td>安装/升级软件包</td></tr><tr><td>apt-get purge pkg_name</td><td>卸载软件（包括配置）</td></tr><tr><td>apt-get remove pkg_name</td><td>卸载软件（不包括配置）</td></tr><tr><td>apt-get update</td><td>更新包索引信息</td></tr><tr><td>apt-get upgrade</td><td>更新已安装软件包</td></tr><tr><td>apt-get clean</td><td>清理缓存</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Liunx相关命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sparklogistics回归之用户分类</title>
      <link href="/2021/06/22/Sparklogistics%E5%9B%9E%E5%BD%92%E4%B9%8B%E7%94%A8%E6%88%B7%E5%88%86%E7%B1%BB/"/>
      <url>/2021/06/22/Sparklogistics%E5%9B%9E%E5%BD%92%E4%B9%8B%E7%94%A8%E6%88%B7%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Scala初&amp;&amp;传奇之路</title>
      <link href="/2021/06/17/Scala%E5%88%9D-%E4%BC%A0%E5%A5%87%E4%B9%8B%E8%B7%AF/"/>
      <url>/2021/06/17/Scala%E5%88%9D-%E4%BC%A0%E5%A5%87%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Scala-简介"><a href="#Scala-简介" class="headerlink" title="Scala 简介"></a>Scala 简介</h1><blockquote><p>Scala是Scalable Language的简写，是一门多范式的编程语言，由联邦理工学院洛桑（EPFL）的Martin Odersky于2001年基于Funnel的工作开始设计</p><blockquote><p>设计初衷是要集成面向对象编程和函数式编程的各种特性。</p><blockquote><p>因此Scala是一种纯面向对象的语言，每个值都是对象。同时Scala也是一种函数式语言，其函数也能当成值来使用。由于 Scala整合了面向对象语言和函数式编程的特性，Scala相对于Java、C#、C++等其他语言更加简洁。<br/><br>Scala源代码被编译成Java字节码<br>所以它可以运行于JVM之上，并可以调用现有的Java类库。Scala一开始就打算基于Java的生态系统发展自身，而这令Scala受益匪浅。</p></blockquote></blockquote></blockquote><h2 id="Scala-特性"><a href="#Scala-特性" class="headerlink" title="Scala 特性"></a>Scala 特性</h2><blockquote><p>1、面向对象<br>2、函数式编程<br>3、静态类型<br>4、Scala是可被扩展的 (提供了一个独特的语言机制来实现)</p><p>4.1、隐式类： 允许给已有的类型添加扩展方法</p><blockquote><p>隐式类是在scala 2.10中引入的，隐式类指的是用implicit关键字修饰的类。在对应的作用域内，带有这个关键字的类的主构造函数可用于隐式转换。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Helpers</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">IntWithTimes</span>(<span class="params">x: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">times</span></span>[<span class="type">A</span>](f: =&gt; <span class="type">A</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">loop</span></span>(current: <span class="type">Int</span>): <span class="type">Unit</span> =</span><br><span class="line">        <span class="keyword">if</span>(current &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          f</span><br><span class="line">          loop(current - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      loop(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>定义了一个隐式类IntWithTimes， 它有一个接收Int类型的构造函数，和一个times方法。那么当我们将这个类引入到我们自己的作用域时，Int类型就拥有了新的times方法  引入便可以使用<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">import</span> <span class="type">Helpers</span>._</span><br><span class="line"><span class="keyword">import</span> <span class="type">Helpers</span>._</span><br></pre></td></tr></table></figure><br>隐式类有以下限制条件</p><p>1、只能在别的trait/类/对象内部定义<br>2、构造函数只能携带一个非隐式参数<br>3、在同一作用域内，不能有任何方法、成员或对象与隐式类同名,注意：这意味着隐式类不能是case class</p></blockquote><p>4.2、字符串插值： 可以让用户使用自定义的插值器进行扩展 &lt;/br&gt; SCala提供了三种创新插值的方法：s,f,raw</p><blockquote><p>字符串插值就是将变量引用直接插入处理过的字面字符中。 这是在scala2.10.0版本引入的。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name=<span class="string">&quot;James&quot;</span></span><br><span class="line">println(<span class="string">s&quot;Hello,<span class="subst">$name</span>&quot;</span>)<span class="comment">//Hello,James</span></span><br></pre></td></tr></table></figure><br>s插值器<br>s”Hello,$name” 是待处理字符串字面，编译器会对它做额外的工作。待处理字符串字面通过“号前的字符来标示</p></blockquote><p>f插值器<br>在任何字符串字面前加上 f，就可以生成简单的格式化串，功能相似于其他语言中的 printf 函数。当使用 f 插值器的时候，所有的变量引用都应当后跟一个printf-style格式的字符串<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> height=<span class="number">1.9</span>d</span><br><span class="line"><span class="keyword">val</span> name=<span class="string">&quot;James&quot;</span></span><br><span class="line">println(<span class="string">f&quot;<span class="subst">$name</span>%s is <span class="subst">$height</span>%2.2f meters tall&quot;</span>)<span class="comment">//James is 1.90 meters tall f 插值器是类型安全的。如果试图向只支持 int 的格式化串传入一个double 值，编译器则会报错。例如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> height:<span class="type">Double</span>=<span class="number">1.9</span>d</span><br><span class="line"></span><br><span class="line">scala&gt;<span class="string">f&quot;<span class="subst">$height</span>%4d&quot;</span></span><br><span class="line">&lt;console&gt;:<span class="number">9</span>: error: <span class="class"><span class="keyword">type</span> <span class="title">mismatch</span></span>;</span><br><span class="line"> found : <span class="type">Double</span></span><br><span class="line"> required: <span class="type">Int</span></span><br><span class="line">           <span class="string">f&quot;<span class="subst">$height</span>%4d&quot;</span></span><br><span class="line">              ^ f 插值器利用了java中的字符串数据格式。这种以%开头的格式在 [<span class="type">Formatter</span> javadoc] 中有相关概述。如果在具体变量后没有%，则格式化程序默认使用 %s（串型）格式。</span><br></pre></td></tr></table></figure><br>raw 插值器<br>除了对字面值中的字符不做编码外，raw 插值器与 s 插值器在功能上是相同的<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scala&gt;<span class="string">s&quot;a\nb&quot;</span></span><br><span class="line">res0:<span class="type">String</span>=</span><br><span class="line">a</span><br><span class="line">b 这里，s 插值器用回车代替了\n。而raw插值器却不会如此处理。</span><br><span class="line"></span><br><span class="line">scala&gt;<span class="string">raw&quot;a\nb&quot;</span></span><br><span class="line">res1:<span class="type">String</span>=a\nb 当不想输入\n被转换为回车的时候，raw 插值器是非常实用的。</span><br></pre></td></tr></table></figure><br>自定义插值器<br>在Scala中，所有处理过的字符串字面值都进行了简单编码转换。任何时候编译器遇到一个如下形式的字符串字面值：id”string content” 它都会被转换成一个StringContext实例的call(id)方法。这个方法在隐式范围内仍可用。只需要简单得 建立一个隐类，给StringContext实例增加一个新方法，便可以定义我们自己的字符串插值器。如<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonHelper</span>(<span class="params">val sc:<span class="type">StringContext</span></span>) <span class="keyword">extends</span> <span class="title">AnyVal</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">json</span></span>(args:<span class="type">Any</span>*):<span class="type">JSONObject</span>=sys.error(<span class="string">&quot;TODO-IMPLEMENT&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">giveMeSomeJson</span></span>(x:<span class="type">JSONObject</span>):<span class="type">Unit</span>=...</span><br><span class="line"></span><br><span class="line">giveMeSomeJson(<span class="string">json&quot;&#123;name:<span class="subst">$name</span>,id:<span class="subst">$id</span>&#125;&quot;</span>) </span><br></pre></td></tr></table></figure></p><blockquote><p>在这个例子中，我们试图通过字符串插值生成一个JSON文本语法。隐类 JsonHelper 作用域内使用该语法，且这个JSON方法需要一个完整的实现。只不过，字符串字面值格式化的结果不是一个字符串，而是一个JSON对象。 注：JSON方法可以访问字符串的原生片段而每个表达式都是一个值。</p></blockquote></blockquote><p>当编译器遇到”{name:name,id:name,id:id”}”，它将会被重写成如下表达式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">&quot;&#123;name:&quot;</span>,<span class="string">&quot;,id:&quot;</span>,<span class="string">&quot;&#125;&quot;</span>).json(name,id)</span><br></pre></td></tr></table></figure></p><p>隐类则被重写成如下形式:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">JsonHelper</span>(<span class="keyword">new</span> <span class="type">StringContext</span>(<span class="string">&quot;&#123;name:&quot;</span>,<span class="string">&quot;,id:&quot;</span>,<span class="string">&quot;&#125;&quot;</span>)).json(name,id)</span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote><p>可扩展的scala <a href="https://www.cnblogs.com/flydean/p/12680354.html">https://www.cnblogs.com/flydean/p/12680354.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark初_架构原理</title>
      <link href="/2021/06/16/Spark%E5%88%9D-%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
      <url>/2021/06/16/Spark%E5%88%9D-%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark之来龙去脉"><a href="#Spark之来龙去脉" class="headerlink" title="Spark之来龙去脉"></a>Spark之来龙去脉</h1><blockquote><p>1、是一种快速、分布式、可扩展、容错率的 &lt;&gt;计算框架<br/><br>2、基于内存计算大数据分布式框架、是替代hadoop mapreduce的替代方案，替代迭代算法设计和交互式查询，支持内存存储和高效的容错恢复，Spark拥有MapReduce具有的所有优点，但不同于MapReduce，Spark的中间操作可以保存到内存中，减少读写HDFS的次数，有效提高性能</p></blockquote><h2 id="Spark的发展历程"><a href="#Spark的发展历程" class="headerlink" title="Spark的发展历程"></a>Spark的发展历程</h2><blockquote><p>2009年，Spark诞生于伯克利大学AMPLab，最初属于伯克利大学的研究性项目,实验室的研究人员之前是从事基于Hadoop mapreduce工作的，他们发现 MapReduce对于迭代和交互式计算任务效率不高，因此他们研究的Spark主要为交互式查询和迭代算法设计，支持内存存储和高效的容错恢复。<br><img src="http://qufl2gk64.hb-bkt.clouddn.com/Spark历程.png"></p></blockquote><h2 id="Spark-特点"><a href="#Spark-特点" class="headerlink" title="Spark 特点"></a>Spark 特点</h2><blockquote><p>快速</p><blockquote><p>一般情况下，对于迭代次数多的应用程序，Sapark在内存中运行速度是hadoop的100多倍，在磁盘运行速度是hadoop Mapreduce 运行速度的10多倍。<br><img src="http://qufl2gk64.hb-bkt.clouddn.com/运行速度对比.png"></p></blockquote><p>易用</p><blockquote><p>Spark支持使用Scala、Python、Java及R语言快速编写应用。同时Spark提供超过80个高级运算符，使得编写并行应用程序变得容易并且可以在Scala、Python或R的交互模式下使用Spark。</p></blockquote><p>通用</p><blockquote><p> Spark可以与SQL、Streaming及复杂的分析良好结合。Spark还有一系列的高级工具，包括Spark SQL、MLlib（机器学习库）、GraphX（图计算）和Spark Streaming，并且支持在一个应用中同时使用这些组件。</p></blockquote><p>随处执行</p><blockquote><p>用户可以使用Spark的独立集群模式运行Spark，也可以在EC2（亚马逊弹性计算云）、Hadoop YARN或者Apache Mesos上运行Spark。并且可以从HDFS、Cassandra、HBase、Hive、Tachyon和任何分布式文件系统读取数据</p></blockquote><p>代码简介</p><blockquote><p>Spark支持使用Scala、Python等语言编写。Scala或者Python的代码相对Java来说都比较简洁，因此Spark使用Scala或者Python编写应用程序要比使用MapReduce编写应用程序简单方便。</p></blockquote></blockquote><h2 id="SPark-生态圈"><a href="#SPark-生态圈" class="headerlink" title="SPark 生态圈"></a>SPark 生态圈</h2><blockquote><p>Spark的生态圈也称为BDAS（伯克利数据分析栈），是伯克利AMPLab实验室打造的，力图在算法（Algoritrhms）、机器（Machines）、人（People）之间通过大规模集成来展现大数据应用的一个平台。<br><img src="http://qufl2gk64.hb-bkt.clouddn.com/spark生态圈.png"></p></blockquote><h2 id="Spark-的重要组件"><a href="#Spark-的重要组件" class="headerlink" title="Spark 的重要组件"></a>Spark 的重要组件</h2><blockquote><p>1、Spark Sql<br>2、Spark Streaming  (流式存储)<br>3、MLlib<br>4、Graphx</p></blockquote><h2 id="Spark-1-0-amp-amp-2-0"><a href="#Spark-1-0-amp-amp-2-0" class="headerlink" title="Spark 1.0 &amp;&amp; 2.0"></a>Spark 1.0 &amp;&amp; 2.0</h2><blockquote><ol><li>Spark2 Apache Spark作为编译器:增加新的引擎Tungsten执行引擎，比Spark1快10倍</li><li>ml做了很大的改进，支持协同过滤</li><li>spark2 org.apache.spark.sql加了SparkSession把Spark的SQLcontext和hiveContext整合dataFrame去掉了，统一采用dataset</li><li>做流的方式，例如设置10秒钟一批，5秒钟处理</li><li>R语言API加入了很多机器学习的算法</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark Streaming</title>
      <link href="/2021/05/31/Spark-Streaming/"/>
      <url>/2021/05/31/Spark-Streaming/</url>
      
        <content type="html"><![CDATA[<h2 id="Spark-Streaming（流）概述"><a href="#Spark-Streaming（流）概述" class="headerlink" title="Spark Streaming（流）概述"></a>Spark Streaming（流）概述</h2><blockquote><p>数据分类</p><h2 id="离线数据和实时数据（相对实时）"><a href="#离线数据和实时数据（相对实时）" class="headerlink" title=" 离线数据和实时数据（相对实时）"></a> 离线数据和实时数据（相对实时）</h2><p>Spark Streaming 用于流式处理</p></blockquote><h2 id="DStream-简介"><a href="#DStream-简介" class="headerlink" title="DStream 简介"></a>DStream 简介</h2><p>&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>&#39;echarts基础图形之雷达图&#39;</title>
      <link href="/2020/10/14/echarts%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%9B%BE/"/>
      <url>/2020/10/14/echarts%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2%E4%B9%8B%E9%9B%B7%E8%BE%BE%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>&#39;echarts基础图形之散点图&#39;</title>
      <link href="/2020/10/14/echarts%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2%E4%B9%8B%E6%95%A3%E7%82%B9%E5%9B%BE/"/>
      <url>/2020/10/14/echarts%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2%E4%B9%8B%E6%95%A3%E7%82%B9%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>&#39;echarts基础图形之pie图&#39;</title>
      <link href="/2020/10/14/echarts%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2%E4%B9%8Bpie%E5%9B%BE/"/>
      <url>/2020/10/14/echarts%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2%E4%B9%8Bpie%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="饼图代码"><a href="#饼图代码" class="headerlink" title="饼图代码"></a>饼图代码</h2> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">     title:&#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&#x27;某站点用户访问来源&#x27;</span>,</span><br><span class="line">        <span class="attr">subtext</span>: <span class="string">&#x27;纯属虚构&#x27;</span>,</span><br><span class="line">        <span class="attr">left</span>:<span class="string">&#x27;center&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">tooltip</span>:&#123;</span><br><span class="line">        <span class="attr">trigger</span>:<span class="string">&#x27;item&#x27;</span>, <span class="comment">//触发类型 默认数据触发见下图 可选为：item | axis</span></span><br><span class="line">        <span class="attr">formatter</span>:<span class="string">&#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;</span> <span class="comment">//a(系类名称)， b（数据项名称）， c（数值），d(饼图：百分比 |雷达图：指标名称)</span></span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">legend</span>:&#123;</span><br><span class="line">        <span class="attr">orient</span>:<span class="string">&#x27;vertical&#x27;</span>, <span class="comment">//布局方式 默认为水平布局，可选为：horizontal | vertical</span></span><br><span class="line">        <span class="attr">x</span>:<span class="string">&#x27;left&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>:[<span class="string">&#x27;直接访问&#x27;</span>,<span class="string">&#x27;邮件营销&#x27;</span>,<span class="string">&#x27;联盟广告&#x27;</span>,<span class="string">&#x27;视屏广告&#x27;</span>,<span class="string">&#x27;社会赞助&#x27;</span>,<span class="string">&#x27;搜索引擎&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">toolbox</span>:&#123;</span><br><span class="line">        <span class="attr">show</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">feature</span>:&#123;</span><br><span class="line">            <span class="attr">mark</span>:&#123;</span><br><span class="line">                <span class="attr">show</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">dataView</span>:&#123;</span><br><span class="line">                <span class="attr">show</span>:<span class="literal">true</span>,</span><br><span class="line">                <span class="attr">readOnly</span>:<span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">restore</span>:&#123;</span><br><span class="line">                <span class="attr">show</span>:<span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">savaAsImage</span>:&#123;</span><br><span class="line">                <span class="attr">show</span>:<span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">calculable</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="attr">series</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;访问来源&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>:<span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">            <span class="comment">//半径，支持绝对值（px）和百分比计算比 min(width,height) /2*75，传输组实现环形图[内半径，外半径]</span></span><br><span class="line">            <span class="attr">radius</span>:<span class="string">&#x27;50%&#x27;</span>,</span><br><span class="line">            <span class="attr">center</span>:[<span class="string">&#x27;50%&#x27;</span>,<span class="string">&#x27;60%&#x27;</span>], <span class="comment">//圆心坐标、支持绝对值（px)和百分比，百分比计算 min(windth,height)* 50%</span></span><br><span class="line">            <span class="attr">itemStyle</span>:&#123;</span><br><span class="line">                <span class="attr">normal</span>:&#123;</span><br><span class="line">                    <span class="attr">label</span>:&#123;</span><br><span class="line">                        <span class="attr">show</span>:<span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">formatter</span>:<span class="string">&#x27;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">data</span>:[</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>:<span class="number">335</span>,</span><br><span class="line">                    <span class="attr">name</span>:<span class="string">&#x27;直接访问&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>:<span class="number">310</span>,</span><br><span class="line">                    <span class="attr">name</span>:<span class="string">&#x27;邮件访问&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>:<span class="number">234</span>,</span><br><span class="line">                    <span class="attr">name</span>:<span class="string">&#x27;联盟广告&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>:<span class="number">135</span>,</span><br><span class="line">                    <span class="attr">name</span>:<span class="string">&#x27;视屏广告&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>:<span class="number">1521</span>,</span><br><span class="line">                    <span class="attr">name</span>:<span class="string">&#x27;社会赞助&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">value</span>:<span class="number">1535</span>,</span><br><span class="line">                    <span class="attr">name</span>:<span class="string">&#x27;搜索引擎&#x27;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">myChart.setOption(option);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Echarts可视化 </category>
          
          <category> 饼图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 饼图代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>echarts饼图基础图形</title>
      <link href="/2020/10/08/echarts%E9%A5%BC%E5%9B%BE%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2/"/>
      <url>/2020/10/08/echarts%E9%A5%BC%E5%9B%BE%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ul><li>代码如下</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: <span class="string">&#x27;#2c343c&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">title</span>: &#123;</span><br><span class="line">        <span class="attr">text</span>: <span class="string">&#x27;Customized Pie&#x27;</span>,</span><br><span class="line">        <span class="attr">left</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">        <span class="attr">top</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">textStyle</span>: &#123;</span><br><span class="line">            <span class="attr">color</span>: <span class="string">&#x27;#ccc&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">tooltip</span>: &#123;</span><br><span class="line">        <span class="attr">trigger</span>: <span class="string">&#x27;item&#x27;</span>,</span><br><span class="line">        <span class="attr">formatter</span>: <span class="string">&#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">visualMap</span>: &#123;</span><br><span class="line">        <span class="attr">show</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">min</span>: <span class="number">80</span>,</span><br><span class="line">        <span class="attr">max</span>: <span class="number">600</span>,</span><br><span class="line">        <span class="attr">inRange</span>: &#123;</span><br><span class="line">            <span class="attr">colorLightness</span>: [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">series</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;访问来源&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">            <span class="attr">radius</span>: <span class="string">&#x27;55%&#x27;</span>,</span><br><span class="line">            <span class="attr">center</span>: [<span class="string">&#x27;50%&#x27;</span>, <span class="string">&#x27;50%&#x27;</span>],</span><br><span class="line">            <span class="attr">data</span>: [</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="number">335</span>, <span class="attr">name</span>: <span class="string">&#x27;直接访问&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="number">310</span>, <span class="attr">name</span>: <span class="string">&#x27;邮件营销&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="number">274</span>, <span class="attr">name</span>: <span class="string">&#x27;联盟广告&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="number">235</span>, <span class="attr">name</span>: <span class="string">&#x27;视频广告&#x27;</span>&#125;,</span><br><span class="line">                &#123;<span class="attr">value</span>: <span class="number">400</span>, <span class="attr">name</span>: <span class="string">&#x27;搜索引擎&#x27;</span>&#125;</span><br><span class="line">            ].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a.value - b.value; &#125;),</span><br><span class="line">            <span class="attr">roseType</span>: <span class="string">&#x27;radius&#x27;</span>,</span><br><span class="line">            <span class="attr">label</span>: &#123;</span><br><span class="line">                <span class="attr">color</span>: <span class="string">&#x27;rgba(255, 255, 255, 0.3)&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">labelLine</span>: &#123;</span><br><span class="line">                <span class="attr">lineStyle</span>: &#123;</span><br><span class="line">                    <span class="attr">color</span>: <span class="string">&#x27;rgba(255, 255, 255, 0.3)&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">smooth</span>: <span class="number">0.2</span>,</span><br><span class="line">                <span class="attr">length</span>: <span class="number">10</span>,</span><br><span class="line">                <span class="attr">length2</span>: <span class="number">20</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">itemStyle</span>: &#123;</span><br><span class="line">                <span class="attr">color</span>: <span class="string">&#x27;#c23531&#x27;</span>,</span><br><span class="line">                <span class="attr">shadowBlur</span>: <span class="number">200</span>,</span><br><span class="line">                <span class="attr">shadowColor</span>: <span class="string">&#x27;rgba(0, 0, 0, 0.5)&#x27;</span></span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            <span class="attr">animationType</span>: <span class="string">&#x27;scale&#x27;</span>,</span><br><span class="line">            <span class="attr">animationEasing</span>: <span class="string">&#x27;elasticOut&#x27;</span>,</span><br><span class="line">            <span class="attr">animationDelay</span>: <span class="function"><span class="keyword">function</span> (<span class="params">idx</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Math</span>.random() * <span class="number">200</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h3><p>利用疫数据制作两表出来<br>要求如下<br>1.饼图<br>2.折线图<br>    2.1折线图<br>暂时不要求美化</p>]]></content>
      
      
      <categories>
          
          <category> Echarts可视化 </category>
          
          <category> 饼图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 饼图基本格式以及个句代码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>echarts折线图糅合柱状图</title>
      <link href="/2020/10/06/Echarts%E6%8A%98%E7%BA%BF%E5%9B%BE%E7%B3%85%E5%90%88%E6%9F%B1%E7%8A%B6%E5%9B%BE/"/>
      <url>/2020/10/06/Echarts%E6%8A%98%E7%BA%BF%E5%9B%BE%E7%B3%85%E5%90%88%E6%9F%B1%E7%8A%B6%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="基础折线图大概全部代码"><a href="#基础折线图大概全部代码" class="headerlink" title="基础折线图大概全部代码"></a>基础折线图大概全部代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    <span class="attr">title</span>:&#123;</span><br><span class="line">        <span class="attr">text</span>:<span class="string">&#x27;长韵&#x27;</span>,</span><br><span class="line">        <span class="attr">link</span>:<span class="string">&#x27;http://www.changan.bio/&#x27;</span>,</span><br><span class="line">        <span class="attr">target</span>:<span class="string">&#x27;self&#x27;</span>,</span><br><span class="line">        <span class="attr">textStyle</span>:&#123;</span><br><span class="line">          <span class="attr">color</span>:<span class="string">&quot;#49b1f5&quot;</span>            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">subtext</span>:<span class="string">&#x27;通往一个属于自己的小博客&#x27;</span>,</span><br><span class="line">        <span class="attr">subtextStyle</span>:&#123;</span><br><span class="line">            <span class="attr">color</span>:<span class="string">&quot;#23b1f5&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">xAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">yAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">series</span>: [&#123;</span><br><span class="line">        <span class="attr">data</span>: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span>,</span><br><span class="line">        <span class="attr">areaStyle</span>: &#123;&#125;,</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="折线图柔和柱状图"><a href="#折线图柔和柱状图" class="headerlink" title="折线图柔和柱状图"></a>折线图柔和柱状图</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    <span class="attr">title</span>:&#123;</span><br><span class="line">        <span class="attr">text</span>:<span class="string">&#x27;长韵&#x27;</span>,</span><br><span class="line">        <span class="attr">link</span>:<span class="string">&#x27;http://www.changan.bio/&#x27;</span>,</span><br><span class="line">        <span class="attr">target</span>:<span class="string">&#x27;self&#x27;</span>,</span><br><span class="line">        <span class="attr">textStyle</span>:&#123;</span><br><span class="line">          <span class="attr">color</span>:<span class="string">&quot;#49b1f5&quot;</span>            </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">subtext</span>:<span class="string">&#x27;通往一个属于自己的小博客&#x27;</span>,</span><br><span class="line">        <span class="attr">subtextStyle</span>:&#123;</span><br><span class="line">            <span class="attr">color</span>:<span class="string">&quot;#23b1f5&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">legend</span>:&#123;</span><br><span class="line">        <span class="attr">data</span>:[<span class="string">&#x27;邮件营销&#x27;</span>, <span class="string">&#x27;联盟广告&#x27;</span>, <span class="string">&#x27;视频广告&#x27;</span>, <span class="string">&#x27;直接访问&#x27;</span>, <span class="string">&#x27;搜索引擎&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">xAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">        <span class="attr">data</span>: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">yAxis</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">series</span>: [&#123;</span><br><span class="line">        <span class="attr">data</span>: [<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span>,</span><br><span class="line">        <span class="attr">areaStyle</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">data</span>:[<span class="number">820</span>, <span class="number">932</span>, <span class="number">901</span>, <span class="number">934</span>, <span class="number">1290</span>, <span class="number">1330</span>, <span class="number">1320</span>],</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="个句代码进行解释"><a href="#个句代码进行解释" class="headerlink" title="个句代码进行解释"></a>个句代码进行解释</h3><p>title 标题<br>areaStyle 是否填充 </p><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p>To be trusted is a greater compliment than to be loved.<br>被人信任，是比被人喜爱还要更大的赞许。</p><h2 id="会进行合并成为五种基本图形"><a href="#会进行合并成为五种基本图形" class="headerlink" title="会进行合并成为五种基本图形"></a>会进行合并成为五种基本图形</h2>]]></content>
      
      
      <categories>
          
          <category> Echarts可视化 </category>
          
          <category> 折线图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 折线图基本格式以及个句代码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>&#39;Echarts柱状图基础</title>
      <link href="/2020/10/05/Echarts%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/10/05/Echarts%E6%9F%B1%E7%8A%B6%E5%9B%BE%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="基础柱状图"><a href="#基础柱状图" class="headerlink" title="基础柱状图"></a>基础柱状图</h2><p>结构构成<br>    -在绘图前我们需要为 ECharts 准备一个具备高宽的 DOM 容器<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 600px;height:400px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><br>    -要将echarts实例化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myChart = echarts.init(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;main&#x27;</span>));  <span class="comment">//基于echarts.init根据盒子进行实例化 获取当前事件id为main的盒子</span></span><br></pre></td></tr></table></figure><h3 id="整个柱状图代码"><a href="#整个柱状图代码" class="headerlink" title="整个柱状图代码"></a>整个柱状图代码</h3><figure class="highlight java"><figcaption><span>Server Pages</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    backgroundColor: <span class="string">&#x27;#12cf96&#x27;</span>,</span><br><span class="line">    xAxis: &#123; </span><br><span class="line">        type: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">        data: [<span class="string">&#x27;Mon&#x27;</span>, <span class="string">&#x27;Tue&#x27;</span>, <span class="string">&#x27;Wed&#x27;</span>, <span class="string">&#x27;Thu&#x27;</span>, <span class="string">&#x27;Fri&#x27;</span>, <span class="string">&#x27;Sat&#x27;</span>, <span class="string">&#x27;Sun&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        type: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        data: [<span class="number">120</span>, <span class="number">200</span>, <span class="number">150</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">110</span>, <span class="number">130</span>],</span><br><span class="line">        type: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">        showBackground: <span class="keyword">true</span>,</span><br><span class="line">        backgroundStyle: &#123;</span><br><span class="line">            color: <span class="string">&#x27;rgba(220, 220, 220, 0.8)&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="个名词解释"><a href="#个名词解释" class="headerlink" title="个名词解释"></a>个名词解释</h3><h4 id="xAxis-相当于一个直角坐标系的x轴"><a href="#xAxis-相当于一个直角坐标系的x轴" class="headerlink" title="xAxis  相当于一个直角坐标系的x轴"></a>xAxis  相当于一个直角坐标系的x轴</h4><blockquote><p>&nbsp;&nbsp; -type   声明类型<br>&nbsp;&nbsp; -category 也就是要声明的类型<br>&nbsp;&nbsp; -data  就是x轴的数值</p></blockquote><h4 id="yAxis-相反也是就是相当于直角坐标系的y轴"><a href="#yAxis-相反也是就是相当于直角坐标系的y轴" class="headerlink" title="yAxis  相反也是就是相当于直角坐标系的y轴"></a>yAxis  相反也是就是相当于直角坐标系的y轴</h4><blockquote><p>&nbsp;&nbsp;&nbsp;-value 声明这个值<br>&nbsp;&nbsp;-series<br>&nbsp;&nbsp;&nbsp;—data 就是y轴的数据 当然数据后都会以英文逗号分隔<br>&nbsp;&nbsp;&nbsp;—type:”bar” 声明这个是柱状图<br>&nbsp;&nbsp;&nbsp;— showBackground: true 补全数据不全的地方 可以理解为没有数据为了好观看而白色标识 只有一个参数<br>-backgroundStyle: {<br>            color: ‘rgba(220, 220, 220, 0.8)’<br>            }<br>&nbsp;&nbsp;&nbsp; 调节空白显示的颜色 这种方式用的rbg三色调<br>&nbsp;&nbsp;&nbsp;  -backgroundColor 以前js或css就有了的 这不多讲</p></blockquote><!-- | 项目        | 价格    |  数量   || --------    | -----: | :----:  || 计算机      | \$1600  |   5    || 手机        |   \$12  |   12   || 管线        |    \$1  |   234  | --><h2 id="柱状图的晋级"><a href="#柱状图的晋级" class="headerlink" title="柱状图的晋级"></a>柱状图的晋级</h2><p>To be a princess, you have to believe that you are a princess.<br>要想成为公主，你必须相信自己就是公主。</p>]]></content>
      
      
      <categories>
          
          <category> Echarts可视化 </category>
          
          <category> 柱状图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 柱状图基本格式以及个句代码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyecharts的语法格式及意思解释</title>
      <link href="/2020/09/23/Pyecharts%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E5%8F%8A%E6%84%8F%E6%80%9D%E8%A7%A3%E9%87%8A/"/>
      <url>/2020/09/23/Pyecharts%E7%9A%84%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E5%8F%8A%E6%84%8F%E6%80%9D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="Pyecharts的大概意思"><a href="#Pyecharts的大概意思" class="headerlink" title="Pyecharts的大概意思"></a>Pyecharts的大概意思</h1><blockquote><p>chart_name=图表类型（）初始化具体的类型的图表<br> chart_name.add_xaxis()添加横坐标名称<br> chart_name.add_yaxis()添加纵坐标数据<br> chart_name.render()生成.html</p></blockquote><h2 id="导入包的解释"><a href="#导入包的解释" class="headerlink" title="导入包的解释"></a>导入包的解释</h2><blockquote><p>from pyecharts.faker import Faker 添加随机数据<br>from pyecharts.charts import Bar 导入需要的包<br>from pyecharts import as opts 找到某个需要的东西，as 为别名<br>from pyecharts.globals import ThemeType 这个模块可以修改主题</p></blockquote><h2 id="柱状图的实例化"><a href="#柱状图的实例化" class="headerlink" title="柱状图的实例化"></a>柱状图的实例化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.faker <span class="keyword">import</span>  Faker</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span>  options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType  </span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span>  Bar</span><br><span class="line">bar = Bar(init_opts=opts.InitOpts(theme=ThemeType.PURPLE_PASSION))  //对Bar进行实例化 添加init_opts=opts.InitOpts(theme=ThemeType.。。。添加主题名称） 进行实例化的时候进行主题的初始化 </span><br><span class="line">&gt; bar.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;Bar~基本&quot;</span>,subtitle=<span class="string">&quot;我是副标题&quot;</span>))  //title_opts主标题  subtitle副题--&gt;那个会在其他文档中说到，这不详说</span><br><span class="line">bar.add_xaxis(Faker.choose())  //Faker.choose指的是文字</span><br><span class="line">bar.add_yaxis(<span class="string">&quot;商品&quot;</span>,Faker.values() //Faker.values指的是数据</span><br><span class="line">bar.render()</span><br></pre></td></tr></table></figure><blockquote><p>注意的：type可以查看数据类型 xaxis中里面添加的数据必须是python的list/列表类型。如果是numpy数组需要转换成list</p></blockquote><h3 id="柱状图实例化的高度"><a href="#柱状图实例化的高度" class="headerlink" title="柱状图实例化的高度"></a>柱状图实例化的高度</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.faker <span class="keyword">import</span>  Faker</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span>  options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span>  Bar</span><br><span class="line">bar = Bar(init_opts=opts.InitOpts(</span><br><span class="line">    theme=ThemeType.MACARONS, //修改高度，宽度</span><br><span class="line">    width=<span class="string">&quot;1920px&quot;</span>,</span><br><span class="line">    height=<span class="string">&quot;1080px&quot;</span></span><br><span class="line"></span><br><span class="line">))</span><br><span class="line"><span class="comment"># 修改主标题</span></span><br><span class="line">bar.set_global_opts(</span><br><span class="line">    title_opts=opts.TitleOpts(</span><br><span class="line">        title=<span class="string">&quot;Bar~基本&quot;</span>,</span><br><span class="line">        subtitle=<span class="string">&quot;我是副标题&quot;</span>)，</span><br><span class="line">                xaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(rotate=<span class="number">30</span>))  //<span class="number">30</span> 旋转的角度 y轴的同等</span><br><span class="line">        )</span><br><span class="line">bar.add_xaxis(Faker.choose())</span><br><span class="line">bar.add_yaxis(<span class="string">&quot;商品A&quot;</span>,Faker.values(),stack=<span class="string">&quot;st&quot;</span>)</span><br><span class="line">bar.add_yaxis(<span class="string">&quot;商品B&quot;</span>,Faker.values(),stack=<span class="string">&quot;st&quot;</span>)  // 他们是处于叠加态（处于叠加）的 如果不设置stack那么它会成一行接一行，不会形成叠加 stack填写的类容一样会被认为是同一叠加</span><br><span class="line">bar.render()</span><br></pre></td></tr></table></figure><blockquote><p>注：叠加比较好看到时间占比或者说是某种占比度更大</p></blockquote><!-- # --> 平均值、最值<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyecharts.faker <span class="keyword">import</span>  Faker</span><br><span class="line"><span class="keyword">from</span> pyecharts <span class="keyword">import</span>  options <span class="keyword">as</span> opts</span><br><span class="line"><span class="keyword">from</span> pyecharts.<span class="built_in">globals</span> <span class="keyword">import</span> ThemeType</span><br><span class="line"><span class="keyword">from</span> pyecharts.charts <span class="keyword">import</span>  Bar</span><br><span class="line">bar = Bar(init_opts=opts.InitOpts(</span><br><span class="line">    theme=ThemeType.MACARONS,</span><br><span class="line">    width=<span class="string">&quot;1920px&quot;</span>,</span><br><span class="line">    height=<span class="string">&quot;720px&quot;</span></span><br><span class="line"></span><br><span class="line">))</span><br><span class="line"><span class="comment"># 修改主标题</span></span><br><span class="line">bar.set_global_opts(</span><br><span class="line">    title_opts=opts.TitleOpts(</span><br><span class="line">        title=<span class="string">&quot;Bar~基本&quot;</span>,</span><br><span class="line">        subtitle=<span class="string">&quot;我是副标题&quot;</span>),</span><br><span class="line">        xaxis_opts=opts.AxisOpts(axislabel_opts=opts.LabelOpts(rotate=<span class="number">30</span>))</span><br><span class="line">),</span><br><span class="line">bar.add_xaxis(Faker.choose())</span><br><span class="line"><span class="comment"># bar.add_xaxis(Faker.choose())</span></span><br><span class="line">bar.add_yaxis(<span class="string">&quot;商品A&quot;</span>,Faker.values(),stack=<span class="string">&quot;st&quot;</span>)</span><br><span class="line">bar.add_yaxis(<span class="string">&quot;商品B&quot;</span>,Faker.values(),stack=<span class="string">&quot;st&quot;</span>)</span><br><span class="line">bar.set_series_opts(</span><br><span class="line">    label_opts=opts.LabelOpts(is_show=<span class="literal">False</span>),</span><br><span class="line">    markpoint_opts=opts.MarkPointOpts( //表示出极值</span><br><span class="line">        data=[</span><br><span class="line">            //最值</span><br><span class="line">            opts.MarkPointItem(type_=<span class="string">&quot;max&quot;</span>,name=<span class="string">&quot;最大值&quot;</span>),</span><br><span class="line">            opts.MarkPointItem(type_=<span class="string">&quot;min&quot;</span>,name=<span class="string">&quot;最小值&quot;</span>),</span><br><span class="line"></span><br><span class="line">        ]</span><br><span class="line">    ),</span><br><span class="line">    markline_opts=opts.MarkLineOpts(   //表示平均，画线</span><br><span class="line">        data=[</span><br><span class="line">            //平均</span><br><span class="line">            opts.MarkLineItem(type_=<span class="string">&quot;average&quot;</span>,name=<span class="string">&quot;平均值&quot;</span>),</span><br><span class="line">        ]</span><br><span class="line">    ),</span><br><span class="line">)</span><br><span class="line">bar.reversal_axis( ) //交换x轴y轴</span><br><span class="line">bar.render()</span><br></pre></td></tr></table></figure><h2 id="今日图形到此结束-9-28"><a href="#今日图形到此结束-9-28" class="headerlink" title="今日图形到此结束 9-28"></a>今日图形到此结束 9-28</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>每日一首古诗词-过苏禄东王墓</title>
      <link href="/2020/08/31/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A6%96%E5%8F%A4%E8%AF%97%E8%AF%8D-%E8%BF%87%E8%8B%8F%E7%A6%84%E4%B8%9C%E7%8E%8B%E5%A2%93/"/>
      <url>/2020/08/31/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A6%96%E5%8F%A4%E8%AF%97%E8%AF%8D-%E8%BF%87%E8%8B%8F%E7%A6%84%E4%B8%9C%E7%8E%8B%E5%A2%93/</url>
      
        <content type="html"><![CDATA[<h2 id="每日一首古诗词-过苏禄东王墓"><a href="#每日一首古诗词-过苏禄东王墓" class="headerlink" title="每日一首古诗词-过苏禄东王墓"></a>每日一首古诗词-过苏禄东王墓</h2><h2 id="清代-顾炎武"><a href="#清代-顾炎武" class="headerlink" title="清代-顾炎武"></a>清代-顾炎武</h2><blockquote><p>丰碑遥见炳奎题，尚忆先朝宠日殚。<br>世有国人供洒扫，每勤词客驻轮蹄。<br>九河水壮龙狐出，十二城荒向鹤栖。<br>下马一为郯子问，中原云鸟正凄迷。</p><h2 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h2><ol><li>哪天兴致所来-在来填写<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2>苏禄国东王墓：明永乐十五年（1417年），苏禄国（今菲律宾）东王巴都葛叭哈喇、西王巴都葛叭苏里和峒王巴都葛叭喇卜率领家眷一行340多人访问中国，受到明永乐皇帝（明成祖朱棣）的热情接待，在北逗留27天。在取道运河回国途经德州时东王不幸遭疾，病故德州。明成祖朱棣派礼部郎中陈世启带祭文赶运至德州为东王举行了隆重葬礼。王妃及两个儿子留居德州守墓，后改为温、安二姓入籍中国。苏禄国东王墓（坐落在山东省德州市城区北部的北营村）成为我国两个中其中一座外国王陵（另一座是位于南京的浡泥国王墓），也是中国唯一的驻有外国王室后裔守陵村落的异邦王陵。，在历史上具有独特的地位和意义。<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2>顾炎武（1613.7.15—1682.2.15），汉族，明朝南直隶苏州府昆山（今江苏省昆山市）千灯镇人，本名绛，乳名藩汉，别名继坤、圭年，字忠清、宁人，亦自署蒋山佣；南都败后，因为仰慕文天祥学生王炎午的为人，改名炎武。因故居旁有亭林湖，学者尊为亭林先生。明末清初的杰出的思想家、经学家、史地学家和音韵学家，与黄宗羲、王夫之并称为明末清初“三大儒”。<br>他一生辗转，行万里路，读万卷书，创立了一种新的治学方法，成为清初继往开来的一代宗师，被誉为清学“开山始祖”。顾炎武学问渊博，于国家典制、郡邑掌故、天文仪象、河漕、兵农及经史百家、音韵训诂之学，都有研究。晚年治经重考证，开清代朴学风气。其学以博学于文，行己有耻为主，合学与行、治学与经世为一。诗多伤时感事之作。<br>其主要作品有《日知录》、《天下郡国利病书》、《肇域志》、《音学五书》、《韵补正》、《古音表》、《诗本音》、《唐韵正》、《音论》、《金石文字记》、《亭林诗文集》等。<h2 id="平仄"><a href="#平仄" class="headerlink" title="平仄"></a>平仄</h2>丰碑遥见炳奎题，尚忆先朝宠日殚。<br>平平仄仄仄平平，仄仄平平仄仄平。<br>世有国人供洒扫，每勤词客驻轮蹄。<br>仄仄平平平仄仄，平平仄仄仄平平。<br>九河水壮龙狐出，十二城荒向鹤栖。<br>平平仄仄平平仄，仄仄平平仄仄平。<br>下马一为郯子问，中原云鸟正凄迷<br>仄仄平平平仄仄，平平仄仄仄平平</li></ol></blockquote><h2 id="出处，参考"><a href="#出处，参考" class="headerlink" title="出处，参考"></a>出处，参考</h2><p>古诗词网：<a href="http://www.gushicimingju.com/gushi/shi/185705.html">http://www.gushicimingju.com/gushi/shi/185705.html</a><br>百度文科：<a href="https://baike.baidu.com/item/%E8%8B%8F%E7%A6%84%E7%8E%8B%E5%A2%93/793310?fromtitle=%E8%8B%8F%E7%A6%84%E4%B8%9C%E7%8E%8B%E5%A2%93&amp;fromid=3023948&amp;fr=aladdin">https://baike.baidu.com/item/%E8%8B%8F%E7%A6%84%E7%8E%8B%E5%A2%93/793310?fromtitle=%E8%8B%8F%E7%A6%84%E4%B8%9C%E7%8E%8B%E5%A2%93&amp;fromid=3023948&amp;fr=aladdin</a></p>]]></content>
      
      
      <categories>
          
          <category> 文学作品 </category>
          
          <category> 古诗词 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一首古诗词-过苏禄东王墓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日一首古诗词-岳鄂王墓</title>
      <link href="/2020/08/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A6%96%E5%8F%A4%E8%AF%97%E8%AF%8D-%E5%B2%B3%E9%84%82%E7%8E%8B%E5%A2%93/"/>
      <url>/2020/08/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A6%96%E5%8F%A4%E8%AF%97%E8%AF%8D-%E5%B2%B3%E9%84%82%E7%8E%8B%E5%A2%93/</url>
      
        <content type="html"><![CDATA[<h2 id="每日一首古诗词-岳鄂王墓"><a href="#每日一首古诗词-岳鄂王墓" class="headerlink" title="每日一首古诗词-岳鄂王墓"></a>每日一首古诗词-岳鄂王墓</h2><h2 id="元朝-赵孟俯"><a href="#元朝-赵孟俯" class="headerlink" title="元朝 赵孟俯"></a>元朝 赵孟俯</h2><blockquote><p>鄂王墓上草离离，秋日荒凉石兽危。<br>南渡君臣轻社稷，中原父老望旌旗。<br>英雄已死嗟何及，天下中分遂不支。<br>莫向西湖歌此曲，水光山色不胜悲。</p><h2 id="译文"><a href="#译文" class="headerlink" title="译文"></a>译文</h2><p>岳飞墓上荒草离离，一片荒凉，只有秋草、石兽而已。<br>南渡君臣轻视社稷，可中原父老还在盼望着王师的旌旗。<br>英雄被害，后悔晚矣，天下灭亡已成定局。<br>不要向西湖吟唱此诗，面对这样的景致无从吟起。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>岳鄂王墓:即岳飞墓,现杭州西湖边栖霞岭下.岳飞于绍兴十一年（1142年）被权奸秦桧等阴谋杀害。宋宁宗嘉泰四年（1204年），追封为鄂王。<br>离离:草茂盛的样子<br>危:高耸屹立的样子<br>石兽:古时石头雕刻动物的立于墓前<br>南渡君臣：指以宋高宗赵构为代表的统治集团。北宋亡后，高宗渡过长江，迁于南方，建都临安（今杭州），史称南渡<br>社稷: 江山国家.社,土地神.稷,谷神<br>望旌旗：意为盼望南宋大军到来。旌旗，代指军队。<br>嗟何及：后悔叹息已来不及。<br>天下中分遂不支：意为从此国家被分割为南北两半，而南宋的半壁江山也不能支持，终于灭亡。</p></blockquote><h2 id="创作背景"><a href="#创作背景" class="headerlink" title="创作背景"></a>创作背景</h2><p>元至元二十三年（1286年）行台侍御史程钜夫“奉诏搜访遗逸于江南”，赵孟頫当仁不让、毫不推辞，到了京城立即受到元世祖的接见。此后官运亨通，做到了翰林学士承旨、荣禄大夫，官居从一品。当时指责赵孟頫的人不少，但今人当更宽容地看待。这是首好诗，不能因人废言。</p><h2 id="赏析"><a href="#赏析" class="headerlink" title="赏析"></a>赏析</h2><p> 这是一支悲愤的悼歌。岳飞的惨死是中国历史上的一大悲剧。岳飞虽然冤死，但他的英名却永远留在历代人民的心中。宋宁宗嘉泰四年（1204年），追封岳飞为鄂王，旷世冤案得以昭雪，离岳飞被害已62年。岳墓建在风景秀丽的西湖岸边，岳飞虽封王建墓，但由于连年战乱，陵园荒芜，景象凄凉。这首诗以反映这样的现实入笔。</p><p>　　首联以离离墓草渲染岳墓秋日的荒凉，冷硬屹立的石兽，更增添了几分悲思。接下来用南北君民作对比，谴责南宋当局苟安享乐、不思北进，同情中原父老忍受煎熬，遥望南师。颈联哀叹有望承担中兴重任的英雄岳飞悲惨死去，使天下南北中分以至南宋最终被蒙古人灭亡。作者在尾联悲痛地吟道：“莫向西湖歌此曲，水光山色不胜悲。”满含湖光依旧，河山易主的深沉的感慨。</p><p>　　作者以赵宋后裔的身份为冤死于赵宋王朝的岳飞，由衷地唱出这支哀痛伤惋的悼歌，分外感人。<br>后面两句,蕴含了诗人无尽的家国之思、亡国之恨。</p><h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>赵孟頫（1254—1322），字子昂，号松雪，松雪道人，又号水精宫道人、鸥波，中年曾作孟俯，汉族，吴兴（今浙江湖州）人。元代著名画家，楷书四大家（欧阳询、颜真卿、柳公权、赵孟頫）之一。赵孟頫博学多才，能诗善文，懂经济，工书法，精绘艺，擅金石，通律吕，解鉴赏。特别是书法和绘画成就最高，开创元代新画风，被称为“元人冠冕”。他也善篆、隶、真、行、草书，尤以楷、行书著称于世。</p><h2 id="平仄"><a href="#平仄" class="headerlink" title="平仄"></a>平仄</h2><p>鄂王坟上草离离，秋日荒凉石兽危。<font color="FFF000">起</font><br>平平仄仄仄平平，仄仄平平仄仄平。<br>南渡君臣轻社稷，中原父老望旌旗。<font color="FF0000">对仗</font> <font color="FFF000">承</font><br>仄仄平平平仄仄，平平仄仄仄平平。<br>英雄已死嗟何及，天下中分遂不支。<font color="FF0000">对仗</font> <font color="FFF000">转</font><br>平平仄仄平平仄，仄仄平平仄仄平。<br>莫向西湖歌此曲，水光山色不胜悲。<font color="FFF000">合</font><br>仄仄平平平仄仄，平平仄仄仄平平。</p>]]></content>
      
      
      <categories>
          
          <category> 文学作品 </category>
          
          <category> 古诗词 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日一首古诗词-岳鄂王墓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive安装和配置</title>
      <link href="/2020/08/28/Hive%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/08/28/Hive%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="解决hive只能开一个的问题"><a href="#解决hive只能开一个的问题" class="headerlink" title="解决hive只能开一个的问题"></a>解决hive只能开一个的问题</h2><ol><li>hive只能开一个客户端 把元数据放在MySQL中<br> 1.2  因为Metastore默认存储在自带目录的derby数据库中的，推荐使用MySQL储存Metastoree</li></ol><h2 id="安装MySQL过程中的错误"><a href="#安装MySQL过程中的错误" class="headerlink" title="安装MySQL过程中的错误"></a>安装MySQL过程中的错误</h2><blockquote><p>linux 关于rpm和find部分命令使用方式</p><pre><code>- rpm -qa |grep mysql 查询系统中有没有这个安装包- find -name &quot;*-db&quot; 查询满足条件的后缀- rpm -qa |grep -i mysql 查看于包相关的</code></pre></blockquote><h3 id="特殊的解压方式"><a href="#特殊的解压方式" class="headerlink" title="特殊的解压方式"></a>特殊的解压方式</h3><blockquote><p>unzip  mysql-libs.zip 解压zip后缀的的文件<br>rpm -ivh MySQL-client-5.6.24-1.el6.x86_64.rpm 则是安装包或者rpm后缀<br>tar -zxvf 则可以解压平常或者常见的安装包</p></blockquote><h3 id="删除一个单独的包"><a href="#删除一个单独的包" class="headerlink" title="删除一个单独的包"></a>删除一个单独的包</h3><blockquote><pre><code>rpm -e MySQL-client-5.6.24-1.el6.x86_64.rpm  卸载MySQL-client-5.6.24-1.el6.x86_64.rpm 这个包- yum remove mariadb-libs-5.5.60-1.el7_5.x86_64 删除冲突的包- rpm -e --nodeps mariadb-libs-5.5.60-1.el7_5.x86_64 强制删除</code></pre></blockquote><h2 id="Hive元数据"><a href="#Hive元数据" class="headerlink" title="Hive元数据"></a>Hive元数据</h2>]]></content>
      
      
      <categories>
          
          <category> 程序、语言、框架 </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive安装和配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive相关概念</title>
      <link href="/2020/08/28/Hive%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/08/28/Hive%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="大数据主要解决3个问题"><a href="#大数据主要解决3个问题" class="headerlink" title="大数据主要解决3个问题"></a>大数据主要解决3个问题</h2><ul><li>传输    存储      计算(Hive)</li></ul><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><ol><li>Hive：海量日志结构化工具 基于Hadoop的一个数据仓库，可以将结构化的数据文件映射为一张表，并提供类MySQL的查询，<font color=#FF0000 >本s质上是将HQL转换成MapReduce</font> <font color=#FF0000 >计算一定是分布式的</font></li><li>Hive的分析底层的默认实现的MapRedecu</li><li>Hive有优点<pre><code>     3.1 提供快速开发的的能力     3.2 减少开发人员学习成本     3.3 在于处理大数据，对于小数据没有优势，应为Hive的延迟比较高     3.4 Hive支持用户自定义函数，可以根据自己需求来实现</code></pre></li><li>Hive缺点<pre><code>     4.1 Hive的HQL的表达能力有限</code></pre></li></ol><blockquote><pre><code>           4.1.1 迭代式算法无法表达           4.1.2 数据挖掘方面不擅长        4.2 Hive的效率较低           4.2.1 Hive自动生成的Mapreduce作业，不够智能化          4.2.2 Hive调优较为麻烦粒度较粗</code></pre></blockquote><ol><li><p>Hive架构原理</p> <!--http://106.54.84.55:8080/changyun/1.png --><p><img src="http://106.54.84.55:8080/changyun/1.png" alt="Hive"></p><p> 5.1 元数据  Metastore</p><pre><code> 元数据包括：表明、表所属数据库（默认default）、表的拥有者、分区字段、表的类型 数据目录&lt;font color=#FF0000 &gt;默认储存自带的derby数据库中，推荐使用MySQL储存Metastore&lt;/font&gt;</code></pre></li><li><p>Hive运行机制</p> <!--http://106.54.84.55:8080/changyun/2.png --><p><img src="http://106.54.84.55:8080/changyun/2.png" alt="Hive"></p></li><li><p>Hive和数据库的对比</p></li></ol><blockquote><p>数据的存储位置不同 由于hive是建立在hadoop上面的 所有数据都是存储在HDFS中，而数据库则可以将数据保存在块设备或者本地文件系统中</p><blockquote><p>   数据的更新： <font color=#FF0000 >由于hives是针对数据仓库设立的，而数据仓库的内容主要是读多写少，因此，Hive中是不会建议修改数据的，所有数据都是在加载好的时候确定的</font>，而数据库需要经常修改</p><blockquote><p>索引： Hive在加载数据是不会进行任何操作，甚至不会对数据进行扫描，所以就别就不会存在key,Hive要访问数中符合特定条件会<font color=#FF0000>需要暴力扫描整个数据<font>,而数据库对一个或几个列建立key提高数据的访问，数据库可以有很高的效率、较低的延迟，由于数据的访问延迟高，决定Hive不适合在线查询</p><blockquote><p>执行： Hive中大多数查询通过Hadoop提供的Mapreduce来实现，而数据库通常有自己的执行引擎<br>可扩展性： 由于Hive时建立在Hadoop上面的，所以Hive和Hadoop的可扩展性的一致的<br>    数据规模： 由于hive是建立在集群上并可以利用Mapreduce进行计算，因此可以支持很大的规模的数据，对应的，数据库所支持就相对较小</p></blockquote></blockquote></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 程序、语言、框架 </category>
          
          <category> Hive </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive相关概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Poetry</title>
      <link href="/2020/08/26/Poetry/"/>
      <url>/2020/08/26/Poetry/</url>
      
        <content type="html"><![CDATA[<h2 id="每天一首古诗词-渡荆门送别"><a href="#每天一首古诗词-渡荆门送别" class="headerlink" title="每天一首古诗词-渡荆门送别"></a>每天一首古诗词-渡荆门送别</h2><h2 id="唐-李太白"><a href="#唐-李太白" class="headerlink" title="唐-李太白"></a>唐-李太白</h2><blockquote><p>渡远荆门外，来从楚国游。<br>山随平野尽，江入大荒流。<br>月下飞天境，云生结海楼。<br>仍怜故乡水，万里送行舟。</p></blockquote><h2 id="【译文】"><a href="#【译文】" class="headerlink" title="【译文】"></a>【译文】</h2><blockquote><p>乘船远行，路过荆门一带，来到楚国故地。<br>青山渐渐消失，平野一望无边。长江滔滔奔涌，流入广袤荒原。<br>月映江面，犹如明天飞镜；云彩升起，变幻无穷，结成了海市蜃楼。<br>故乡之水恋恋不舍，不远万里送我行舟。</p><h2 id="【注释】"><a href="#【注释】" class="headerlink" title="【注释】"></a>【注释】</h2><p>荆门：山名，位于今湖北省宜都县西北长江南岸，与北岸虎牙三对峙，地势险要，自古即有楚蜀咽喉之称。<br>远：远自。<br>楚国：楚地，指湖北一带，春秋时期属楚国。<br>平野：平坦广阔的原野。<br>江：长江。大荒：广阔无际的田野。<br>月下飞天镜：明月映入江水，如同飞下的天镜。下：移下。<br>海楼：海市蜃楼，这里形容江上云霞的美丽景象。<br>仍：依然。怜：怜爱。一本作“连”。故乡水：指从四川流来的长江水。因诗人从小生活在四川，把四川称作故乡。<br>万里：喻行程之远。</p><h2 id="【赏析】"><a href="#【赏析】" class="headerlink" title="【赏析】"></a>【赏析】</h2><p>这首诗是李白出蜀时所作。李白这次出蜀，由水路乘船远行，经巴渝，出三峡，直向荆门山之外驶去，目的是到湖北、湖南一带楚国故地游览。“渡远荆门外，来从楚国游”，指的就是这一壮游。这时候的青年诗人，兴致勃勃，坐在船上沿途纵情观赏巫山两岸高耸云霄的峻岭，一路看来，眼前景色逐渐变化，船过荆门一带，已是平原旷野，视域顿然开阔，别是一番景色：</p></blockquote><p>“山随平野尽，江入大荒流。”</p><p>“山随平野尽”，形象地描绘了船出三峡、渡过荆门山后长江两岸的特有景色：山逐渐消失了，眼前是一望无际的低平的原野。著一“随”字，化静为动，将群山与平野的位置逐渐变换、推移，真切地表现出来。这句好比用电影镜头摄下的一组活动画面，给人以流动感与空间感，将静止的山岭摹状出活动的趋向来。</p><p>“江入大荒流”，写出江水奔腾直泻的气势，从荆门往远处望去，仿佛流入荒漠辽远的原野，显得天空寥廓，境界高远。后句著一“入”字，写出了气势的博大，充分表达了诗人的万丈豪情，充满了喜悦和昂扬的激情，力透纸背，用语贴切。景中蕴藏着诗人喜悦开朗的心情和青春的蓬勃朝气。</p><p>颔联这两句不仅由于写进“平野”、“大荒”这些辽阔原野的意象，而气势开阔；而且还由于动态的描写而十分生动。大江固然是流动的，而山脉却本来是凝固的，“随、尽”的动态感觉，完全是得自舟行的实际体验。在陡峭奇险，山峦叠嶂的三峡地带穿行多日后，突见壮阔之景，豁然开朗的心情可想而知。它用高度凝炼的语言。极其概括地写出了诗人整个行程的地理变化。</p><p>写完山势与流水，诗人又以移步换景手法，从不同角度描绘长江的近景与远景：</p><p>“月下飞天镜，云生结海楼。”</p><p>长江流过荆门以下，河道迂曲，流速减缓。晚上，江面平静时，俯视月亮在水中的倒影，好象天上飞来一面明镜似的；日间，仰望天空，云彩兴起，变幻无穷，结成了海市蜃楼般的奇景。这正是从荆门一带广阔平原的高空中和平静的江面上所观赏到的奇妙美景。如在崇山峻岭的三峡中，自非亭午夜分，不见曦月，夏水襄陵，江面水流湍急汹涌，那就很难有机会看到“月下飞天镜”的水中影像；在隐天蔽日的三峡空间，也无从望见“云生结海楼”的奇景。这一联以水中月明如圆镜反衬江水的平静，以天上云彩构成海市蜃楼衬托江岸的辽阔，天空的高远，艺术效果十分强烈。颔颈两联，把生活在蜀中的人，初次出峡，见到广大平原时的新鲜感受极其真切地写了出来。</p><p>颈联两句反衬江水平静，展现江岸辽阔，天空高远，充满了浪漫主义色彩。</p><p>李白在欣赏荆门一带风光的时候，面对那流经故乡的滔滔江水，不禁起了思乡之情：</p><p>“仍怜故乡水，万里送行舟。”</p><p>诗人顺着长江远渡荆门，江水流过的蜀地也就是曾经养育过他的故乡，初次离别，他怎能不无限留恋，依依难舍呢？但诗人不说自己思念故乡，而说故乡之水恋恋不舍地一路送我远行，怀着深情厚意，万里送行舟，从对面写来，越发显出自己思乡深情。诗以浓重的怀念惜别之情结尾，言有尽而情无穷。诗题中的“送别”应是告别故乡而不是送别朋友，诗中并无送别朋友的离情别绪。清沈德潜认为“诗中无送别意，题中二字可删”（《唐诗别裁》），这并不是没有道理的。</p><p>这首诗首尾行结，浑然一体，意境高远，风格雄健。“山随平野尽，江入大荒流”，写得逼真如画，有如一幅长江出峡渡荆门长轴山水图，成为脍炙人口的佳句。如果说优秀的山水画“咫尺应须论万里”，那么，这首形象壮美瑰玮的五律也可以说能以小见大，以一当十，容量丰富，包涵长江中游数万里山势与水流的景色，具有高度集中的艺术概括力。</p><h2 id="【作者简介】"><a href="#【作者简介】" class="headerlink" title="【作者简介】"></a>【作者简介】</h2><blockquote><p>李白（701-762），字太白，号青莲居士，唐朝浪漫主义诗人，被后人誉为’诗仙’出生于西域碎叶城，四岁再随父迁至剑南道绵州，有《李太白集》流传于世，762年病逝，享年61岁，其墓在今安徽当涂，四川江油、湖北安陆有纪念馆。</p></blockquote><p>参考：<br>古诗文网<a href="https://www.taixiangla.com/gushi/23860.html">https://www.taixiangla.com/gushi/23860.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 文学作品 </category>
          
          <category> 古诗词 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每天一首古诗词-渡荆门送别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗钟</title>
      <link href="/2020/08/23/%E8%AF%97%E9%92%9F/"/>
      <url>/2020/08/23/%E8%AF%97%E9%92%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="嵌字诗钟与整体思维"><a href="#嵌字诗钟与整体思维" class="headerlink" title="嵌字诗钟与整体思维"></a>嵌字诗钟与整体思维</h3><p>吴思本</p><p>嵌字诗钟既来源于律诗的对偶诗联，又不同于律联。不同处就在于作者们必须围绕这两个嵌字来构思和组织诗句，而这两个嵌字都是现拈或事先给定的，其事类乃至词性往往相距较远。若单纯只从每个嵌字本身来写诗钟，则上下联间的句意就会出现很大的断裂，势必使读者无法产生联想，因而也难以获得一个较完整和深刻的印象和感受。但是，正如唐代皎然所言：”诗语二句相须，如鸟有翅”（《诗式》）；浑然一体，血脉相连，历来是我国诗学的一个重要审美原则。这也体现了中华民族独特的整体思维特征，它完全不同于当代西方的分析思潮。所以，在写作嵌字诗钟时，防止和避免上下联间的句意断裂是很有必要的。以下讨论都取例于《雪鸿初集》。 </p><p>一、句意断裂的出现 </p><p>太行父子移山憨<br>巫峡君臣说梦奇（《山•梦》六唱）</p><p>嵌字为”山”和”梦”，比类较远，此上下联的前四个字，分别用了两个工对，属人物名及地名，还用了两个典故。但此处工对的实施并未能避免由嵌字所引起的上下联句意间的断裂，因为愚公父子的移”山”和襄王、宋玉的说”梦”，毕意是两码事，两者没有直接联系，也难以使读者产生更多的联想和回味。类似的例子还有：</p><p>牢骚屈子编天问<br>游戏扬雄解客嘲（《天•客》六唱）；</p><p>解佩几疑仙女幻<br>击当合让五人豪（《仙•五》五唱）；</p><p>元霜捣药蓝桥暮<br>白露横江赤壁秋（《药•江》四唱）。 </p><p>二、联句浑成的获得 </p><p>铜琶铁板江东曲<br>流水高山海上琴（《东•上》六唱），</p><p>此处用了句中自对，但就上下联而言，是属宽对；还用了两个故事，主人翁分别是东坡和伯牙。由于两句都是在描述音乐，从而使上下联浑然天成，不即不离。再如：</p><p>悬岩觅路凌空上<br>窄港连舟取次行（《空•次》六唱），<br>是围绕行旅来构思上下联。</p><p>最难风雨怀人夜<br>无奈关山见月时（《人•月》六唱）<br>虽然”风雨”与”关山”是属邻对，但上联之”夜”，正是下联的”见月时”，是用时间来作沟通。</p><p>世多钱虏铜遗臭<br>我有梅花雪孕香（《铜•雪》五唱），<br>此联除”香”和”臭”以外，几乎全为宽对，但上下联在辞意上有强烈对比，反而产生良好效果。 </p><p>应该说，《雪鸿初集》中的大多数（80％以上）嵌字诗钟都注意了上下句间的文思关联，做到互相呼应、映衬和补充，从而防止了由嵌字本身可能引起的上下联间的句意断裂。其主要技巧是，让上下联写同一主题（如：写景、怀人、言志和行旅……），或同一时空，乃至反衬等等。 </p><p>三、反对、旁对之妙用 </p><p>《文心雕龙》曰：”反对为优，正对为劣”，”反对者，理殊趣合也；正对者，事异义同者也”。刘熙载也说：”绝句体每首只有四句，容量很少，难以尽情抒写，这就需要有一种’妙用’，要取径深曲，盖意不可尽以不尽尽之，正面不写写反面，本面不写写对面、旁面，须如睹影知竿乃妙。”（《艺概》），以上论述亦适用于诗钟。</p><p>在《雪鸿初集》中，反对的例子如：上下联一往一返：</p><p>移篷拟向明湖泛<br>策杖曾从日观归（《明•日》五唱）；</p><p>一晴一雨：<br>明月楼台秋似水<br>落花庭院雨如烟（《秋•雨》五唱）；</p><p>一有一无；<br>疑无路入危峰隔<br>别有天开曲径通（《路•天》三唱）；</p><p>一水一陆，或一高一下：<br>霜凌老树头皆秃<br>月上横塘水更明（《头•水》五唱），等等。 </p><p>旁对的例子如：上下联一见一闻：<br>菊残篱下金无色<br>竹折阶前雪有声（《金•雪》五唱）；</p><p>夹岸泉声穿石出<br>隔江云影挟山来（《石•山》六唱）；</p><p>一天一地：<br>潮生远岸平无际<br>云互寒天影不流（《平•影》五唱）；</p><p>一人一我：<br>我亦爱莲尘不染<br>人能如菊淡何妨（《尘•淡》五唱），等等。 </p><p>以上这些反对和旁对的例子，都是通过语境和视角的转换和对比，来取得上下联浑然一体、珠圆玉润的效果，而达到活泼隽永、含蓄天成的境界。 </p><p>四、工对、宽对的权衡 </p><p>据对《雪鸿初集》六卷的初步统计，在全卷197联中，全用工对的有69联，占35％，仅为三分之一强。”诗人之所以不处处都用工对，自有其修辞上的理由。近体诗受平仄的拘束已经不小，如果在对仗上也处处求工，那么，思想就没有回旋的余地了。再者，求工太过，就往往弄到同义相对”（王力：《汉语诗律学》），反而容易造成合掌。因此，对仗工整并不意味处处必须工对，只要”境与意会”（东坡语），即使是邻对或宽对，也能使诗联臻于上乘，《雪鸿初集》中的一些例子就是明证。 </p><p>就如明代朱承爵所言：”作诗之妙，全在意境融彻，出音声之外，乃得真味”（《存余堂诗话》）。作诗自以立意为先，特别是对于嵌字诗钟，更要注意创作时的整体思维，避免上下联间的句意断裂。</p><h3 id="诗钟直观式嵌字格图谱-完整版"><a href="#诗钟直观式嵌字格图谱-完整版" class="headerlink" title="诗钟直观式嵌字格图谱(完整版)"></a>诗钟直观式嵌字格图谱(完整版)</h3><p>为便于嵌字诗钟的学习，我根据张西厢《闲话诗钟》中列举出的嵌字诗钟格式，整理出了一个比较直观的图式，因为自觉方便使用，尤其是年龄大的钟友们用起来会更为简捷、方便，因此将它放到了在国粹网上与大家分享。从挂在网上一年来的效果来看，钟友们比较认可它，也有很多老师提出了此图谱尚有欠缺, 如一些格式和别名没有收录等。故对本图谱作了进一步的补充。</p><p>另外，学习诗钟若仅止于格式，便会流于末学。希望钟友们经常翻看一下钟坛上疏竹先生置顶的《诗钟理论文献索引》中有关诗钟的资料，这些都是前辈们留下的精华，多读会有诸多的脾益。</p><p>钟格分为八大类：合咏，笼纱，晦明，分咏，分咏连环，专咏，专咏连环，嵌字。</p><p>嵌字格又称嵌珠格, 有正格与别格之分：</p><p>嵌2字正格7种：鹤顶，燕颔，鸢肩，蜂腰，鹤膝，凫胫，雁足。</p><p>嵌2字别格7种：魁斗，蝉联，比翼，流水，云泥，太极，辘轳。</p><p>嵌3字别格3种：汤网，勾股，鼎峙。</p><p>嵌4字别格2种：双钩，睡珠。</p><p>嵌6字别格1种：竹节。</p><p>碎锦类8种：碎锦，鸿爪，四皓，五杂俎，六逸，七贤，八龙，九老。</p><p>还有些不常见的钟格：</p><p>韵律类1种：拗体。</p><p>集句类3种：集句，集锦，居易。</p><p>改句类2种：续句，改句（包括折腰格）。</p><p>杂体类5种：四言，五言，八言，骈体，散文（包括流水碎和押尾格）。</p><p>其它类3种：虚词，方言，钟谜。</p><p>以下主要是叙述诗钟嵌字格式，其他格式不加赘述。</p><p>一、嵌2字正格：</p><p>1、一唱 凤顶格<br>又称冠顶格、鹤顶格、虎头格等。</p><p>嵌□□□□□□<br>嵌□□□□□□</p><p>2、二唱燕颔格又称凫颈格。</p><p>□嵌□□□□□<br>□嵌□□□□□</p><p>3、三唱鸢肩格又称鸳肩格。</p><p>□□嵌□□□□<br>□□嵌□□□□</p><p>4、四唱蜂腰格 </p><p>□□□嵌□□□<br>□□□嵌□□□</p><p>5、五唱鹤膝格</p><p>□□□□嵌□□<br>□□□□嵌□□</p><p>6、六唱凫胫格又称鹭胫格。</p><p>□□□□□嵌□<br>□□□□□嵌□</p><p>7、七唱雁足格又称鱼尾格、坐脚格。</p><p>□□□□□□嵌<br>□□□□□□嵌</p><p>二、嵌2字别格</p><p>1、魁斗格又称玉盒格。</p><p>嵌□□□□□□<br>□□□□□□嵌</p><p>2、蝉联格又称蝉连格、连理格。</p><p>□□□□□□嵌<br>嵌□□□□□□</p><p>3、辘轳格</p><p>可根据下面的格式类推。</p><p>□□嵌□□□□<br>□嵌□□□□□</p><p>嵌□□□□□□<br>□嵌□□□□□</p><p>4、比翼格2个题字分嵌于上下比相对的位置上，一至七唱。</p><p>嵌嵌嵌嵌嵌嵌嵌<br>嵌嵌嵌嵌嵌嵌嵌</p><p>5、云泥格即鹭拳格</p><p>张西厢原谱为题字分嵌上下比中，位置不可相对。</p><p>□嵌□□□□□<br>□□□嵌□□□</p><p>时有国粹网疏竹先生于2006年2月12日发表《为诗钟“云泥格”正名》一文，将云泥格订正如下：</p><p>云泥格又名鹭拳格：拈平仄二字为题字，嵌于诗钟出句第二字及对句第六字，或出句第六字及对句第二字。</p><p>6、太极格回文+2个比翼格嵌字。</p><p>□□□嵌□□□<br>□□□嵌□□□</p><p>7、流水格</p><p>嵌字同比翼格，但要求联语上下句意须相贯，似流水不断（即如流水对）。</p><p>□□□嵌□□□<br>□□□嵌□□□</p><p>三、嵌3字别格</p><p>1、汤网格以三字分嵌两句，题中两字作对，限位嵌于上下比首尾。余一字不连，亦嵌余下的首尾处。</p><p>嵌□□□□□□<br>嵌□□□□□嵌</p><p>嵌□□□□□嵌<br>嵌□□□□□□</p><p>□□□□□□嵌<br>嵌□□□□□嵌</p><p>嵌□□□□□嵌<br>□□□□□□嵌</p><p>2、勾股格以三字分嵌两句，题中两字可对，不限位。余一字不连，随意可嵌。</p><p>□□□嵌□□□<br>□□□嵌□嵌□</p><p>□嵌□□□嵌□<br>□嵌□□□□□</p><p>□□□□□嵌□<br>□嵌□□□嵌□</p><p>□□□□嵌□□<br>□嵌□□嵌□□</p><p>3、鼎峙格又称品字格。题字分嵌于上下比中，如鼎足。</p><p>□□□嵌□□□<br>嵌□□□□□嵌</p><p>嵌□□□□□嵌<br>□□□嵌□□□</p><p>四、嵌4字别格</p><p>1、双钩格又称香囊格。<br>四字钟题，题字分嵌上下比于首尾。</p><p>嵌□□□□□嵌<br>嵌□□□□□嵌</p><p>2、睡珠格</p><p>四字钟题，两字相联分嵌于上下句，不拘位置，唯求字次平行相对即可。</p><p>□□□嵌嵌□□<br>□□□嵌嵌□□</p><p>嵌嵌□□□□□<br>嵌嵌□□□□□</p><p>五、嵌6字别格</p><p>竹节格六个题字，分别嵌入上下句的二、四、六的位置上。但六个字中，须三字是平声字，三字是仄声字方可。</p><p>□嵌□嵌□嵌□<br>□嵌□嵌□嵌□</p><p>六、碎锦类</p><p>1、碎锦格又称流水碎、碎流格、七碎格、散嵌格。</p><p>将四字题字或四字以上的题字，分嵌于任意一句或上下句的任意位置上，不能相并。对嵌四字的碎锦格，历来还是有“不连不对”的严格规定。</p><p>□嵌□□嵌□□<br>嵌□□嵌□□□</p><p>余下以此类推。</p><p>2、鸿爪格</p><p>三字碎锦格，题字不得相连。</p><p>□嵌□□嵌□□<br>□□嵌□□□□</p><p>余下以此类推。</p><p>3、四皓格</p><p>四字碎锦格，题字不得相连。</p><p>□嵌□□嵌□□<br>□□嵌□嵌□□</p><p>余下以此类推。</p><p>4、五杂俎格</p><p>有时人也称之“五俎”</p><p>碎锦格之一。五字钟题，题字随意分嵌，不得相连。</p><p>□嵌□□嵌□嵌<br>□□□嵌□嵌□</p><p>5、六逸格</p><p>碎锦格之一。六字钟题，题字随意分嵌，可连2个字。</p><p>嵌嵌□□嵌□嵌<br>□□嵌□□嵌□</p><p>6、七贤格</p><p>碎锦格之一。七字钟题，题字随意分嵌，可连2个字。</p><p>嵌嵌□嵌□嵌□<br>□□嵌□嵌□嵌</p><p>7、八龙格</p><p>碎锦格之一。八字钟题，题字随意分嵌，可连3个字，可对。</p><p>嵌嵌嵌□嵌□嵌<br>□嵌□嵌□嵌□</p><p>8、九老格</p><p>碎锦格之一。九字钟题，题字随意分嵌，可连4个字，可对。</p><p>嵌嵌嵌嵌□□嵌<br>嵌□嵌嵌□嵌□</p><p>七、综合类</p><p>这一类是我依照多格相叠又包含嵌字的原则划出的，共4类，6种格式。</p><p>1、晦明格</p><p>随意嵌一题字于一比中，另一题字为咏。</p><p>□□□□□嵌□<br>□□□□□□□</p><p>□□□□□□□<br>□□嵌□□□□</p><p>注：此格本为诗钟单独的一类，因为有一字明嵌故作为特例列出。</p><p>2、专咏格又称单吟格（即合咏+嵌字）。限咏一个主题，禁犯题字。嵌2字，所嵌2字即为题字。</p><p>□□□嵌□□□<br>□□□嵌□□□</p><p>3、连环唱 </p><p>（1）上楼格 2字题。题字限做一套，由一唱至七唱。</p><p>嵌嵌嵌嵌嵌嵌嵌<br>嵌嵌嵌嵌嵌嵌嵌</p><p>（2）下楼格 2字题。题字限做一套，由七唱至一唱。</p><p>嵌嵌嵌嵌嵌嵌嵌<br>嵌嵌嵌嵌嵌嵌嵌</p><p>4、连环格</p><p>（1）合咏连环格</p><p>又称单吟连环格、专咏连环格、专吟连环格、单咏连环格。</p><p>一命题作一联诗钟，禁犯题字。同时限定嵌字的字数和唱位，或不限唱位。</p><p>□嵌□嵌□□□<br>□嵌□嵌□□□</p><p>（2）分咏连环格 </p><p>与分咏格相同，上下句各吟各的主题，但限定嵌字的唱位和字数。也可以根据嵌字的字数，同时限定嵌字格，与合咏连环格相似。如以下方式以此类推。 </p><p>□□□嵌□□□<br>□□□嵌□□□<br>□嵌□□□□□<br>□□□□□嵌□<br>□□□嵌□□□<br>嵌□□□□□嵌<br>嵌□□□□□嵌<br>嵌□□□□□嵌</p><p>说明：</p><p>1、本文诗钟格式增补基本上是参照李竹深《辞赋余韵话诗钟》中列出的格式。敬礼一下前辈。<br>2、本文中诗钟的分类引用了网上扫叶成堆之《外篇之&lt;你也可以对对联&gt; 诗钟》的分类格式，特此说明，并向撰写该文的老师表示谢意！<br>3、在网上还搜集到了一些其他的资料，也为最后定稿提供了佐证，在这里一并谢过。</p><h3 id="诗钟"><a href="#诗钟" class="headerlink" title="诗钟"></a>诗钟</h3><p>一、诗钟的概念<br>诗钟是中国古代文人的一种限时吟诗文字游戏，大约出现在嘉庆、道光年间的福建八闽地区。诗钟限一炷香功夫吟成一联或多联，香尽鸣钟，所以叫做“诗钟”。诗钟吟成，再作为核心联句各补缀成一首律诗，游戏结束。诗钟多半限定内容（诗题）、文字和种格，比如诗钟分咏，限“来、去”，即上联必须有“来”，对下联的“去”字。诗钟比一般对联要求格律更工整，内容更含蓄，甚至类似谜语才好<br>如果限“来、去，七联”，则必须吟成七字对联七幅，“来、去”分别位于句中的七个不同位置。更有甚者，先固定每句的第一个字，比如“来”和“去”，再限“来、去，七联”，比如《枫影榃诗词》中有（不是严格意义上的诗钟）：<br>[1]来而不往非常礼，去若能归是醉仙<br>　　来来往往千帆竞，去去回回百鸟旋<br>　　来世来生都不管，去愁去病复何求<br>　　来即速来三万贯，去须长去一千年<br>　　来财怎及来名好？去势常随去世行<br>　　来年只恐成来世，去病谁知要去愁<br>　　来世不知何处去？去年难得此间来<br>去年今夜关山月，来日洞房花烛人<br>　　去去烟波失樯橹，来来语势夺君臣<br>　　去国去家三十载，来名来利一场空<br>　　去愁须去心窝火，来信捎来人附言<br>　　去官揖别去时友，来客掸弹来处尘<br>　　去职居然无去路，来人端的有来头<br>　　去奔人家穷处去，来寻官府败时<br>有心立说垂青史，无计营生愧老妻<br>　　世有牢笼谁就范？天无绝路我行医<br>　　三餐有泪下稀粥，六月无钱买短衣<br>　　三人行有我施主，万卷书无肯得鸡<br>　　神游天国有仙鹤，身在江湖无湿衣<br>　　雨打茅蓬皆有眼，鱼游涸辙殆无诗<br>　　旷世奇才何处有？长篇小说大师无<br>无复万家新气象，有如千载古城楼<br>　　不无遗憾英雄死，犹有虚名中外浮<br>　　遍地无情焚物欲，漫天有雾障瞳眸<br>　　野外寻无栖息鸟，朝中踞有办公猴<br>　　人间莫道无民主，鼻上还疑有自由<br>　　官家脸面最无耻，铁石心肠必有求<br>　　点开百度一搜有，除却双规半句无<br>《闲话诗钟》<br>作者：张西厢<br>钟义<br>昔人敲钟，规律极严，拈题时，缀钱于缕，焚香寸许，承以铜盘，香焚缕断，钱落盘鸣，以为构思之限，故名“诗钟”，即刻烛击钵之遗意也。钟虽小品，惊天地，泣鬼神，征夫怨妇之思，怀乡忧国之感，均可流露于寥寥十四字中，变化无穷，奥妙莫测，固属雕虫小技，亦洋洋乎大观，或谓此中兴味，胜诗十倍，经验之语<br>钟意<br>诗钟固重对仗，尤重立意，无意义之诗钟，谓之“哑钟”，敲之不响，唱之无味。盖以白粉墙对黑漆板之类，决难引人入胜，粤派之弱点，即在于此。故正宗之诗钟，须有诗之声调风格，置之于诗中，则为名诗，置之于钟中，则为名钟。或谓诗钟，须有起承转合之势，未免言之过甚，盖诗钟为七律诗之一联，古人名联，或对描事物，或直舒怀抱，绝少于一联中，备有起承或转合之势也。<br>钟派<br>清初闽人，已有此制，名日“改诗”，即改律句绝句之七言诗而为两句也，此种改诗，或有称之为单羊角对百衲琴，雕玉双钩者，要皆不如诗钟名称之普遍。诗钟向有闽派、粤派之分，两派之争至今未息，闽派重空灵尚意义，粤派重典实尚对仗，平心而论，两派各有所长，能化粤派之典实，而兼闽派之空灵，斯为上乘，忆粤人蔡乃煌为钟坛宿将，且以敲钟得官，然每阅及粤派钟卷，即投之于簏中。故粤、闽两派之分，亦非限于人地也。近人林熊祥先生，对于诗钟之意见主张宽大其门径，使成为一种较绝句更为锤炼之诗，而侪于一般诗歌之列，善于此道者，多抱同感，若能别树一帜，使此铁钟而成为原子钟，不可谓非艺术界之一大改进也。<br>钟社<br>独起敲钟，兴味索然，故欲敲钟，必先集社，钟社之设，并无若何组织，亦无任何作用，不过文人墨士，藉以发舒怀抱，联络感情而已。近数年来，台、港两地，钟社之多，竟达四十余处，可谓盛矣。岂欲敲醒国魂欤，激扬民气欤，余拭目以俟之。<br>钟眼<br>钟眼须稳，务求不能移易，例如联与连，不得相混，用连床则可，用联床则不可，床与榻，不得相借，用东床则可，用东榻则不可。钟眼，更以有来历为佳，例如“千雪”一唱“千眼西方般若佛；雪肤南内太真妃。”千眼出自佛典千眼千手观世音，雪肤出自长恨歌“雪肤花貌参差是”。钟眼如不相称，则对仗更须求其工稳，上例“千”与“雪”绝不相称，而以“眼”、“肤”承对，可称能手。<br>钟题<br>普通拈题，常用抽字及翻书等法，以昭公允，分咏事物者，于书中翻出两事物，嵌字格则于书中任翻数字，作为钟题，绝少由每人自出题目也。分咏、合咏不可犯题面字，例如分咏“元宵”、“蝶”。则钟句须避用“元宵蝶”三字。分咏合咏事物，并忌以代替字明点题意，例如“象、扇”分咏。若用大兽、交趾兽、挥羽、羽毛、一羽、裁纨等字，不啻将题字明明点出，决难得到佳句，且易失去题意。例如“争钦挥羽运奇谋”、“指挥一羽定三分”明明是咏卧龙而非咏扇也。钟题可任意加以某种限制，以增兴趣，如合咏“竹”限用一“毛”字，则钟联中，须有“毛”字。反之，亦可禁用“虚节风月?竿箨君妃栽”十字，则钟联中须避用此十字也。此外，尚有更严格之限制者，即钟题虚字而限实用，例如“而了”二唱，则须实用“吉了”、“以而”；“若于”二唱，则须实用“兰若”、“杜于”；“若然”二唱，则须实用“巨然”、“贺若”等等，方为合格，文人墨客，兴到之余，好用其极也。分咏、合咏，以切正本题不能移咏别人别物者为原则，严格言之，咏狗者不能移到犬，咏冠者不能移到帽。<br>钟典<br>古人名句，多用常语而不用典，如“露从今夜白；月是故乡明。”语虽浅近，意则深长，诗钟亦何独不然，不得已而用典，既忌过僻，而点题亦极严格，咏“履”不能引用“鞋”典，咏“眼”不能引用“目”典，以原典有履字眼字者为合格，如“象、扇”分咏，引用焚身典，多有以牙代齿者，殊为不妥，盖原典是齿而非牙也。钟贵典丽堂皇，引用僻典固不宜，即稗官野史之章回小说，亦须避用为宜。<br>钟句<br>诗钟常因限于题字及题字之位置，而造句煞费苦心。总之，以字字不落空，字字不能移易为佳制。例如“两空”六唱“不住猿声啼两岸；但闻人语响空山。”字字出自唐诗，字字不能移易，可称闽派中之佳制。基此理由，若能分集古人诗句，或古人诗意，且对仗工整，而切合题意者，较之自造，尤胜一筹。造句之技术，尤贵奇峰突出，例如“红豆啄残鹦鹉粒；碧梧栖老凤凰枝。”若易以“鹦鹉啄残红豆粒；凤凰栖老碧梧枝。”则较平实无奇矣，当年杜老，亦何曾不推敲及此乎。钟句避用叠字，盖仅仅十四字之小品，一字千金，不宜浪费半字，若以钟眼而叠字，则更不可，如“元旦”四唱，倘用元元、旦旦之叠字，则为三唱乎，抑为四唱乎。分咏事物之造句，常因两事物之相距过远，而难于落笔者，于此时须先觅对字，再就对字而构思，例如分咏“汉光武、燕”。先觅赤帻、紫襟等之对字，分咏“牧童、蛇”先觅骑牛、吞象等之对字，则自易落笔矣，惟追求对像，须下工夫，务使有鸳鸯交颈、鸾凤和鸣之妙，不可有彩凤随鸦、鲜花插粪之嫌。<br>钟对<br>诗钟固重立意，并重对仗，有半字之差者，即非上乘。以虚对虚、实对实、地名对地名、姓名对姓名、颜色对颜色、朝代对朝代为工整。若字面亦能相对，如放翁对茂叔，司马对卧龙更佳。诗钟虽为诗之一联，然切忌流水对法，而对仗亦不宜假借，例如<br>身无彩凤双飞翼；心有灵犀一点通。<br>春蚕到死丝方尽；蜡炬成灰泪始干。<br>在诗则为名句，在钟则嫌其以“翼”对“通”。以“春蚕”对“蜡炬”，不能合格。惟如前例，以“人语”对“猿声”，两字连用，借对一字者，则无不可。而双用常语，如“天地”对“古今”，“春秋”对“江汉”，则更无不可。<br>诗钟常有以字面相对而假借者，例如“重九”五唱，“昂藏愿拜重瞳象；谄媚宁容九尾狐。”“象”与“狐”，字面相对而实不对，虽极巧妙，亦以少用为上。盖“九尾狐”为一固定名词，而“重瞳象”则否，难免对仗不称之嫌。此外，以一物对两物者，谓之“三脚钟”，例如“风云”对“秋月”，“雨露”对“春烟”，风云、雨露，各为二物，而秋月、春烟，各为一物，在律诗中尚嫌不称，何况诗钟。<br>出比、对比，须凑合天然，铢两悉称，若一比堂皇，一比纤巧，一比如天，一比如井，彼此失衡，谓之“跛脚钟”，作者最易犯此通病，故往往一比自然，一比则生硬，一比如香象渡河，一比则如黠鼠偷油，一比吓煞夫人，一比则跪在?下。初抱“句不惊人死不休”之奢望，卒之反有“满城风雨近重阳”之叹，若能先从平易处着笔，则可减少此种困难也。出比用典，则对比亦须用典，而典故时代，不宜相距过远，如以三代典故属对三代典故固佳，即属对秦汉典故亦可，若两时代相距过远，或引用典故之内容，彼此失衡，均为小疵。盖以吴道子之钟馗与潘雅声之美人，并悬于书室中，终觉不称也。<br>钟律<br>诗律要细，钟亦何独不然，古人律诗，求其最合诗钟之条件者，惟少陵耳。如<br>　　旌旗日暖龙蛇动；宫殿风微燕雀高。<br>　　笋根稚子无人见；沙上凫雏傍母眠。<br>　　江上小堂巢翡翠；苑边高冢卧麒麟。<br>　　老妻画纸为棋局；稚子敲针作钓钩。<br>　　江间波浪兼天涌；塞上风云接地阴。<br>　　波飘菇米沉云黑；露冷莲房坠粉红。<br>　　羞将短发还吹帽；笑倩旁人为正冠。<br>　　蓝水远从千涧落；玉山高并两峰寒。<br>　　岸容待腊将舒柳；山意冲寒欲放梅。<br>　　刺绣五纹添弱线；吹葭六管动飞灰。<br>　　五更鼓角声悲壮；三峡星河影动摇。<br>　　花径不曾缘客扫；蓬门今始为君开。<br>　　盘餐市远无兼味；樽酒家贫只旧醅。<br>　　海内风尘诸弟隔；天涯涕泪一身遥。<br>　　北极朝廷终不改；西山寇盗莫相侵。<br>诸联，若置之于钟中，称之为“钟圣”，谁曰不宜。而“旌旗日暖龙蛇动；宫殿风微燕雀高”一联之浑雄庄晒，尤可作为首选之标准也。<br>钟声<br>香港钟声多，而台湾更多，真有“姑苏城外寒山寺；夜半钟声到客船。”之感，顾名思义，诗钟之声调，须和谐而响亮，始足发人深省，因之平仄不可失调，第一字可不论，第三第五字则必论，出比第三字可不论，对比第三平字则必论，例如“珠帘暮卷西山雨；画栋朝飞南浦云。”、“巫峡啼猿数行泪；衡阳归雁几封书”在诗固称名句，在钟则嫌数字拗韵，而“南”字失调也。至若对比第三字，应平而用仄，在古人七律诗中，尚不多见，况于钟乎<br>钟评<br>评选诗钟，为一难事，见仁见智，各有不同，惟古人名句，传诵至今，犹众囗同声，盖文艺自有其客观之优点，绝非成见或感情所能左右也。尝读唐司空图所列《诗品》二十四种，见地极高，可作诗钟评选之标准，即雄浑第一、冲淡第二、沉着第三、高古第四、纤?第五、典雅第六、洗练第七、劲健第八、绮丽第九、自然第十、含蓄第十一、豪放第十二、精神第十三、缜密第十四、疏野第十五、清奇第十六、委曲第十七、实境第十八、悲慨第十九、形容第二十、超诣第二十一、飘逸第二十二、旷达第二十三、流动第二十四。捐除成见。破除情面。执此尺以量之。可无遗恨矣。<br>钟格<br>概说<br>诗钟格式，可分：合咏格、分咏格、笼纱格、嵌字格四类。而嵌字格又分：凤顶、燕颔、鸢肩、蜂腰、鹤膝、凫胫、雁足、魁斗、蝉联、辘轳、比翼、汤网、云泥、鼎峙、晦明、碎锦、双钩、四皓、五姐、六逸、七贤、八龙、九老等格，分述于左。<br>合咏格<br>即将题意表现于钟联中，以不犯题字为原则。亦有例外者，并得随意加以某种限制，例如。<br>花落知多少：合咏，不犯题字<br>绣坏料添红一片<br>锦茵应减绿三分<br>凄凉墙外飘难数<br>狼藉阶前扫几回<br>分咏格<br>简介<br>即分咏事物也，以不犯题字为合格，例如<br>岳飞、虎：分咏<br>画尔不成翻类犬</p><p>诗钟分咏意境<br>字之曰举并称鹏<br>笔、邮票：分咏<br>万国花封元首相<br>五云草判黑头公<br>笼纱格<br>即将题字暗藏于钟联中，隐约如见，呼之欲出，例如<br>左易：笼纱格<br>牙因知味承恩幸<br>思未能言擅赋才<br>嵌字格<br>格体简介<br>1、凤顶格 即将两题字分嵌于每句之第一字，所谓“一唱”也，例如<br>人鸟：一唱<br>人凭赤血羸犹健<br>鸟到青云倦亦飞<br>2、燕颔格 即将两题字分?于每句之第二字，所谓二唱也，例如<br>醉吟：二唱<br>臣醉酒能倾一石<br>客吟诗已载三车<br>3、鸢肩格 即将两题字分嵌于每句之第三字。所谓三唱也。例如<br>红豆：三唱<br>灯光豆灺劳人草<br>楼影红飞思妇花<br>4、蜂腰格即将两题字分嵌于每句之第四字。所谓四唱也，例如<br>元旦：四唱<br>千军待旦传刁斗<br>万国朝元拜冕旒<br>5、鹤膝格 即将两题字分嵌于每句之第五字。所谓五唱也。例如<br>重、九：五唱<br>要为卷土重来计<br>谁赞勤王九合功<br>6、凫胫格 即将两题字分嵌于每句之第六字。所谓六唱也。例如<br>意、飞：六唱<br>斜阳六伐鸦飞乱<br>明月孤山鹤意痴<br>7、雁足格 即将两题字分嵌于每句之第七字。所谓七唱也。例如<br>鹤梅：七唱<br>隐现云端千岁鹤<br>横斜竹外一枝梅<br>8、魁斗格 即将两题字任意分嵌于第一字及第十四字。例如<br>黄花：魁斗格<br>花门积雪千山白<br>大漠飞沙一月黄<br>9、蝉联格 即将两题字分嵌于第七字及第八宇。例如<br>蝉唱：蝉联格<br>花落后庭商女唱<br>蝉鸣西陆楚囚吟<br>10、辘轳格即将两题字分嵌于第一字及第九字。或第三字及第九字，以此类推。例如<br>莲露：辘轳格<br>乍垂莲瓣移香步<br>微露瓠犀发妙香<br>11、比翼格 即将两题字任意对嵌于钟联中。等于一唱至七唱。例如<br>散书：比翼格}<br>杜房并驾中书省<br>金宋相持大散关<br>12、汤网格即将三个题字。任意分嵌于两句之首末。而成网开一面之局。例如<br>天、安、云：汤网格<br>天末楼台横北固<br>云中城阙望西安<br>13、云泥格 即将题字分嵌于两句中。但不得相对。例如<br>云泥：云泥格<br>青云直上鹏程路<br>华屋偏多燕垒泥<br>14、晦明格 即一句明点题字，一句暗写题字。例如<br>红豆：晦明格<br>双肿如豆讥文士<br>一口含樱画美人<br>15、鼎峙格 将三个题字分嵌于第1字第7字第11字。或分嵌于第4字第8字第14字。成鼎峙之格。例如<br>天中节：鼎峙格<br>穷阴杀节霜铺地<br>中夜清寒月满天<br>16、碎锦格亦称鸿爪格。即将题字（二字或以上）分嵌于钟联中不得相连。例如<br>张陈：碎锦格<br>满几陈编三寸烛<br>半肩行李一张琴<br>17、双钩格即将四个题字对嵌于钟联首尾之中。例如<br>南北高丽：双钩格<br>丽水逆流环陇北<br>高邮名县着淮南<br>18、四皓格 碎锦格之一种。题字不得相连。例如<br>海角钟声<br>海城画角严兵卫<br>山阁诗钟集友声<br>19、五杂俎碎锦格之一种。题字不得相连。例如<br>清泉石上流<br>溪边瘦石多清籁<br>岩上飞泉少浊流<br>20、六逸格 碎锦格之一种。惟题字可以相连。例如<br>杏花春雨江南：得连二字。<br>雨后寻春桃叶渡<br>江南沽酒杏花村<br>21、七贤格 碎锦格之一种。题字可以相连。例如<br>发无可白方为老：得连二字。<br>无眠可到东方白<br>有发都为老境苍<br>22、八龙格 碎锦格之一种。题字可以相连。例如<br>月明华屋画桥碧阴：得连三字。<br>小桥画舫摇明月<br>华屋芳林度碧阴<br>23、九老格 碎锦格之一种。题字可以相连。例如<br>寒鸦万点流水绕孤村：得连四字。<br>水流孤塞千声雁<br>村绕寒林万点鸦</p>]]></content>
      
      
      <categories>
          
          <category> 文学作品 </category>
          
          <category> 诗钟-课外补读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌、思维、样式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript复习</title>
      <link href="/2020/08/16/JavaScript%E5%A4%8D%E4%B9%A0/"/>
      <url>/2020/08/16/JavaScript%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="javaScript"><a href="#javaScript" class="headerlink" title="javaScript"></a>javaScript</h1><h2 id="数组遍历的两种方法"><a href="#数组遍历的两种方法" class="headerlink" title="数组遍历的两种方法"></a>数组遍历的两种方法</h2><h3 id="for循环遍历"><a href="#for循环遍历" class="headerlink" title="for循环遍历"></a>for循环遍历</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;孙悟空&#x27;</span>,<span class="number">145</span>,<span class="string">&#x27;孙空&#x27;</span>,<span class="number">155</span>,<span class="string">&#x27;悟空&#x27;</span>,<span class="number">1585</span>,<span class="string">&#x27;杨戬&#x27;</span>,<span class="number">155</span>,<span class="string">&#x27;白龙马&#x27;</span>,<span class="number">45</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;arr.length; i++)&#123;</span><br><span class="line">            alert(<span class="string">&quot;常见于各种数组的遍历&quot;</span>)</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><h3 id="forEach专门用于遍历"><a href="#forEach专门用于遍历" class="headerlink" title="forEach专门用于遍历"></a>forEach专门用于遍历</h3><p>  其一种 foEach()需要函数作为参数<br>                浏览器会自动遍历元素，并且以形参的形式传递<br>                回调函数产生三个函数</p><ol><li>第一个参数：当前正在遍历的元素</li><li>第二个元素：当前元素正在遍历的索引</li><li>第三个元素：正在遍历的数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;孙悟空&#x27;</span>,<span class="number">145</span>,<span class="string">&#x27;孙空&#x27;</span>,<span class="number">155</span>,<span class="string">&#x27;悟空&#x27;</span>,<span class="number">1585</span>,<span class="string">&#x27;杨戬&#x27;</span>,<span class="number">155</span>,<span class="string">&#x27;白龙马&#x27;</span>,<span class="number">45</span>];</span><br><span class="line">        arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;heelo&quot;</span>)</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3>可以用来从数组中抽取指定的参数<br>该方法不会改变元素数组,而是将截取的元素封装到一个新的数组<br>参数:<br>1.截取刚开始的位置索引,包含开始索引<br>2.截取结束位置索引,不包括结束索引<br>第二个参数可以不写,这样的话第一参数以后都会被截取<br>索引可以为负<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;孙悟空&#x27;</span>,<span class="number">145</span>,<span class="string">&#x27;孙空&#x27;</span>,<span class="number">155</span>,<span class="string">&#x27;悟空&#x27;</span>,<span class="number">1585</span>,<span class="string">&#x27;杨戬&#x27;</span>,<span class="number">155</span>,<span class="string">&#x27;白龙马&#x27;</span>,<span class="number">45</span>];</span><br><span class="line"><span class="keyword">var</span> result =arr.slice(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line">result = arr.sloce(<span class="number">1</span>,-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3>可以用于删除数组,会指定元素删除<br>会影响到原数组,删除的元素会作为返回值返回<br>参数:<br>1.表示开始索引位置<br>2.表示删除数量<br>3.可以传递新的元素,这些元素将自动插入到开始索引<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;孙悟空&#x27;</span>,<span class="number">145</span>,<span class="string">&#x27;孙空&#x27;</span>,<span class="number">155</span>,<span class="string">&#x27;悟空&#x27;</span>,<span class="number">1585</span>,<span class="string">&#x27;杨戬&#x27;</span>,<span class="number">155</span>,<span class="string">&#x27;白龙马&#x27;</span>,<span class="number">45</span>];</span><br><span class="line"><span class="keyword">var</span> result = arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;牛魔王&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3>可以链接多个数组,并将多个数组返回<br>该方法不会对原数组产生影响 有返回值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;孙悟空&#x27;</span>,<span class="number">145</span>,<span class="string">&#x27;孙空&#x27;</span>,<span class="number">155</span>];</span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="string">&#x27;悟空&#x27;</span>,<span class="number">1585</span>,<span class="string">&#x27;杨戬&#x27;</span>,<span class="number">155</span>,<span class="string">&#x27;白龙马&#x27;</span>,<span class="number">45</span>];</span><br><span class="line"><span class="keyword">var</span> result =arr.concat(arr1)</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h3 id="joio"><a href="#joio" class="headerlink" title="joio()"></a>joio()</h3>该方法将数组转换成字符串<br>不会影响原数组 有返回值<br>可以指定一个字符串作为参数,当作连接符,不指定则默认’,’</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = arr.join();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> result);</span><br></pre></td></tr></table></figure><h3 id="reyerse"><a href="#reyerse" class="headerlink" title="reyerse"></a>reyerse</h3><pre><code>该方法用来反转数组该方法影响原数组 arr.reverse();</code></pre><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><pre><code>用来排序影响原数组</code></pre><p>  默认Unicode进行排序 对于数字排序时,可能会得到错误结果<br>  指定排序规则<br>        -定义两个形参 a b<br>         如果返回值大于0则元素会交换位置<br>         如果返回值小于0则元素位置不变<br>         如果返回值一个0,则认为两个元素相等,也不交换<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">77</span>,<span class="number">11</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//前面大</span></span><br><span class="line">      <span class="keyword">if</span>(a&gt;b)&#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125; );</span><br><span class="line"><span class="built_in">console</span>.log(arr);  </span><br></pre></td></tr></table></figure></p><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h3><p>  在调用函数时，浏览器每次都会传递两个隐含参数<br>1.函数的上下文对象call和apply<br>2.封装的实参对象arguments<br>    -arguments是一个类数组对象，它也可以通过索引来操作数据，可以 获取长度<br>    -在调用函数，我们所传的实参都会在arguments中 可以不定义实参可以使用形参<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.callee); 这个属性对应一个函数对象，当前调用的</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="string">&quot;hello&quot;</span>,<span class="number">45</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><p>如果创建使用构造函数创建的则是当前代码执行的时间<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a =<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure><br>指定创建一个时间对象，则需要在构造函数中传递一个时间字符作为参数<br>  格式<br>    月份/日/年 时：分：秒<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d2=<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;12/03/2020 11:10:21&#x27;</span>);</span><br></pre></td></tr></table></figure><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data=d2.getDaet();返回当前号数</span><br><span class="line"><span class="keyword">var</span> date1=d2.getday();返回当前日期</span><br><span class="line"><span class="keyword">var</span> date2=d2.getMonth();返回当前月份 </span><br><span class="line"><span class="keyword">var</span> daet3=d2.getFulyear();返回当前年份</span><br><span class="line"><span class="keyword">var</span> time=d2.getTime();返回当前时间戳 格林威志标准时间<span class="number">1970</span>/<span class="number">1</span>/<span class="number">0</span> <span class="number">0</span>：<span class="number">0</span>：<span class="number">0</span> 毫秒数</span><br><span class="line">  -alert(time/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>/<span class="number">365</span>)</span><br><span class="line">    -获取当前（代码执行）的时间戳 time = <span class="built_in">Date</span>.now();</span><br></pre></td></tr></table></figure></p><h2 id="Math：-W3school"><a href="#Math：-W3school" class="headerlink" title="Math： W3school"></a>Math： <a href="https://www.w3school.com.cn/jsref/jsref_obj_math.asp">W3school</a></h2><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>String()<br>  -可以将基本类型字符串转换成String<br>Number()<br>  -可以将基本数据类型数字装换成Number<br>Boolean()<br>  -可以将基本数据类型布尔值转换成Boolean<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> str=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> bool=<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><font color=#FF0000 >包装类基本上不自己使用浏览器会自动创建，用完则销毁</font>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql基本语法</title>
      <link href="/2020/08/16/Mysql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2020/08/16/Mysql%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL语法"><a href="#MySQL语法" class="headerlink" title="MySQL语法"></a>MySQL语法</h2><blockquote><p> show databases; 查看数据库<br>    show tables; 查看表<br>    delete from user where host=’master’ 删除表user里面的host<br>    update user set host=’%’ where host=’localhost’; 添加并修改user表host<br>    select user,host,password from user; 查询表user字段user,host,password<br>    flush privileges；  立即刷新，也可以重新启动 </p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js部分笔记</title>
      <link href="/2020/08/01/js%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/01/js%E9%83%A8%E5%88%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="局部-全局"><a href="#局部-全局" class="headerlink" title="局部 全局"></a>局部 全局</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> a=<span class="number">123</span>;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">        alert(a);</span><br><span class="line">        a =<span class="number">456</span>;</span><br><span class="line">&#125;  </span><br><span class="line">fun(<span class="number">456</span>);</span><br><span class="line">alert(a);</span><br></pre></td></tr></table></figure><h3 id="THIS"><a href="#THIS" class="headerlink" title="THIS"></a>THIS</h3><ul><li>解析器在调用函数时每次都会像函数内存传递一个隐含的参数<ul><li>这个隐含的参数就是this this指向的是一个对象</li><li>这个对象我们称之为函数执行的上下对象<ul><li>根据函数的调用方式不同，this会指向不同的对象</li><li>以函数得形式调用时，this永远都是Windows</li><li>以方法的形式调用，this就是调用方法那个对象</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;猴子&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">vae obj = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&quot;孙悟空&quot;</span>,</span><br><span class="line">    <span class="attr">sayName</span>:fun</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.sayName();</span><br></pre></td></tr></table></figure><p>大宋提刑官</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><blockquote><p> 创建一个构造函数，专门用来创建Perso对象的<br>    构造函数就是一个普通的函数，创建方式和普通函数没有区别<br>    不同的是构造函数习惯首字母大写<br>    区别：</p><blockquote><p>普通函数是直接调用 构造函数要用new调用<br>    1.调用构造函数会创建对象<br> 2.将新建对象设置为函数中this，在构造函数中使用this来引用新建对象<br>3.逐行执行函数的代码<br> 4.将对象作为返回值</p></blockquote><p>   使用同一个构造函数创建的对象，我们称之为类<br>    我们将通过一个构造函数创建的对象我们称之为实例<br>    对象 instanceof 构造函数 是则true 错则false 检查是否为实例</p><p>this的情况</p><blockquote><p>当以函数的形式调用时，thid是widows<br>    当以方法的形式调用时，该调用方法this就是谁<br>    当以构造函数的形式调用时，this就是新创建的对象</p></blockquote></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name,age,gender</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.naem = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    <span class="built_in">this</span>.syName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(thsi.naem);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> per =<span class="keyword">new</span> person(<span class="string">&#x27;孙悟空&#x27;</span>, <span class="number">41</span> ,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(per);</span><br></pre></td></tr></table></figure><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><blockquote><p>原型 prototype</p><blockquote><p>我们所创建的每一个函数，解析器都会像函数添加一个属性prototype<br>    这个属性对应着一个对象，这个对象就是我们所谓的原型对象<br>    如果函数作为普通函数调用没有任何作用 相反通过构造函数调用时,都会有个掩藏属性</p></blockquote><p>指向该对象的原型对象，我们可以通过<em>proto</em>来访问该属性<br>    原型对象就相当于公共区域，所有实例都会访问到这个原型对象中<br>    我们可以将对象中共有的内容，统一设置到原型中 当访问一个属性或方法会在自身对象中（子类）中寻找而后再去原型（父类型）再然后会去原型的原型中去寻找 （原型也是对象） 直到找到object的原型 如果没有找到则返回null<br>    可以使用hasOwnProperty()来检查对象自身中是否含有这个属性或者方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Myclass</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Myclass.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;我是原型&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> mc =<span class="keyword">new</span> Myclass();</span><br><span class="line"><span class="comment">//console.log(mc.sayHello);</span></span><br><span class="line">mc.sayHello();</span><br><span class="line"><span class="built_in">console</span>.log(Myclass.prototype == mc.__proto__) <span class="comment">//验证判断是否相等 结果是true</span></span><br></pre></td></tr></table></figure><h2 id="垃圾回收-GC"><a href="#垃圾回收-GC" class="headerlink" title="垃圾回收 GC"></a>垃圾回收 GC</h2><blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
